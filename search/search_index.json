{
    "docs": [
        {
            "location": "/", 
            "text": "BDD by example\n\n\n\n\nEste taller forma parte de las actividades del \nAula de Software Libre de la\nUniversidad de C\u00f3rdoba\n.\n\n\nEl material de esta documentaci\u00f3n est\u00e1 sacado de las presentaciones de \nhttps://es.slideshare.net/CiaranMcNulty\n:\n\n\n\n\nTDD with PhpSpec\n\n\nDriving Design through Examples", 
            "title": "Inicio"
        }, 
        {
            "location": "/#bdd-by-example", 
            "text": "Este taller forma parte de las actividades del  Aula de Software Libre de la\nUniversidad de C\u00f3rdoba .  El material de esta documentaci\u00f3n est\u00e1 sacado de las presentaciones de  https://es.slideshare.net/CiaranMcNulty :   TDD with PhpSpec  Driving Design through Examples", 
            "title": "BDD by example"
        }, 
        {
            "location": "/introduction/", 
            "text": "Introducci\u00f3n\n\n\nDesarrollo orientado a pruebas (TDD)\n\n\nTest Driven Development (TDD), o desarrollo orientado a pruebas, es un proceso de desarrollo de software muy conocido, que consiste en la repetici\u00f3n de ciclos de desarrollo muy cortos.\n\n\n\n\nLos requisitos se convierten en pruebas, unidades de c\u00f3digo que prueban una determinada funcionalidad.\n\n\nEntonces, se produce el c\u00f3digo justo que permite pasar dicha prueba.\n\n\n\n\nEste proceso es opuesto a otros sistemas de desarrollo que permiten incorporar c\u00f3digo que no se sabe con certeza si concuerdan o no con los requisitos.\n\n\nLos test que se pueden realizar pueden ser de unidad, funcionales y de aceptaci\u00f3n. Para todos estos tipos de test, en PHP podemos usar PHPUnit.\n\n\nCiclo del desarrollo orientado a pruebas\n\n\n\n\nA\u00f1ade un test\n\n\nEjecuta los test y comprueba que el nuevo test falla\n\n\nEscribe el c\u00f3digo\n\n\nEjecuta los test\n\n\nRefactoriza el c\u00f3digo\n\n\nRepite\n\n\n\n\nEjemplo de un test de unidad con PHPUnit\n\n\nSi queremos implementar una clase que implemente funciones matem\u00e1ticas, este ser\u00eda el c\u00f3digo de una prueba unitaria que, con PHPUnit, escribir\u00edamos para implementar la funcionalidad \nsuma\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n?php\n\n\nuse\n \nPHPUnit\\Framework\\TestCase\n;\n\n\n\nclass\n \nCalculatorTest\n \nextends\n \nTestCase\n\n\n{\n\n    \npublic\n \nfunction\n \ntestAdd\n()\n\n    \n{\n\n        \n$calculator\n \n=\n \nnew\n \nCalculator\n();\n\n        \n$result\n \n=\n \n$calculator\n-\nadd\n(\n3\n,\n \n2\n);\n\n\n        \n$this\n-\nassertEquals\n(\n5\n,\n \n$result\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nSolo cuando tengamos el test escrito podremos desarrollar el c\u00f3digo:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n?php\n\n\nclass\n \nCalculator\n\n\n{\n\n    \npublic\n \nfunction\n \nadd\n \n(\nint\n \n$a\n,\n \nint\n \n$b\n)\n:\n \nint\n\n    \n{\n\n        \nreturn\n \n$a\n \n+\n \n$b\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nLas tres reglas\n\n\nRobert Martin, en su libro \"Clean Code. A Handbook of agile software craftsmanship\", especifica las tres reglas que deben seguirse cuando se desarrolla con TDD:\n\n\n\n\nNo debes escribir c\u00f3digo de producci\u00f3n hasta que hayas escrito una prueba unitaria que falle.\n\n\nNo debes escribir m\u00e1s de una prueba unitaria que sea suficiente para fallar y el sistema no compile.\n\n\nNo debes escribir m\u00e1s c\u00f3digo de producci\u00f3n que el suficiente para superar la prueba que est\u00e9 fallando actualmente.\n\n\n\n\nDesarrollo orientado a comportamiento (BDD)\n\n\nBehaviour Driven Development (BDD), o desarrollo orientado a comportamiento, es un proceso de desarrollo similar a TDD, solo que con BDD lo que se realiza es definir el comportamiento y las especificaciones, al contrario que con TDD que se limita solamente a comprobar funcionalidades.\n\n\nLos test que se pueden realizar pueden ser de unidad, funcionales y de aceptaci\u00f3n. Para los test de unidad el software m\u00e1s apropiado en PhpSpec y para el resto Behat.\n\n\nCiclo del desarrollo orientado a comportamiento\n\n\n\n\nDescribe el comportamiento del software a trav\u00e9s de pruebas\n\n\nEjecuta los test y comprueba que el nuevo test falla\n\n\nImplementa el nuevo comportamiento\n\n\nEjecuta los test\n\n\nMejora el c\u00f3digo\n\n\nRepite\n\n\n\n\nEjemplo de un test de unidad con PHPSpec\n\n\nSi usamos el ejemplo de la calculadora, esta ser\u00eda la forma de describir el comportamiento de la calculadora:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n?php\n\n\nuse\n \nPhpSpec\\ObjectBehavior\n;\n\n\n\nclass\n \nCalculatorSpec\n \nextends\n \nObjectBehavior\n\n\n{\n\n    \nfunction\n \nit_is_initializable\n()\n\n    \n{\n\n        \n$this\n-\nshouldHaveType\n(\nCalculator\n::\nclass\n);\n\n    \n}\n\n\n    \nfunction\n \nit_adds_to_numbers\n()\n\n    \n{\n\n        \n$this\n-\nadd\n(\n2\n,\n \n3\n)\n-\nshouldReturn\n(\n5\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nLas diferencias principales con PHPUnit son dos:\n\n\n\n\nEl nombre de la funci\u00f3n describe el comportamiento a implementar. Debe empezar por \nit_\n o \nits_\n.\n\n\nNo es necesario instanciar la clase que queremos probar. La clase \nCalculatorSpec\n adquiere los m\u00e9todos de la clase que estamos describiendo.\n\n\n\n\nHay muchas m\u00e1s diferencias, pero a grandes rasgos nos vamos a quedar con esas dos.\n\n\nEjemplo de un test con Behat\n\n\nBehat utiliza un lenguaje llamado Gherkin para describir historias de usuario. Es m\u00e1s apropiado para hacer test de aceptaci\u00f3n. Este ser\u00eda un ejemplo de un test de aceptaci\u00f3n con Gherkin:\n\n\n1\n2\n3\n4\n5\n6\n7\nCaracter\u00edstica:\n Crear una calculadora\n\n\n\n    \nEscenario:\n Sumar dos n\u00fameros\n\n\n        Dado \nque quiero sumar dos n\u00fameros\n\n\n        \nCuando \nintroduzco el n\u00famero \n2\n\n\n        \nE \nintroduzco el n\u00famero \n3\n\n\n        \nEntonces \nrecibo el n\u00famero \n5\n\n\n\n\n\n\n\nEsta prueba es una simplificaci\u00f3n de lo que permite hacer Gherkin. La forma en c\u00f3mo se ejecuta e implementa este tipo de test lo veremos m\u00e1s adelante.", 
            "title": "Introducci\u00f3n"
        }, 
        {
            "location": "/introduction/#introduccion", 
            "text": "", 
            "title": "Introducci\u00f3n"
        }, 
        {
            "location": "/introduction/#desarrollo-orientado-a-pruebas-tdd", 
            "text": "Test Driven Development (TDD), o desarrollo orientado a pruebas, es un proceso de desarrollo de software muy conocido, que consiste en la repetici\u00f3n de ciclos de desarrollo muy cortos.   Los requisitos se convierten en pruebas, unidades de c\u00f3digo que prueban una determinada funcionalidad.  Entonces, se produce el c\u00f3digo justo que permite pasar dicha prueba.   Este proceso es opuesto a otros sistemas de desarrollo que permiten incorporar c\u00f3digo que no se sabe con certeza si concuerdan o no con los requisitos.  Los test que se pueden realizar pueden ser de unidad, funcionales y de aceptaci\u00f3n. Para todos estos tipos de test, en PHP podemos usar PHPUnit.", 
            "title": "Desarrollo orientado a pruebas (TDD)"
        }, 
        {
            "location": "/introduction/#ciclo-del-desarrollo-orientado-a-pruebas", 
            "text": "A\u00f1ade un test  Ejecuta los test y comprueba que el nuevo test falla  Escribe el c\u00f3digo  Ejecuta los test  Refactoriza el c\u00f3digo  Repite", 
            "title": "Ciclo del desarrollo orientado a pruebas"
        }, 
        {
            "location": "/introduction/#ejemplo-de-un-test-de-unidad-con-phpunit", 
            "text": "Si queremos implementar una clase que implemente funciones matem\u00e1ticas, este ser\u00eda el c\u00f3digo de una prueba unitaria que, con PHPUnit, escribir\u00edamos para implementar la funcionalidad  suma :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 ?php  use   PHPUnit\\Framework\\TestCase ;  class   CalculatorTest   extends   TestCase  { \n     public   function   testAdd () \n     { \n         $calculator   =   new   Calculator (); \n         $result   =   $calculator - add ( 3 ,   2 ); \n\n         $this - assertEquals ( 5 ,   $result ); \n     }  }    Solo cuando tengamos el test escrito podremos desarrollar el c\u00f3digo:  1\n2\n3\n4\n5\n6\n7\n8 ?php  class   Calculator  { \n     public   function   add   ( int   $a ,   int   $b ) :   int \n     { \n         return   $a   +   $b ; \n     }  }", 
            "title": "Ejemplo de un test de unidad con PHPUnit"
        }, 
        {
            "location": "/introduction/#las-tres-reglas", 
            "text": "Robert Martin, en su libro \"Clean Code. A Handbook of agile software craftsmanship\", especifica las tres reglas que deben seguirse cuando se desarrolla con TDD:   No debes escribir c\u00f3digo de producci\u00f3n hasta que hayas escrito una prueba unitaria que falle.  No debes escribir m\u00e1s de una prueba unitaria que sea suficiente para fallar y el sistema no compile.  No debes escribir m\u00e1s c\u00f3digo de producci\u00f3n que el suficiente para superar la prueba que est\u00e9 fallando actualmente.", 
            "title": "Las tres reglas"
        }, 
        {
            "location": "/introduction/#desarrollo-orientado-a-comportamiento-bdd", 
            "text": "Behaviour Driven Development (BDD), o desarrollo orientado a comportamiento, es un proceso de desarrollo similar a TDD, solo que con BDD lo que se realiza es definir el comportamiento y las especificaciones, al contrario que con TDD que se limita solamente a comprobar funcionalidades.  Los test que se pueden realizar pueden ser de unidad, funcionales y de aceptaci\u00f3n. Para los test de unidad el software m\u00e1s apropiado en PhpSpec y para el resto Behat.", 
            "title": "Desarrollo orientado a comportamiento (BDD)"
        }, 
        {
            "location": "/introduction/#ciclo-del-desarrollo-orientado-a-comportamiento", 
            "text": "Describe el comportamiento del software a trav\u00e9s de pruebas  Ejecuta los test y comprueba que el nuevo test falla  Implementa el nuevo comportamiento  Ejecuta los test  Mejora el c\u00f3digo  Repite", 
            "title": "Ciclo del desarrollo orientado a comportamiento"
        }, 
        {
            "location": "/introduction/#ejemplo-de-un-test-de-unidad-con-phpspec", 
            "text": "Si usamos el ejemplo de la calculadora, esta ser\u00eda la forma de describir el comportamiento de la calculadora:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 ?php  use   PhpSpec\\ObjectBehavior ;  class   CalculatorSpec   extends   ObjectBehavior  { \n     function   it_is_initializable () \n     { \n         $this - shouldHaveType ( Calculator :: class ); \n     } \n\n     function   it_adds_to_numbers () \n     { \n         $this - add ( 2 ,   3 ) - shouldReturn ( 5 ); \n     }  }    Las diferencias principales con PHPUnit son dos:   El nombre de la funci\u00f3n describe el comportamiento a implementar. Debe empezar por  it_  o  its_ .  No es necesario instanciar la clase que queremos probar. La clase  CalculatorSpec  adquiere los m\u00e9todos de la clase que estamos describiendo.   Hay muchas m\u00e1s diferencias, pero a grandes rasgos nos vamos a quedar con esas dos.", 
            "title": "Ejemplo de un test de unidad con PHPSpec"
        }, 
        {
            "location": "/introduction/#ejemplo-de-un-test-con-behat", 
            "text": "Behat utiliza un lenguaje llamado Gherkin para describir historias de usuario. Es m\u00e1s apropiado para hacer test de aceptaci\u00f3n. Este ser\u00eda un ejemplo de un test de aceptaci\u00f3n con Gherkin:  1\n2\n3\n4\n5\n6\n7 Caracter\u00edstica:  Crear una calculadora       Escenario:  Sumar dos n\u00fameros          Dado  que quiero sumar dos n\u00fameros           Cuando  introduzco el n\u00famero  2           E  introduzco el n\u00famero  3           Entonces  recibo el n\u00famero  5    Esta prueba es una simplificaci\u00f3n de lo que permite hacer Gherkin. La forma en c\u00f3mo se ejecuta e implementa este tipo de test lo veremos m\u00e1s adelante.", 
            "title": "Ejemplo de un test con Behat"
        }, 
        {
            "location": "/modelling/", 
            "text": "Modelando con ejemplos\n\n\nCaptura de requisitos\n\n\nImaginemos que queremos crear un sistema de fidelizaci\u00f3n de clientes de un restaurante, d\u00e1ndoles una serie de puntos que le permitan obtener descuentos en sucesivas visitas. Cuando usamos reglas para la captura de requisitos, corremos el riesgo de ser ambiguos.\n\n\nPor ejemplo, veamos que ocurre cuando especificamos solo con reglas:\n\n\n\n\nExample\n\n\n\n\nRF01\n: Los clientes obtienen un punto por cada euro gastado en un men\u00fa.\n\n\nRF02\n: Diez puntos pueden ser canjeados por un euro de descuento al pagar un men\u00fa.\n\n\nRF03\n: El IVA es del 10%.\n\n\n\n\n\n\nEl problema es que nos surgen una serie de dudas que estas reglas no resuelven:\n\n\n\n\n\u00bfSi gasto puntos a\u00fan puedo ganar puntos?\n\n\n\u00bfPuedo gastar m\u00e1s de diez puntos en un solo men\u00fa?\n\n\n\u00bfEl IVA se aplica al precio descontado o al total?\n\n\n\n\nSi modelamos los requisitos con ejemplos obtenemos esto:\n\n\n\n\nExample\n\n\nSi un men\u00fa para una familia de cinco personas cuesta 50 euros:\n\n\n\n\nSi pagan en efectivo pagar\u00e1n 50\u20ac m\u00e1s 5\u20ac de IVA y obtendr\u00e1n 50 puntos.\n\n\nSi pagan con 10 puntos, costar\u00e1 10 puntos y 49\u20ac + 5\u20ac de IVA y obtendr\u00e1n 0 puntos.\n\n\nSi pagan solo con puntos, entregar\u00e1n 500 puntos + 5\u20ac de IVA y obtendr\u00e1n 0 puntos.\n\n\n\n\n\n\nEvidentemente el ejemplo cuenta con pocas reglas, pero lo que se quiere hacer notar es que es relativamente sencillo llegar a ambig\u00fcedades que con los ejemplos no obtendr\u00edamos. Por ello, en UML contamos con los casos de uso, que es una forma de captura de requisitos funcionales que permite evitar este tipo de problemas.\n\n\nNos vamos a ahorrar la parte de crear los casos de uso y vamos ir directamente a crear las historias de usuario con Gherkin.\n\n\nGherkin\n\n\nGherkin\n es un lenguaje que permite describir el comportamiento del software sin entrar en detalles de c\u00f3mo se ha implementado dicho comportamiento. Cada caracter\u00edstica que se define con \ngherkin\n debe ir en un fichero con extensi\u00f3n \n.feature\n. A continuaci\u00f3n se puede ver una plantilla de ejemplo:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n# language: es\n\n\nCaracter\u00edstica:\n Internal operations\n\n\n    In order to stay secret\n\n\n    As a secret organization\n\n\n    We need to be able to erase past agents\n memory\n\n\n\n    \nAntecedentes:\n\n\n        [Dados|Dadas|Dada|Dado|*] there is agent A\n\n\n        [*|Y|E] there is agent B\n\n\n\n    Escenario: Erasing agent memory\n\n\n        [Dados|Dadas|Dada|Dado|*] there is agent J\n\n\n        [*|Y|E] there is agent K\n\n\n        [Cuando|*] I erase agent K\ns memory\n\n\n        [Entonces|*] there should be agent J\n\n\n        [Pero|*] there should not be agent K\n\n\n\n    Esquema del escenario: Erasing other agents\n memory\n\n\n        [Dados|Dadas|Dada|Dado|*] there is agent \nagent1\n\n\n        [*|Y|E] there is agent \nagent2\n\n\n        [Cuando|*] I erase agent \nagent2\ns memory\n\n\n        [Entonces|*] there should be agent \nagent1\n\n\n        [Pero|*] there should not be agent \nagent2\n\n\n\n        Ejemplos:\n\n\n        | agent1 | agent2 |\n\n\n        | D      | M      |\n\n\n\n\n\n\n\nLas palabras entre [ ] indican una entre las posibles. Para ver el formato en ingl\u00e9s lee la documentaci\u00f3n oficial.\n\n\nIntroducci\u00f3n de la caracter\u00edstica\n\n\nCada archivo .feature consiste convencionalmente en una \u00fanica caracter\u00edstica. Una l\u00ednea que comienza con la palabra clave \nCaracter\u00edstica\n seguida de texto tabulado que la describe. Una caracter\u00edstica generalmente contiene una lista de escenarios y unos antecedentes. Cada escenario consiste en una lista de pasos, que debe comenzar con una de las palabras clave indicadas en la plantilla.\n\n\nLos \nantecedentes\n son datos disponibles antes de cada prueba. Lo habitual es resetear el estado de la aplicaci\u00f3n para que al comienzo de cada escenario est\u00e9 tal y como indican los antecedentes.\n\n\nLos \nescenarios\n son las caracter\u00edsticas que deben ser implementadas y se componen de tres secciones:\n\n\n\n\n\"\nDado\n unos antecedentes\": Permiten establecer un estado de la aplicaci\u00f3n espec\u00edfico para esta prueba.\n\n\n\"\nCuando\n\" ocurre o se realiza una acci\u00f3n: Aqu\u00ed es donde se prueba la caracter\u00edstica a programar.\n\n\n\"\nEntonces\n\" ocurre una consecuencia: Aqu\u00ed es donde se comprueba que la caracter\u00edstica funciona correctamente.\n\n\n\n\nSe pueden concatenar sentencias con las palabras \nY\n, \nE\n y \nPERO\n, tal y como se ve en la plantilla.\n\n\nCreando los escenarios\n\n\nVamos a describir un posible archivo \ngherkin\n para nuestro ejemplo del restaurante:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n#language: es\n\n\nCaracter\u00edstica:\n Pagar un men\u00fa\n\n\n    Reglas:\n\n\n\n    - 1 punto por cada euro.\n\n\n    - 10 puntos equivalen a un descuento de 1 euros.\n\n\n    - El IVA es del 10%\n\n\n\n    \nAntecedentes:\n\n\n        Dados los siguientes men\u00fas:\n\n\n        | n\u00famero | precio |\n\n\n        | 1      | 10     |\n\n\n        | 2      | 12     |\n\n\n        | 3      |  8     |\n\n\n\n    Escenario: Ganar puntos al pagar en efectivo\n\n\n        Dado \nque he comprado \n5\n men\u00fas del n\u00famero \n1\n\n\n        \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n        \nY \npago en efectivo con \n55\n euros\n\n\n        \nEntonces \nla factura est\u00e1 pagada\n\n\n        \nY \nhe obtenido \n50\n puntos\n\n\n\n    \nEscenario:\n Pagar con dinero y puntos\n\n\n        Dado \nque he comprado \n5\n men\u00fas del n\u00famero \n1\n\n\n        \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n        \nY \npago con \n10\n puntos y \n54\n euros\n\n\n        \nEntonces \nla factura est\u00e1 pagada\n\n\n        \nY \nhe obtenido \n0\n puntos\n\n\n\n    \nEscenario:\n Pagar con puntos\n\n\n        Dado \nque he comprado \n5\n men\u00fas del n\u00famero \n1\n\n\n        \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n        \nY \npago con \n500\n puntos y \n5\n euros\n\n\n        \nEntonces \nla factura est\u00e1 pagada\n\n\n        \nY \nhe obtenido \n0\n puntos\n\n\n\n    \nEscenario:\n Intentar pagar el IVA con puntos\n\n\n        Dado \nque he comprado \n5\n men\u00fas del n\u00famero \n1\n\n\n        \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n        \nY \npago con \n550\n puntos y \n0\n euros\n\n\n        \nEntonces \nquedan \n5\n euros por pagar\n\n\n\n    \nEscenario:\n Comprar men\u00fas de varios tipos\n\n\n        Dado \nque he comprado \n1\n men\u00fa del n\u00famero \n1\n\n\n        \nY \nque he comprado \n2\n men\u00fas del n\u00famero \n2\n\n\n        \nY \nque he comprado \n2\n men\u00fas del n\u00famero \n3\n\n\n        \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n        \nY \npago en efectivo con \n55\n euros\n\n\n        \nEntonces \nla factura est\u00e1 pagada\n\n\n        \nY \nhe obtenido \n50\n puntos\n\n\n\n\n\n\n\nEl anterior archivo describe las caracter\u00edsticas, en un lenguaje de negocio, de las caracter\u00edsticas del software que debemos implementar. En los siguientes cap\u00edtulos iremos implementando el proyecto paso a paso.", 
            "title": "Modelando con ejemplos"
        }, 
        {
            "location": "/modelling/#modelando-con-ejemplos", 
            "text": "", 
            "title": "Modelando con ejemplos"
        }, 
        {
            "location": "/modelling/#captura-de-requisitos", 
            "text": "Imaginemos que queremos crear un sistema de fidelizaci\u00f3n de clientes de un restaurante, d\u00e1ndoles una serie de puntos que le permitan obtener descuentos en sucesivas visitas. Cuando usamos reglas para la captura de requisitos, corremos el riesgo de ser ambiguos.  Por ejemplo, veamos que ocurre cuando especificamos solo con reglas:   Example   RF01 : Los clientes obtienen un punto por cada euro gastado en un men\u00fa.  RF02 : Diez puntos pueden ser canjeados por un euro de descuento al pagar un men\u00fa.  RF03 : El IVA es del 10%.    El problema es que nos surgen una serie de dudas que estas reglas no resuelven:   \u00bfSi gasto puntos a\u00fan puedo ganar puntos?  \u00bfPuedo gastar m\u00e1s de diez puntos en un solo men\u00fa?  \u00bfEl IVA se aplica al precio descontado o al total?   Si modelamos los requisitos con ejemplos obtenemos esto:   Example  Si un men\u00fa para una familia de cinco personas cuesta 50 euros:   Si pagan en efectivo pagar\u00e1n 50\u20ac m\u00e1s 5\u20ac de IVA y obtendr\u00e1n 50 puntos.  Si pagan con 10 puntos, costar\u00e1 10 puntos y 49\u20ac + 5\u20ac de IVA y obtendr\u00e1n 0 puntos.  Si pagan solo con puntos, entregar\u00e1n 500 puntos + 5\u20ac de IVA y obtendr\u00e1n 0 puntos.    Evidentemente el ejemplo cuenta con pocas reglas, pero lo que se quiere hacer notar es que es relativamente sencillo llegar a ambig\u00fcedades que con los ejemplos no obtendr\u00edamos. Por ello, en UML contamos con los casos de uso, que es una forma de captura de requisitos funcionales que permite evitar este tipo de problemas.  Nos vamos a ahorrar la parte de crear los casos de uso y vamos ir directamente a crear las historias de usuario con Gherkin.", 
            "title": "Captura de requisitos"
        }, 
        {
            "location": "/modelling/#gherkin", 
            "text": "Gherkin  es un lenguaje que permite describir el comportamiento del software sin entrar en detalles de c\u00f3mo se ha implementado dicho comportamiento. Cada caracter\u00edstica que se define con  gherkin  debe ir en un fichero con extensi\u00f3n  .feature . A continuaci\u00f3n se puede ver una plantilla de ejemplo:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27 # language: es  Caracter\u00edstica:  Internal operations      In order to stay secret      As a secret organization      We need to be able to erase past agents  memory       Antecedentes:          [Dados|Dadas|Dada|Dado|*] there is agent A          [*|Y|E] there is agent B      Escenario: Erasing agent memory          [Dados|Dadas|Dada|Dado|*] there is agent J          [*|Y|E] there is agent K          [Cuando|*] I erase agent K s memory          [Entonces|*] there should be agent J          [Pero|*] there should not be agent K      Esquema del escenario: Erasing other agents  memory          [Dados|Dadas|Dada|Dado|*] there is agent  agent1          [*|Y|E] there is agent  agent2          [Cuando|*] I erase agent  agent2 s memory          [Entonces|*] there should be agent  agent1          [Pero|*] there should not be agent  agent2          Ejemplos:          | agent1 | agent2 |          | D      | M      |    Las palabras entre [ ] indican una entre las posibles. Para ver el formato en ingl\u00e9s lee la documentaci\u00f3n oficial.", 
            "title": "Gherkin"
        }, 
        {
            "location": "/modelling/#introduccion-de-la-caracteristica", 
            "text": "Cada archivo .feature consiste convencionalmente en una \u00fanica caracter\u00edstica. Una l\u00ednea que comienza con la palabra clave  Caracter\u00edstica  seguida de texto tabulado que la describe. Una caracter\u00edstica generalmente contiene una lista de escenarios y unos antecedentes. Cada escenario consiste en una lista de pasos, que debe comenzar con una de las palabras clave indicadas en la plantilla.  Los  antecedentes  son datos disponibles antes de cada prueba. Lo habitual es resetear el estado de la aplicaci\u00f3n para que al comienzo de cada escenario est\u00e9 tal y como indican los antecedentes.  Los  escenarios  son las caracter\u00edsticas que deben ser implementadas y se componen de tres secciones:   \" Dado  unos antecedentes\": Permiten establecer un estado de la aplicaci\u00f3n espec\u00edfico para esta prueba.  \" Cuando \" ocurre o se realiza una acci\u00f3n: Aqu\u00ed es donde se prueba la caracter\u00edstica a programar.  \" Entonces \" ocurre una consecuencia: Aqu\u00ed es donde se comprueba que la caracter\u00edstica funciona correctamente.   Se pueden concatenar sentencias con las palabras  Y ,  E  y  PERO , tal y como se ve en la plantilla.", 
            "title": "Introducci\u00f3n de la caracter\u00edstica"
        }, 
        {
            "location": "/modelling/#creando-los-escenarios", 
            "text": "Vamos a describir un posible archivo  gherkin  para nuestro ejemplo del restaurante:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50 #language: es  Caracter\u00edstica:  Pagar un men\u00fa      Reglas:      - 1 punto por cada euro.      - 10 puntos equivalen a un descuento de 1 euros.      - El IVA es del 10%       Antecedentes:          Dados los siguientes men\u00fas:          | n\u00famero | precio |          | 1      | 10     |          | 2      | 12     |          | 3      |  8     |      Escenario: Ganar puntos al pagar en efectivo          Dado  que he comprado  5  men\u00fas del n\u00famero  1           Cuando  pido la cuenta recibo una factura de  55  euros           Y  pago en efectivo con  55  euros           Entonces  la factura est\u00e1 pagada           Y  he obtenido  50  puntos       Escenario:  Pagar con dinero y puntos          Dado  que he comprado  5  men\u00fas del n\u00famero  1           Cuando  pido la cuenta recibo una factura de  55  euros           Y  pago con  10  puntos y  54  euros           Entonces  la factura est\u00e1 pagada           Y  he obtenido  0  puntos       Escenario:  Pagar con puntos          Dado  que he comprado  5  men\u00fas del n\u00famero  1           Cuando  pido la cuenta recibo una factura de  55  euros           Y  pago con  500  puntos y  5  euros           Entonces  la factura est\u00e1 pagada           Y  he obtenido  0  puntos       Escenario:  Intentar pagar el IVA con puntos          Dado  que he comprado  5  men\u00fas del n\u00famero  1           Cuando  pido la cuenta recibo una factura de  55  euros           Y  pago con  550  puntos y  0  euros           Entonces  quedan  5  euros por pagar       Escenario:  Comprar men\u00fas de varios tipos          Dado  que he comprado  1  men\u00fa del n\u00famero  1           Y  que he comprado  2  men\u00fas del n\u00famero  2           Y  que he comprado  2  men\u00fas del n\u00famero  3           Cuando  pido la cuenta recibo una factura de  55  euros           Y  pago en efectivo con  55  euros           Entonces  la factura est\u00e1 pagada           Y  he obtenido  50  puntos    El anterior archivo describe las caracter\u00edsticas, en un lenguaje de negocio, de las caracter\u00edsticas del software que debemos implementar. En los siguientes cap\u00edtulos iremos implementando el proyecto paso a paso.", 
            "title": "Creando los escenarios"
        }, 
        {
            "location": "/start-project/", 
            "text": "Crear el proyecto\n\n\nVamos a implementar el proyecto que implemente las caracter\u00edsticas descritas en el apartado anterior. Vamos a hacer uso de un esqueleto que ya tiene configurado:\n\n\n1\ncomposer create aulasoftwarelibre/bdd-by-example\n\n\n\n\n\n\n\nSe nos crear\u00e1 un directorio con todo lo que necesitamos para empezar a trabajar. Si analizamos el fichero \ncomposer.json\n veremos las dependencias de nuestro proyecto:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n{\n\n    \nrequire-dev\n:\n \n{\n\n        \nbehat/behat\n:\n \n^3.4\n,\n\n        \nkanel/phpspec-data-provider-extension\n:\n \n^1.0\n,\n\n        \nphpspec/phpspec\n:\n \n^4.3\n,\n\n        \nleanphp/phpspec-code-coverage\n:\n \n^4.2\n,\n\n        \nphpunit/phpunit\n:\n \n^7.0\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nCreaci\u00f3n de caracter\u00edsticas\n\n\nLas caracter\u00edsticas (ficheros \n.feature\n) deben ir dentro del directorio \nfeatures/\n de nuestro proyecto.\n\n\n\n\nTip\n\n\nLas cajas de ejemplo tienen un icono que, si lo pulsas, permiten copiar el contenido al portapapeles. \u00dasalo para ir m\u00e1s r\u00e1pido al copiar el c\u00f3digo.\n\n\n\n\n\n\nCrearemos dentro de dicho directorio un fichero llamado \nmenu.feature\n con el contenido que describimos en el cap\u00edtulo anterior.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n#language: es\n\n\nCaracter\u00edstica:\n Pagar un men\u00fa\n\n\n    Reglas:\n\n\n\n    - 1 punto por cada euro.\n\n\n    - 10 puntos equivalen a un descuento de 1 euros.\n\n\n    - El IVA es del 10%\n\n\n\n    \nAntecedentes:\n\n\n        Dados los siguientes men\u00fas:\n\n\n        | n\u00famero | precio |\n\n\n        | 1      | 10     |\n\n\n        | 2      | 12     |\n\n\n        | 3      |  8     |\n\n\n\n    Escenario: Ganar puntos al pagar en efectivo\n\n\n        Dado \nque he comprado \n5\n men\u00fas del n\u00famero \n1\n\n\n        \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n        \nY \npago en efectivo con \n55\n euros\n\n\n        \nEntonces \nla factura est\u00e1 pagada\n\n\n        \nY \nhe obtenido \n50\n puntos\n\n\n\n    \nEscenario:\n Pagar con dinero y puntos\n\n\n        Dado \nque he comprado \n5\n men\u00fas del n\u00famero \n1\n\n\n        \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n        \nY \npago con \n10\n puntos y \n54\n euros\n\n\n        \nEntonces \nla factura est\u00e1 pagada\n\n\n        \nY \nhe obtenido \n0\n puntos\n\n\n\n    \nEscenario:\n Pagar con puntos\n\n\n        Dado \nque he comprado \n5\n men\u00fas del n\u00famero \n1\n\n\n        \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n        \nY \npago con \n500\n puntos y \n5\n euros\n\n\n        \nEntonces \nla factura est\u00e1 pagada\n\n\n        \nY \nhe obtenido \n0\n puntos\n\n\n\n    \nEscenario:\n Intentar pagar el IVA con puntos\n\n\n        Dado \nque he comprado \n5\n men\u00fas del n\u00famero \n1\n\n\n        \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n        \nY \npago con \n550\n puntos y \n0\n euros\n\n\n        \nEntonces \nquedan \n5\n euros por pagar\n\n\n\n    \nEscenario:\n Comprar men\u00fas de varios tipos\n\n\n        Dado \nque he comprado \n1\n men\u00fa del n\u00famero \n1\n\n\n        \nY \nque he comprado \n2\n men\u00fas del n\u00famero \n2\n\n\n        \nY \nque he comprado \n2\n men\u00fas del n\u00famero \n3\n\n\n        \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n        \nY \npago en efectivo con \n55\n euros\n\n\n        \nEntonces \nla factura est\u00e1 pagada\n\n\n        \nY \nhe obtenido \n50\n puntos\n\n\n\n\n\n\n\nEjecuci\u00f3n de behat\n\n\nAhora que tenemos las pruebas definidas vamos a ejecutar \nbehat\n:\n\n\n1\nvendor/bin/behat --snippets-for FeatureContext\n\n\n\n\n\n\nObtendremos el resumen de la ejecuci\u00f3n de pruebas que contiene la siguiente informaci\u00f3n:\n\n\n1\n2\n3\n5\n scenarios \n(\n5\n undefined\n)\n\n\n32\n steps \n(\n32\n undefined\n)\n\n0m0.02s \n(\n9\n.49Mb\n)\n\n\n\n\n\n\n\nLo que significa es que \nbehat\n no reconoce ninguno de los \nstep\n o pasos de los que se compone cada escenario. Esa parte debemos programarla nosotros. Para ello \nbehat\n nos facilita el trabajo con una serie de \nsnippets\n. Veamos uno:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n?php\n\n\n/**\n\n\n * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2\n\n\n */\n\n\npublic\n \nfunction\n \nqueHeCompradoMenusDelNumero\n(\n$arg1\n,\n \n$arg2\n)\n\n\n{\n\n    \nthrow\n \nnew\n \nPendingException\n();\n\n\n}\n\n\n\n\n\n\n\nEl \nstep\n se compone de una cabecera con las palabras \n@Given\n, \n@When\n o \n@Then\n  y una frase que coincide con la que hayamos determinado en el paso. Los n\u00fameros y las cadenas que se pongan entre comillas se convierten en par\u00e1metros del paso. Tambi\u00e9n es posible usar expresiones regulares, pero en esos casos debemos hacerlo a mano. El objetivo es meter todos estos snippets en el archivo de contexto que usa \nBehat\n.\n\n\nSi editamos el archivo \nfeatures/bootstrap/FeatureContext.php\n, veremos el archivo de contexto por defecto que usar \nBehat\n. Podemos tener los que necesitemos, para separar los \nsteps\n de forma conveniente, pero eso es configuraci\u00f3n avanzada del entorno y no nos vamos a meter en eso. Editamos el archivo y copiamos el siguiente contenido en \u00e9l:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n?php\n\n\n\nuse\n \nBehat\\Behat\\Context\\Context\n;\n\n\nuse\n \nBehat\\Behat\\Tester\\Exception\\PendingException\n;\n\n\nuse\n \nBehat\\Gherkin\\Node\\PyStringNode\n;\n\n\nuse\n \nBehat\\Gherkin\\Node\\TableNode\n;\n\n\n\n/**\n\n\n* Defines application features from the specific context.\n\n\n*/\n\n\nclass\n \nFeatureContext\n \nimplements\n \nContext\n\n\n{\n\n    \n/**\n\n\n     * Initializes context.\n\n\n     *\n\n\n     * Every scenario gets its own context instance.\n\n\n     * You can also pass arbitrary arguments to the\n\n\n     * context constructor through behat.yml.\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n()\n\n    \n{\n\n    \n}\n\n\n    \n/**\n\n\n     * @Given los siguientes men\u00fas:\n\n\n     */\n\n    \npublic\n \nfunction\n \nlosSiguientesMenus\n(\nTableNode\n \n$table\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n     * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2\n\n\n     */\n\n    \npublic\n \nfunction\n \nqueHeCompradoMenusDelNumero\n(\n$arg1\n,\n \n$arg2\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n     * @When pido la cuenta recibo una factura de :arg1 euros\n\n\n     */\n\n    \npublic\n \nfunction\n \npidoLaCuentaReciboUnaFacturaDeEuros\n(\n$arg1\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n     * @When pago en efectivo con :arg1 euros\n\n\n     */\n\n    \npublic\n \nfunction\n \npagoEnEfectivoConEuros\n(\n$arg1\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n     * @Then la factura est\u00e1 pagada\n\n\n     */\n\n    \npublic\n \nfunction\n \nlaFacturaEstaPagada\n()\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n     * @Then he obtenido :arg1 puntos\n\n\n     */\n\n    \npublic\n \nfunction\n \nheObtenidoPuntos\n(\n$arg1\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n     * @When pago con :arg1 puntos y :arg2 euros\n\n\n     */\n\n    \npublic\n \nfunction\n \npagoConPuntosYEuros\n(\n$arg1\n,\n \n$arg2\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n     * @Then quedan :arg1 euros por pagar\n\n\n     */\n\n    \npublic\n \nfunction\n \nquedanEurosPorPagar\n(\n$arg1\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n     * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2\n\n\n     */\n\n    \npublic\n \nfunction\n \nqueHeCompradoMenuDelNumero\n(\n$arg1\n,\n \n$arg2\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nSi volvemos a ejecutar behat:\n\n\n1\nvendor/bin/behat\n\n\n\n\n\n\nObtenemos algo distinto:\n\n\n1\n2\n3\n5\n scenarios \n(\n5\n pending\n)\n\n\n32\n steps \n(\n5\n pending, \n27\n skipped\n)\n\n0m0.03s \n(\n9\n.54Mb\n)\n\n\n\n\n\n\n\nYa los escenarios no est\u00e1n como \nundefined\n sino como \npending\n.\n\n\nImplementando el primer \nstep\n\n\nEl primer \nstep\n es el que corresponde con la parte de antecedentes:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n#language: es\n\n\nCaracter\u00edstica:\n Pagar un men\u00fa\n\n\n    Reglas:\n\n\n\n    - 1 punto por cada euro.\n\n\n    - 10 puntos equivalen a un descuento de 1 euros.\n\n\n    - El IVA es del 10%\n\n\n\n    \nAntecedentes:\n\n\n        Dados los siguientes men\u00fas:\n\n\n        | n\u00famero | precio |\n\n\n        | 1      | 10     |\n\n\n        | 2      | 12     |\n\n\n        | 3      |  8     |\n\n\n\n\n\n\n\nQue corresponde al siguiente \nsnippet\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n?php\n\n\n\nuse\n \nBehat\\Behat\\Context\\Context\n;\n\n\nuse\n \nBehat\\Behat\\Tester\\Exception\\PendingException\n;\n\n\nuse\n \nBehat\\Gherkin\\Node\\PyStringNode\n;\n\n\nuse\n \nBehat\\Gherkin\\Node\\TableNode\n;\n\n\n\n/**\n\n\n * Defines application features from the specific context.\n\n\n */\n\n\nclass\n \nFeatureContext\n \nimplements\n \nContext\n\n\n{\n\n    \n/**\n\n\n     * @Given los siguientes men\u00fas:\n\n\n     */\n\n\n    \npublic\n \nfunction\n \nlosSiguientesMenus\n(\nTableNode\n \n$table\n)\n\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nY aqu\u00ed nos surge la primera necesidad, necesitamos una clase para almacenar men\u00fas.\n\n\nPhpSpec\n\n\nPhpSpec es una herramienta para el dise\u00f1o de clases. Se usa, especialmente, para el dise\u00f1o de un modelo de dominio limpio, desacoplado y aislado sin involucrarse demasiado en la infraestructura. Principalmente lo que vamos a indicar con PhpSpec es la API de nuestra clase con el resto del dominio.\n\n\nPor el momento, para poder pasar la prueba que falla \n\"Dados los siguientes men\u00fas\", necesitamos una clase que nos ofrezca informaci\u00f3n del n\u00famero de men\u00fa y del precio. As\u00ed que vamos a empezar a describir nuestra clase con la ayuda de _PhpSpec\n:\n\n\n1\nvendor/bin/phpspec desc Restaurant/Menu\n\n\n\n\n\n\n\n\nWarning\n\n\nDebido a que la barra invertida '\\' sirve como secuencia de escape en la consola, usamos la barra normal '/' para separar el espacio de nombres de la clase. Otra opci\u00f3n es usar doble barra invertida:\n\n\n1\nvendor/bin/phpspec desc Restaurant\n\\\\\nMenu\n\n\n\n\n\n\n\n\nObtendremos un archivo en \nspec/Restaurant/MenuSpec.php\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n?php\n\n\n\nnamespace\n \nspec\\Restaurant\n;\n\n\n\nuse\n \nRestaurant\\Menu\n;\n\n\nuse\n \nPhpSpec\\ObjectBehavior\n;\n\n\nuse\n \nProphecy\\Argument\n;\n\n\n\nclass\n \nMenuSpec\n \nextends\n \nObjectBehavior\n\n\n{\n\n    \nfunction\n \nit_is_initializable\n()\n\n    \n{\n\n        \n$this\n-\nshouldHaveType\n(\nMenu\n::\nclass\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nLa especificaci\u00f3n indica que existe una clase que debe ser iniciable y de tipo \nRestaurant\\Menu\n. Si ejecutamos las pruebas de \nPhpSpec\n:\n\n\n1\nvendor/bin/phpspec run\n\n\n\n\n\n\nObtendremos la siguiente salida:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n  Restaurant\n\\M\nenu\n\n  \n11\n  ! is initializable\n        class Restaurant\n\\M\nenu does not exist.\n\n----  broken examples\n\n        Restaurant/Menu\n  \n11\n  ! is initializable\n        class Restaurant\n\\M\nenu does not exist.\n\n\n\n1\n specs\n\n1\n examples \n(\n1\n broken\n)\n\n32ms\n\n  Do you want me to create \n`\nRestaurant\n\\M\nenu\n`\n \nfor\n you?\n                                                                     \n[\nY/n\n]\n\n\n\n\n\n\n\nNos avisa que la clase que se quiere probar no existe y si quiere probarla por nosotros. Para sucesivas veces, en este tutorial responderemos siempre s\u00ed a esta circunstancia aunque no se indique.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nClass Restaurant\n\\M\nenu created in .../bdd-by-example/src/Restaurant/Menu.php.\n\n\n      Restaurant\n\\M\nenu\n\n  \n11\n  \u2714 is initializable\n\n\n\n1\n specs\n\n1\n examples \n(\n1\n passed\n)\n\n34ms\n\n\n\n\n\n\nObteniendo una clase Menu en nuestro proyecto en \nsrc/Restaurant/Menu.php\n:\n\n\n1\n2\n3\n4\n5\n6\n7\n?php\n\n\n\nnamespace\n \nRestaurant\n;\n\n\n\nclass\n \nMenu\n\n\n{\n\n\n}\n\n\n\n\n\n\n\nVamos a seguir especificando los requisitos de nuestra clase para pasar la prueba. Concretamente necesitamos que nuestra clase sea capaz de indicar el n\u00famero de men\u00fa y el precio. Vamos a escribir la especificaci\u00f3n y la comentamos a continuaci\u00f3n. Modificamos nuestro \nMenuSpec.php\n as\u00ed:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n?php\n\n\n\nnamespace\n \nspec\\Restaurant\n;\n\n\n\nuse\n \nRestaurant\\Menu\n;\n\n\nuse\n \nPhpSpec\\ObjectBehavior\n;\n\n\nuse\n \nProphecy\\Argument\n;\n\n\n\nclass\n \nMenuSpec\n \nextends\n \nObjectBehavior\n\n\n{\n\n    \nconst\n \nNUMBER\n \n=\n \n10\n;\n\n    \nconst\n \nPRICE\n \n=\n \n2500\n;\n\n\n    \nfunction\n \nlet\n()\n\n    \n{\n\n        \n$this\n-\nbeConstructedWith\n(\nself\n::\nNUMBER\n,\n \nself\n::\nPRICE\n);\n\n    \n}\n\n\n    \nfunction\n \nit_is_initializable\n()\n\n    \n{\n\n        \n$this\n-\nshouldHaveType\n(\nMenu\n::\nclass\n);\n\n    \n}\n\n\n    \nfunction\n \nit_has_a_menu_number\n()\n\n    \n{\n\n        \n$this\n-\nnumber\n()\n-\nshouldBe\n(\nself\n::\nNUMBER\n);\n\n    \n}\n\n\n    \nfunction\n \nit_has_a_price\n()\n\n    \n{\n\n        \n$this\n-\nprice\n()\n-\nshouldBe\n(\nself\n::\nPRICE\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nLas l\u00edneas 24 y 29 especifican los dos comportamientos que esperamos de nuestra clase, devolver el n\u00famero y devolver el precio. Pero antes de devolver nada esa informaci\u00f3n debe incorporarse a trav\u00e9s del constructor. Para ello usamos la funci\u00f3n _ let_ (l\u00ednea 14), que sirve para configurar la prueba en su comienzo. En este caso, la l\u00ednea 16 construye la clase con el n\u00famero y el precio del men\u00fa. El uso de constantes es para ser m\u00e1s descriptivo a la hora de leer la prueba. Ya que hemos especificado como se construye la clase, especificamos los otros dos comportamientos.\n\n\n\n\nInfo\n\n\nEstamos usando euros para los ejemplos. En realidad, y dado que PHP no tiene un tipo de datos para datos financieros, deber\u00edamos usar alguna clase \nMoneda\n o guardar los datos en c\u00e9ntimos para evitar el uso de decimales. Para simplificar el tutorial vamos a usar c\u00e9ntimos. As\u00ed que aunque en los test usemos euros en la clase \nMenu\n vamos a almacenar el valor en c\u00e9ntimos.\n\n\n\n\nPara indicar el n\u00famero de men\u00fa, indicamos que llamamos a un m\u00e9todo \nnumber()\n (l\u00ednea 26) que debe devolver el mismo valor que se pas\u00f3 al constructor. Para indicar el precio, lo mismo pero llamando a un m\u00e9todo \nprice()\n (l\u00ednea 31).\n\n\nEjecutamos otra vez \nPhpSpec\n, respondiendo afirmativamente a todas las preguntas:\n\n\n1\nvendor/bin/phpspec run\n\n\n\n\n\n\nObteniendo la siguiente salida:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n      Restaurant\n\\M\nenu\n\n  \n19\n  ! is initializable\n        method Restaurant\n\\M\nenu::__construct not found.\n  \n24\n  ! has a menu number\n        method Restaurant\n\\M\nenu::__construct not found.\n  \n29\n  ! has a price\n        method Restaurant\n\\M\nenu::__construct not found.\n\n----  broken examples\n\n        Restaurant/Menu\n  \n19\n  ! is initializable\n        method Restaurant\n\\M\nenu::__construct not found.\n\n        Restaurant/Menu\n  \n24\n  ! has a menu number\n        method Restaurant\n\\M\nenu::__construct not found.\n\n        Restaurant/Menu\n  \n29\n  ! has a price\n        method Restaurant\n\\M\nenu::__construct not found.\n\n\n\n1\n specs\n\n3\n examples \n(\n3\n broken\n)\n\n59ms\n\n  Do you want me to create \n`\nRestaurant\n\\M\nenu::__construct\n()\n`\n \nfor\n you?            \n                                                                         \n[\nY/n\n]\n\n\n  Method Restaurant\n\\M\nenu::__construct\n()\n has been created.\n\n\n      Restaurant\n\\M\nenu\n\n  \n19\n  \u2714 is initializable\n  \n24\n  ! has a menu number\n        method Restaurant\n\\M\nenu::number not found.\n  \n29\n  ! has a price\n        method Restaurant\n\\M\nenu::price not found.\n\n----  broken examples\n\n        Restaurant/Menu\n  \n24\n  ! has a menu number\n        method Restaurant\n\\M\nenu::number not found.\n\n        Restaurant/Menu\n  \n29\n  ! has a price\n        method Restaurant\n\\M\nenu::price not found.\n\n\n\n1\n specs\n\n3\n examples \n(\n1\n passed, \n2\n broken\n)\n\n62ms\n\n  Do you want me to create \n`\nRestaurant\n\\M\nenu::number\n()\n`\n \nfor\n you?                 \n                                                                         \n[\nY/n\n]\n\n\n  Method Restaurant\n\\M\nenu::number\n()\n has been created.\n\n\n  Do you want me to create \n`\nRestaurant\n\\M\nenu::price\n()\n`\n \nfor\n you?                  \n                                                                         \n[\nY/n\n]\n\n\n  Method Restaurant\n\\M\nenu::price\n()\n has been created.\n\n\n      Restaurant\n\\M\nenu\n\n  \n19\n  \u2714 is initializable\n  \n24\n  \u2718 has a menu number\n        expected \n[\ninteger:10\n]\n, but got null.\n  \n29\n  \u2718 has a price\n        expected \n[\ninteger:2500\n]\n, but got null.\n\n----  failed examples\n\n        Restaurant/Menu\n  \n24\n  \u2718 has a menu number\n        expected \n[\ninteger:10\n]\n, but got null.\n\n        Restaurant/Menu\n  \n29\n  \u2718 has a price\n        expected \n[\ninteger:2500\n]\n, but got null.\n\n\n\n1\n specs\n\n3\n examples \n(\n1\n passed, \n2\n failed\n)\n\n79ms\n\n\n\n\n\n\nEvidentemente las pruebas fallar\u00e1n al final, pero es el proceso normal en desarrollo orientado a pruebas/comportamiento. Analicemos que ha ocurrido en nuestra clase \nMenu\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n?php\n\n\n\nnamespace\n \nRestaurant\n;\n\n\n\nclass\n \nMenu\n\n\n{\n\n    \npublic\n \nfunction\n \n__construct\n(\n$argument1\n,\n \n$argument2\n)\n\n    \n{\n\n        \n// TODO: write logic here\n\n    \n}\n\n\n    \npublic\n \nfunction\n \nnumber\n()\n\n    \n{\n\n        \n// TODO: write logic here\n\n    \n}\n\n\n    \npublic\n \nfunction\n \nprice\n()\n\n    \n{\n\n        \n// TODO: write logic here\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nLa especificaci\u00f3n de la prueba ha creado el esqueleto de nuestra clase, ahora solo queda implementar la funcionalidad para pasar la especificaci\u00f3n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n?php\n\n\ndeclare\n(\nstrict_types\n=\n1\n);\n\n\n\nnamespace\n \nRestaurant\n;\n\n\n\nclass\n \nMenu\n \nimplements\n \nPriced\n\n\n{\n\n    \nprivate\n \n$number\n;\n\n    \nprivate\n \n$price\n;\n\n\n    \npublic\n \nfunction\n \n__construct\n(\nint\n \n$number\n,\n \nint\n \n$price\n)\n\n    \n{\n\n        \n$this\n-\nnumber\n \n=\n \n$number\n;\n\n        \n$this\n-\nprice\n \n=\n \n$price\n;\n\n    \n}\n\n\n    \npublic\n \nfunction\n \nnumber\n()\n:\n \nint\n\n    \n{\n\n        \nreturn\n \n$this\n-\nnumber\n;\n\n    \n}\n\n\n    \npublic\n \nfunction\n \nprice\n()\n:\n \nint\n\n    \n{\n\n        \nreturn\n \n$this\n-\nprice\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nEjecutamos las pruebas y comprobamos que pasan:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\nbash$ vendor/bin/phpspec run\n\n      Restaurant\n\\M\nenu\n\n  \n19\n  \u2714 is initializable\n  \n24\n  \u2714 has a menu number\n  \n29\n  \u2714 has a price\n\n\n\n1\n specs\n\n3\n examples \n(\n3\n passed\n)\n\n60ms\n\n\n\n\n\n\nYa tenemos nuestra primera clase completada que pasa la especificaci\u00f3n.\n\n\nTerminar de implementar el primer step\n\n\nAhora podemos programar el paso para ir progresando en nuestros casos de uso. Editamos el archivo FeatureContext:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n?php\n\n\n\nuse\n \nBehat\\Behat\\Context\\Context\n;\n\n\nuse\n \nBehat\\Behat\\Tester\\Exception\\PendingException\n;\n\n\nuse\n \nBehat\\Gherkin\\Node\\PyStringNode\n;\n\n\nuse\n \nBehat\\Gherkin\\Node\\TableNode\n;\n\n\n\n/**\n\n\n * Defines application features from the specific context.\n\n\n */\n\n\nclass\n \nFeatureContext\n \nimplements\n \nContext\n\n\n{\n\n\n    \nprivate\n \n$menus\n;\n\n\n\n    \n/**\n\n\n     * Initializes context.\n\n\n     *\n\n\n     * Every scenario gets its own context instance.\n\n\n     * You can also pass arbitrary arguments to the\n\n\n     * context constructor through behat.yml.\n\n\n     */\n\n    \npublic\n \nfunction\n \n__construct\n()\n\n    \n{\n\n\n        \n$this\n-\nmenus\n \n=\n \n[];\n\n\n    \n}\n\n    \n/**\n\n\n     * @Given los siguientes men\u00fas:\n\n\n     */\n\n    \npublic\n \nfunction\n \nlosSiguientesMenus\n(\nTableNode\n \n$table\n)\n\n    \n{\n\n\n        \nforeach\n \n(\n$table\n-\ngetHash\n()\n \nas\n \n$menu\n)\n \n{\n\n\n            \n$this\n-\nmenus\n[\n$menu\n[\nn\u00famero\n]]\n \n=\n \nnew\n \n\\Restaurant\\Menu\n(\n$menu\n[\nn\u00famero\n],\n \n$menu\n[\nprecio\n]\n \n*\n \n100\n);\n\n\n        \n}\n\n\n    \n}\n\n\n    \n/**\n\n\n     * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2\n\n\n     */\n\n    \npublic\n \nfunction\n \nqueHeCompradoMenusDelNumero\n(\n$arg1\n,\n \n$arg2\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n     * @When pido la cuenta recibo una factura de :arg1 euros\n\n\n     */\n\n    \npublic\n \nfunction\n \npidoLaCuentaReciboUnaFacturaDeEuros\n(\n$arg1\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n     * @When pago en efectivo con :arg1 euros\n\n\n     */\n\n    \npublic\n \nfunction\n \npagoEnEfectivoConEuros\n(\n$arg1\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n     * @Then la factura est\u00e1 pagada\n\n\n     */\n\n    \npublic\n \nfunction\n \nlaFacturaEstaPagada\n()\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n     * @Then he obtenido :arg1 puntos\n\n\n     */\n\n    \npublic\n \nfunction\n \nheObtenidoPuntos\n(\n$arg1\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n     * @When pago con :arg1 puntos y :arg2 euros\n\n\n     */\n\n    \npublic\n \nfunction\n \npagoConPuntosYEuros\n(\n$arg1\n,\n \n$arg2\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n     * @Then quedan :arg1 euros por pagar\n\n\n     */\n\n    \npublic\n \nfunction\n \nquedanEurosPorPagar\n(\n$arg1\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n     * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2\n\n\n     */\n\n    \npublic\n \nfunction\n \nqueHeCompradoMenuDelNumero\n(\n$arg1\n,\n \n$arg2\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nEjecutamos behat y vemos que ya hay pruebas que pasan:\n\n\n1\n2\n3\n5\n scenarios \n(\n5\n pending\n)\n\n\n32\n steps \n(\n5\n passed, \n5\n pending, \n22\n skipped\n)\n\n0m0.03s \n(\n9\n.54Mb\n)", 
            "title": "Crear el proyecto"
        }, 
        {
            "location": "/start-project/#crear-el-proyecto", 
            "text": "Vamos a implementar el proyecto que implemente las caracter\u00edsticas descritas en el apartado anterior. Vamos a hacer uso de un esqueleto que ya tiene configurado:  1 composer create aulasoftwarelibre/bdd-by-example    Se nos crear\u00e1 un directorio con todo lo que necesitamos para empezar a trabajar. Si analizamos el fichero  composer.json  veremos las dependencias de nuestro proyecto:  1\n2\n3\n4\n5\n6\n7\n8\n9 { \n     require-dev :   { \n         behat/behat :   ^3.4 , \n         kanel/phpspec-data-provider-extension :   ^1.0 , \n         phpspec/phpspec :   ^4.3 , \n         leanphp/phpspec-code-coverage :   ^4.2 , \n         phpunit/phpunit :   ^7.0 \n     }  }", 
            "title": "Crear el proyecto"
        }, 
        {
            "location": "/start-project/#creacion-de-caracteristicas", 
            "text": "Las caracter\u00edsticas (ficheros  .feature ) deben ir dentro del directorio  features/  de nuestro proyecto.   Tip  Las cajas de ejemplo tienen un icono que, si lo pulsas, permiten copiar el contenido al portapapeles. \u00dasalo para ir m\u00e1s r\u00e1pido al copiar el c\u00f3digo.    Crearemos dentro de dicho directorio un fichero llamado  menu.feature  con el contenido que describimos en el cap\u00edtulo anterior.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50 #language: es  Caracter\u00edstica:  Pagar un men\u00fa      Reglas:      - 1 punto por cada euro.      - 10 puntos equivalen a un descuento de 1 euros.      - El IVA es del 10%       Antecedentes:          Dados los siguientes men\u00fas:          | n\u00famero | precio |          | 1      | 10     |          | 2      | 12     |          | 3      |  8     |      Escenario: Ganar puntos al pagar en efectivo          Dado  que he comprado  5  men\u00fas del n\u00famero  1           Cuando  pido la cuenta recibo una factura de  55  euros           Y  pago en efectivo con  55  euros           Entonces  la factura est\u00e1 pagada           Y  he obtenido  50  puntos       Escenario:  Pagar con dinero y puntos          Dado  que he comprado  5  men\u00fas del n\u00famero  1           Cuando  pido la cuenta recibo una factura de  55  euros           Y  pago con  10  puntos y  54  euros           Entonces  la factura est\u00e1 pagada           Y  he obtenido  0  puntos       Escenario:  Pagar con puntos          Dado  que he comprado  5  men\u00fas del n\u00famero  1           Cuando  pido la cuenta recibo una factura de  55  euros           Y  pago con  500  puntos y  5  euros           Entonces  la factura est\u00e1 pagada           Y  he obtenido  0  puntos       Escenario:  Intentar pagar el IVA con puntos          Dado  que he comprado  5  men\u00fas del n\u00famero  1           Cuando  pido la cuenta recibo una factura de  55  euros           Y  pago con  550  puntos y  0  euros           Entonces  quedan  5  euros por pagar       Escenario:  Comprar men\u00fas de varios tipos          Dado  que he comprado  1  men\u00fa del n\u00famero  1           Y  que he comprado  2  men\u00fas del n\u00famero  2           Y  que he comprado  2  men\u00fas del n\u00famero  3           Cuando  pido la cuenta recibo una factura de  55  euros           Y  pago en efectivo con  55  euros           Entonces  la factura est\u00e1 pagada           Y  he obtenido  50  puntos", 
            "title": "Creaci\u00f3n de caracter\u00edsticas"
        }, 
        {
            "location": "/start-project/#ejecucion-de-behat", 
            "text": "Ahora que tenemos las pruebas definidas vamos a ejecutar  behat :  1 vendor/bin/behat --snippets-for FeatureContext   Obtendremos el resumen de la ejecuci\u00f3n de pruebas que contiene la siguiente informaci\u00f3n:  1\n2\n3 5  scenarios  ( 5  undefined )  32  steps  ( 32  undefined ) \n0m0.02s  ( 9 .49Mb )    Lo que significa es que  behat  no reconoce ninguno de los  step  o pasos de los que se compone cada escenario. Esa parte debemos programarla nosotros. Para ello  behat  nos facilita el trabajo con una serie de  snippets . Veamos uno:  1\n2\n3\n4\n5\n6\n7\n8 ?php  /**   * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2   */  public   function   queHeCompradoMenusDelNumero ( $arg1 ,   $arg2 )  { \n     throw   new   PendingException ();  }    El  step  se compone de una cabecera con las palabras  @Given ,  @When  o  @Then   y una frase que coincide con la que hayamos determinado en el paso. Los n\u00fameros y las cadenas que se pongan entre comillas se convierten en par\u00e1metros del paso. Tambi\u00e9n es posible usar expresiones regulares, pero en esos casos debemos hacerlo a mano. El objetivo es meter todos estos snippets en el archivo de contexto que usa  Behat .  Si editamos el archivo  features/bootstrap/FeatureContext.php , veremos el archivo de contexto por defecto que usar  Behat . Podemos tener los que necesitemos, para separar los  steps  de forma conveniente, pero eso es configuraci\u00f3n avanzada del entorno y no nos vamos a meter en eso. Editamos el archivo y copiamos el siguiente contenido en \u00e9l:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95 ?php  use   Behat\\Behat\\Context\\Context ;  use   Behat\\Behat\\Tester\\Exception\\PendingException ;  use   Behat\\Gherkin\\Node\\PyStringNode ;  use   Behat\\Gherkin\\Node\\TableNode ;  /**  * Defines application features from the specific context.  */  class   FeatureContext   implements   Context  { \n     /**       * Initializes context.       *       * Every scenario gets its own context instance.       * You can also pass arbitrary arguments to the       * context constructor through behat.yml.       */ \n     public   function   __construct () \n     { \n     } \n\n     /**       * @Given los siguientes men\u00fas:       */ \n     public   function   losSiguientesMenus ( TableNode   $table ) \n     { \n         throw   new   PendingException (); \n     } \n\n     /**       * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2       */ \n     public   function   queHeCompradoMenusDelNumero ( $arg1 ,   $arg2 ) \n     { \n         throw   new   PendingException (); \n     } \n\n     /**       * @When pido la cuenta recibo una factura de :arg1 euros       */ \n     public   function   pidoLaCuentaReciboUnaFacturaDeEuros ( $arg1 ) \n     { \n         throw   new   PendingException (); \n     } \n\n     /**       * @When pago en efectivo con :arg1 euros       */ \n     public   function   pagoEnEfectivoConEuros ( $arg1 ) \n     { \n         throw   new   PendingException (); \n     } \n\n     /**       * @Then la factura est\u00e1 pagada       */ \n     public   function   laFacturaEstaPagada () \n     { \n         throw   new   PendingException (); \n     } \n\n     /**       * @Then he obtenido :arg1 puntos       */ \n     public   function   heObtenidoPuntos ( $arg1 ) \n     { \n         throw   new   PendingException (); \n     } \n\n     /**       * @When pago con :arg1 puntos y :arg2 euros       */ \n     public   function   pagoConPuntosYEuros ( $arg1 ,   $arg2 ) \n     { \n         throw   new   PendingException (); \n     } \n\n     /**       * @Then quedan :arg1 euros por pagar       */ \n     public   function   quedanEurosPorPagar ( $arg1 ) \n     { \n         throw   new   PendingException (); \n     } \n\n     /**       * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2       */ \n     public   function   queHeCompradoMenuDelNumero ( $arg1 ,   $arg2 ) \n     { \n         throw   new   PendingException (); \n     }  }    Si volvemos a ejecutar behat:  1 vendor/bin/behat   Obtenemos algo distinto:  1\n2\n3 5  scenarios  ( 5  pending )  32  steps  ( 5  pending,  27  skipped ) \n0m0.03s  ( 9 .54Mb )    Ya los escenarios no est\u00e1n como  undefined  sino como  pending .", 
            "title": "Ejecuci\u00f3n de behat"
        }, 
        {
            "location": "/start-project/#implementando-el-primer-step", 
            "text": "El primer  step  es el que corresponde con la parte de antecedentes:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 #language: es  Caracter\u00edstica:  Pagar un men\u00fa      Reglas:      - 1 punto por cada euro.      - 10 puntos equivalen a un descuento de 1 euros.      - El IVA es del 10%       Antecedentes:          Dados los siguientes men\u00fas:          | n\u00famero | precio |          | 1      | 10     |          | 2      | 12     |          | 3      |  8     |    Que corresponde al siguiente  snippet   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 ?php  use   Behat\\Behat\\Context\\Context ;  use   Behat\\Behat\\Tester\\Exception\\PendingException ;  use   Behat\\Gherkin\\Node\\PyStringNode ;  use   Behat\\Gherkin\\Node\\TableNode ;  /**   * Defines application features from the specific context.   */  class   FeatureContext   implements   Context  { \n     /**       * @Given los siguientes men\u00fas:       */       public   function   losSiguientesMenus ( TableNode   $table )       { \n         throw   new   PendingException (); \n     }  }    Y aqu\u00ed nos surge la primera necesidad, necesitamos una clase para almacenar men\u00fas.", 
            "title": "Implementando el primer step"
        }, 
        {
            "location": "/start-project/#phpspec", 
            "text": "PhpSpec es una herramienta para el dise\u00f1o de clases. Se usa, especialmente, para el dise\u00f1o de un modelo de dominio limpio, desacoplado y aislado sin involucrarse demasiado en la infraestructura. Principalmente lo que vamos a indicar con PhpSpec es la API de nuestra clase con el resto del dominio.  Por el momento, para poder pasar la prueba que falla  \"Dados los siguientes men\u00fas\", necesitamos una clase que nos ofrezca informaci\u00f3n del n\u00famero de men\u00fa y del precio. As\u00ed que vamos a empezar a describir nuestra clase con la ayuda de _PhpSpec :  1 vendor/bin/phpspec desc Restaurant/Menu    Warning  Debido a que la barra invertida '\\' sirve como secuencia de escape en la consola, usamos la barra normal '/' para separar el espacio de nombres de la clase. Otra opci\u00f3n es usar doble barra invertida:  1 vendor/bin/phpspec desc Restaurant \\\\ Menu    Obtendremos un archivo en  spec/Restaurant/MenuSpec.php :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 ?php  namespace   spec\\Restaurant ;  use   Restaurant\\Menu ;  use   PhpSpec\\ObjectBehavior ;  use   Prophecy\\Argument ;  class   MenuSpec   extends   ObjectBehavior  { \n     function   it_is_initializable () \n     { \n         $this - shouldHaveType ( Menu :: class ); \n     }  }    La especificaci\u00f3n indica que existe una clase que debe ser iniciable y de tipo  Restaurant\\Menu . Si ejecutamos las pruebas de  PhpSpec :  1 vendor/bin/phpspec run   Obtendremos la siguiente salida:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18   Restaurant \\M enu\n\n   11   ! is initializable\n        class Restaurant \\M enu does not exist.\n\n----  broken examples\n\n        Restaurant/Menu\n   11   ! is initializable\n        class Restaurant \\M enu does not exist. 1  specs 1  examples  ( 1  broken ) \n32ms\n\n  Do you want me to create  ` Restaurant \\M enu `   for  you?\n                                                                      [ Y/n ]    Nos avisa que la clase que se quiere probar no existe y si quiere probarla por nosotros. Para sucesivas veces, en este tutorial responderemos siempre s\u00ed a esta circunstancia aunque no se indique.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 Class Restaurant \\M enu created in .../bdd-by-example/src/Restaurant/Menu.php.\n\n\n      Restaurant \\M enu\n\n   11   \u2714 is initializable 1  specs 1  examples  ( 1  passed ) \n34ms   Obteniendo una clase Menu en nuestro proyecto en  src/Restaurant/Menu.php :  1\n2\n3\n4\n5\n6\n7 ?php  namespace   Restaurant ;  class   Menu  {  }    Vamos a seguir especificando los requisitos de nuestra clase para pasar la prueba. Concretamente necesitamos que nuestra clase sea capaz de indicar el n\u00famero de men\u00fa y el precio. Vamos a escribir la especificaci\u00f3n y la comentamos a continuaci\u00f3n. Modificamos nuestro  MenuSpec.php  as\u00ed:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33 ?php  namespace   spec\\Restaurant ;  use   Restaurant\\Menu ;  use   PhpSpec\\ObjectBehavior ;  use   Prophecy\\Argument ;  class   MenuSpec   extends   ObjectBehavior  { \n     const   NUMBER   =   10 ; \n     const   PRICE   =   2500 ; \n\n     function   let () \n     { \n         $this - beConstructedWith ( self :: NUMBER ,   self :: PRICE ); \n     } \n\n     function   it_is_initializable () \n     { \n         $this - shouldHaveType ( Menu :: class ); \n     } \n\n     function   it_has_a_menu_number () \n     { \n         $this - number () - shouldBe ( self :: NUMBER ); \n     } \n\n     function   it_has_a_price () \n     { \n         $this - price () - shouldBe ( self :: PRICE ); \n     }  }    Las l\u00edneas 24 y 29 especifican los dos comportamientos que esperamos de nuestra clase, devolver el n\u00famero y devolver el precio. Pero antes de devolver nada esa informaci\u00f3n debe incorporarse a trav\u00e9s del constructor. Para ello usamos la funci\u00f3n _ let_ (l\u00ednea 14), que sirve para configurar la prueba en su comienzo. En este caso, la l\u00ednea 16 construye la clase con el n\u00famero y el precio del men\u00fa. El uso de constantes es para ser m\u00e1s descriptivo a la hora de leer la prueba. Ya que hemos especificado como se construye la clase, especificamos los otros dos comportamientos.   Info  Estamos usando euros para los ejemplos. En realidad, y dado que PHP no tiene un tipo de datos para datos financieros, deber\u00edamos usar alguna clase  Moneda  o guardar los datos en c\u00e9ntimos para evitar el uso de decimales. Para simplificar el tutorial vamos a usar c\u00e9ntimos. As\u00ed que aunque en los test usemos euros en la clase  Menu  vamos a almacenar el valor en c\u00e9ntimos.   Para indicar el n\u00famero de men\u00fa, indicamos que llamamos a un m\u00e9todo  number()  (l\u00ednea 26) que debe devolver el mismo valor que se pas\u00f3 al constructor. Para indicar el precio, lo mismo pero llamando a un m\u00e9todo  price()  (l\u00ednea 31).  Ejecutamos otra vez  PhpSpec , respondiendo afirmativamente a todas las preguntas:  1 vendor/bin/phpspec run   Obteniendo la siguiente salida:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91       Restaurant \\M enu\n\n   19   ! is initializable\n        method Restaurant \\M enu::__construct not found.\n   24   ! has a menu number\n        method Restaurant \\M enu::__construct not found.\n   29   ! has a price\n        method Restaurant \\M enu::__construct not found.\n\n----  broken examples\n\n        Restaurant/Menu\n   19   ! is initializable\n        method Restaurant \\M enu::__construct not found.\n\n        Restaurant/Menu\n   24   ! has a menu number\n        method Restaurant \\M enu::__construct not found.\n\n        Restaurant/Menu\n   29   ! has a price\n        method Restaurant \\M enu::__construct not found. 1  specs 3  examples  ( 3  broken ) \n59ms\n\n  Do you want me to create  ` Restaurant \\M enu::__construct () `   for  you?            \n                                                                          [ Y/n ] \n\n  Method Restaurant \\M enu::__construct ()  has been created.\n\n\n      Restaurant \\M enu\n\n   19   \u2714 is initializable\n   24   ! has a menu number\n        method Restaurant \\M enu::number not found.\n   29   ! has a price\n        method Restaurant \\M enu::price not found.\n\n----  broken examples\n\n        Restaurant/Menu\n   24   ! has a menu number\n        method Restaurant \\M enu::number not found.\n\n        Restaurant/Menu\n   29   ! has a price\n        method Restaurant \\M enu::price not found. 1  specs 3  examples  ( 1  passed,  2  broken ) \n62ms\n\n  Do you want me to create  ` Restaurant \\M enu::number () `   for  you?                 \n                                                                          [ Y/n ] \n\n  Method Restaurant \\M enu::number ()  has been created.\n\n\n  Do you want me to create  ` Restaurant \\M enu::price () `   for  you?                  \n                                                                          [ Y/n ] \n\n  Method Restaurant \\M enu::price ()  has been created.\n\n\n      Restaurant \\M enu\n\n   19   \u2714 is initializable\n   24   \u2718 has a menu number\n        expected  [ integer:10 ] , but got null.\n   29   \u2718 has a price\n        expected  [ integer:2500 ] , but got null.\n\n----  failed examples\n\n        Restaurant/Menu\n   24   \u2718 has a menu number\n        expected  [ integer:10 ] , but got null.\n\n        Restaurant/Menu\n   29   \u2718 has a price\n        expected  [ integer:2500 ] , but got null. 1  specs 3  examples  ( 1  passed,  2  failed ) \n79ms   Evidentemente las pruebas fallar\u00e1n al final, pero es el proceso normal en desarrollo orientado a pruebas/comportamiento. Analicemos que ha ocurrido en nuestra clase  Menu :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 ?php  namespace   Restaurant ;  class   Menu  { \n     public   function   __construct ( $argument1 ,   $argument2 ) \n     { \n         // TODO: write logic here \n     } \n\n     public   function   number () \n     { \n         // TODO: write logic here \n     } \n\n     public   function   price () \n     { \n         // TODO: write logic here \n     }  }    La especificaci\u00f3n de la prueba ha creado el esqueleto de nuestra clase, ahora solo queda implementar la funcionalidad para pasar la especificaci\u00f3n:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26 ?php  declare ( strict_types = 1 );  namespace   Restaurant ;  class   Menu   implements   Priced  { \n     private   $number ; \n     private   $price ; \n\n     public   function   __construct ( int   $number ,   int   $price ) \n     { \n         $this - number   =   $number ; \n         $this - price   =   $price ; \n     } \n\n     public   function   number () :   int \n     { \n         return   $this - number ; \n     } \n\n     public   function   price () :   int \n     { \n         return   $this - price ; \n     }  }    Ejecutamos las pruebas y comprobamos que pasan:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 bash$ vendor/bin/phpspec run\n\n      Restaurant \\M enu\n\n   19   \u2714 is initializable\n   24   \u2714 has a menu number\n   29   \u2714 has a price 1  specs 3  examples  ( 3  passed ) \n60ms   Ya tenemos nuestra primera clase completada que pasa la especificaci\u00f3n.", 
            "title": "PhpSpec"
        }, 
        {
            "location": "/start-project/#terminar-de-implementar-el-primer-step", 
            "text": "Ahora podemos programar el paso para ir progresando en nuestros casos de uso. Editamos el archivo FeatureContext:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99 ?php  use   Behat\\Behat\\Context\\Context ;  use   Behat\\Behat\\Tester\\Exception\\PendingException ;  use   Behat\\Gherkin\\Node\\PyStringNode ;  use   Behat\\Gherkin\\Node\\TableNode ;  /**   * Defines application features from the specific context.   */  class   FeatureContext   implements   Context  {       private   $menus ;  \n     /**       * Initializes context.       *       * Every scenario gets its own context instance.       * You can also pass arbitrary arguments to the       * context constructor through behat.yml.       */ \n     public   function   __construct () \n     {           $this - menus   =   [];       } \n     /**       * @Given los siguientes men\u00fas:       */ \n     public   function   losSiguientesMenus ( TableNode   $table ) \n     {           foreach   ( $table - getHash ()   as   $menu )   {               $this - menus [ $menu [ n\u00famero ]]   =   new   \\Restaurant\\Menu ( $menu [ n\u00famero ],   $menu [ precio ]   *   100 );           }       } \n\n     /**       * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2       */ \n     public   function   queHeCompradoMenusDelNumero ( $arg1 ,   $arg2 ) \n     { \n         throw   new   PendingException (); \n     } \n\n     /**       * @When pido la cuenta recibo una factura de :arg1 euros       */ \n     public   function   pidoLaCuentaReciboUnaFacturaDeEuros ( $arg1 ) \n     { \n         throw   new   PendingException (); \n     } \n\n     /**       * @When pago en efectivo con :arg1 euros       */ \n     public   function   pagoEnEfectivoConEuros ( $arg1 ) \n     { \n         throw   new   PendingException (); \n     } \n\n     /**       * @Then la factura est\u00e1 pagada       */ \n     public   function   laFacturaEstaPagada () \n     { \n         throw   new   PendingException (); \n     } \n\n     /**       * @Then he obtenido :arg1 puntos       */ \n     public   function   heObtenidoPuntos ( $arg1 ) \n     { \n         throw   new   PendingException (); \n     } \n\n     /**       * @When pago con :arg1 puntos y :arg2 euros       */ \n     public   function   pagoConPuntosYEuros ( $arg1 ,   $arg2 ) \n     { \n         throw   new   PendingException (); \n     } \n\n     /**       * @Then quedan :arg1 euros por pagar       */ \n     public   function   quedanEurosPorPagar ( $arg1 ) \n     { \n         throw   new   PendingException (); \n     } \n\n     /**       * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2       */ \n     public   function   queHeCompradoMenuDelNumero ( $arg1 ,   $arg2 ) \n     { \n         throw   new   PendingException (); \n     }  }    Ejecutamos behat y vemos que ya hay pruebas que pasan:  1\n2\n3 5  scenarios  ( 5  pending )  32  steps  ( 5  passed,  5  pending,  22  skipped ) \n0m0.03s  ( 9 .54Mb )", 
            "title": "Terminar de implementar el primer step"
        }, 
        {
            "location": "/first-scenario/", 
            "text": "Implementando el primer escenario\n\n\nEl primer escenario es el siguiente:\n\n\n1\n2\n3\n4\n5\n6\nEscenario:\n Ganar puntos al pagar en efectivo\n\n\n    Dado \nque he comprado \n5\n men\u00fas del n\u00famero \n1\n\n\n    \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n    \nY \npago en efectivo con \n55\n euros\n\n\n    \nEntonces \nla factura est\u00e1 pagada\n\n\n    \nY \nhe obtenido \n50\n puntos\n\n\n\n\n\n\n\nPara implementar esta escenario, que es realmente el primero de nuestro proyecto que vamos a implementar, necesitamos una clase cuenta (\nBill\n) que guarde los men\u00fas que se han consumido e informe del coste total, de la cantidad que se ha ingresado (en dinero o puntos), de lo que resta por pagar y de los puntos obtenidos.\n\n\nDescribir la clase \nBill\n\n\nUsamos \nPhpSpec\n para crear la especificaci\u00f3n, siguiendo los pasos que anteriormente hicimos con la clase \nMenu\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\nbash$ vendor/bin/phpspec desc Restaurant/Bill\nSpecification \nfor\n Restaurant\n\\B\nill created in /home/sergio/Developer/curso-web/bdd-by-example/bdd-by-example/spec/Restaurant/BillSpec.php.\n\nbash$ vendor/bin/phpspec run\n\n      Restaurant\n\\B\nill\n\n  \n11\n  ! is initializable\n        class Restaurant\n\\B\nill does not exist.\n\n      Restaurant\n\\M\nenu\n\n  \n19\n  \u2714 is initializable\n  \n24\n  \u2714 has a menu number\n  \n29\n  \u2714 has a price\n\n----  broken examples\n\n        Restaurant/Bill\n  \n11\n  ! is initializable\n        class Restaurant\n\\B\nill does not exist.\n\n\n\n2\n specs\n\n4\n examples \n(\n3\n passed, \n1\n broken\n)\n\n71ms\n\n  Do you want me to create \n`\nRestaurant\n\\B\nill\n`\n \nfor\n you?                           \n                                                                         \n[\nY/n\n]\n\n\nClass Restaurant\n\\B\nill created in /home/sergio/Developer/curso-web/bdd-by-example/bdd-by-example/src/Restaurant/Bill.php.\n\n\n      Restaurant\n\\B\nill\n\n  \n11\n  \u2714 is initializable\n\n      Restaurant\n\\M\nenu\n\n  \n19\n  \u2714 is initializable\n  \n24\n  \u2714 has a menu number\n  \n29\n  \u2714 has a price\n\n\n\n2\n specs\n\n4\n examples \n(\n4\n passed\n)\n\n71ms\n\n\n\n\n\n\nYa tenemos nuestra especificaci\u00f3n \nspec/Restaurant/BillSpec.php\n y nuestra clase \nRestaurant/Bill.php\n\n\nAhora tenemos que describir la API de nuestra clase. Concretamente para este escenario nuestra clase debe proporcionar una API para:\n\n\n\n\nA\u00f1adir un men\u00fa a la cuenta\n\n\nObtener el total de la cuenta\n\n\nPermitir pagar una cantidad de dinero\n\n\nDeterminar cu\u00e1nto resta por pagar\n\n\nDeterminar cu\u00e1ntos puntos se han ganado\n\n\n\n\nPara esta prueba vamos a suponer que tenemos ya una instancia de \nMenu\n que cuesta 10\u20ac. \u00bfImporta el n\u00famero de men\u00fa? No, en realidad no. En m\u00e1s, \u00bfpodr\u00edamos a\u00f1adir elementos a la cuenta que no fueran men\u00fas? Lo l\u00f3gico es que s\u00ed. Entonces, \u00bfc\u00f3mo hacemos nuestra clase compatible con cualquier clase que tenga un precio? Pues utilizando interfaces. Vamos a crear una interfaz \nPriced\n que obligue a las clases que lo implementen a devolver \nprice()\n. Entramos en la primera refactorizaci\u00f3n de nuestra clase \nMenu\n.\n\n\nRefactorizar \nMenu\n\n\nA\u00f1adimos esta especificaci\u00f3n a \nMenuSpec\n:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n?php\n\n\nclass\n \nMenuSpec\n \nextends\n \nObjectBehavior\n\n\n{\n\n\n    \nfunction\n \nit_implements_price_interface\n()\n\n\n    \n{\n\n\n        \n$this\n-\nshouldImplement\n(\n\\Restaurant\\Priced\n::\nclass\n);\n\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n\nInfo\n\n\nPonemos el namespace completo de \n\\Restaurant\\Price\n, pero podemos importarla con \nuse Restaurant\\Price;\n en la cabecera de nuestro archivo.\n\n\n\n\nEn este caso \nPriced\n a\u00fan no existe y la prueba fallar\u00e1, como es normal. Pero en esta ocasi\u00f3n \nphpspec\n no crear\u00e1 la clase, simplemente se limitar\u00e1 a fallar. Vamos a crear nuestra interfaz en \nRestaurant/Priced.php\n:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n?php\n\n\n\nnamespace\n \nRestaurant\n;\n\n\n\n\ninterface\n \nPriced\n\n\n{\n\n    \npublic\n \nfunction\n \nprice\n()\n:\n \nint\n;\n\n\n}\n\n\n\n\n\n\n\nAhora necesitamos que nuestra clase \nMenu\n implemente la interfaz \nPriced\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n?php\n\n\n\nnamespace\n \nRestaurant\n;\n\n\n\nclass\n \nMenu\n \nimplements\n \nPriced\n\n\n{\n\n    \nprivate\n \n$number\n;\n\n    \nprivate\n \n$price\n;\n\n\n    \npublic\n \nfunction\n \n__construct\n(\nint\n \n$number\n,\n \nint\n \n$price\n)\n\n    \n{\n\n        \n$this\n-\nnumber\n \n=\n \n$number\n;\n\n        \n$this\n-\nprice\n \n=\n \n$price\n;\n\n    \n}\n\n\n    \npublic\n \nfunction\n \nnumber\n()\n:\n \nint\n\n    \n{\n\n        \nreturn\n \n$this\n-\nnumber\n;\n\n    \n}\n\n\n    \npublic\n \nfunction\n \nprice\n()\n:\n \nint\n\n    \n{\n\n        \nreturn\n \n$this\n-\nprice\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nY ya hemos conseguido que la prueba pase:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\nvendor/bin/phpspec run\n\n      Restaurant\n\\B\nill\n\n  \n11\n  \u2714 is initializable\n\n      Restaurant\n\\M\nenu\n\n  \n19\n  \u2714 implements price interface\n  \n24\n  \u2714 is initializable\n  \n29\n  \u2714 has a menu number\n  \n34\n  \u2714 has a price\n\n\n\n2\n specs\n\n5\n examples \n(\n5\n passed\n)\n\n82ms\n\n\n\n\n\n\nA\u00f1adiendo elementos a la cuenta\n\n\nAhora ya podemos a\u00f1adir elementos a la cuenta, sin importarnos si es un men\u00fa o cualquier otra cosa, solo los importa que tenga precio. Vamos a hacer las pruebas con un solo elemento que cueste 10\u20ac.\n\n\nVamos a crear el m\u00e9todo \nlet\n para configurar los datos de ejemplo:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n?php\n\n\n\nnamespace\n \nspec\\Restaurant\n;\n\n\n\nuse\n \nRestaurant\\Bill\n;\n\n\nuse\n \nPhpSpec\\ObjectBehavior\n;\n\n\nuse\n \nProphecy\\Argument\n;\n\n\nuse\n \nRestaurant\\Priced\n;\n\n\n\nclass\n \nBillSpec\n \nextends\n \nObjectBehavior\n\n\n{\n\n    \nfunction\n \nlet\n(\nPriced\n \n$item\n)\n\n    \n{\n\n        \n$item\n-\nprice\n()\n-\nwillReturn\n(\n1000\n);\n\n    \n}\n\n\n    \nfunction\n \nit_is_initializable\n()\n\n    \n{\n\n        \n$this\n-\nshouldHaveType\n(\nBill\n::\nclass\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nEn esta ocasi\u00f3n no estamos usando \nlet\n para configurar el constructor de la clase, que por ahora no hemos determinado que vayamos a necesitar, sino para configurar una instancia de una clase que implementa el interfaz \nPriced\n y que cuando se llamen a la funci\u00f3n \nprice()\n devolver\u00e1 1000. Hay que tener en cuenta que \nPriced\n es una interfaz, no una clase, y que en realidad no ser\u00eda posible crear instancias de \nPriced\n. Sin embargo, \nphpspec\n crear un \ndoble\n, una clase que implementa la interfaz que se le indica y que simula las respuestas a los m\u00e9todos con los valores que se le indican con las cl\u00e1usulas \nwillReturn\n.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n?php\n\n\n\nnamespace\n \nspec\\Restaurant\n;\n\n\n\nuse\n \nRestaurant\\Bill\n;\n\n\nuse\n \nPhpSpec\\ObjectBehavior\n;\n\n\nuse\n \nProphecy\\Argument\n;\n\n\nuse\n \nRestaurant\\Priced\n;\n\n\n\nclass\n \nBillSpec\n \nextends\n \nObjectBehavior\n\n\n{\n\n    \nfunction\n \nlet\n(\nPriced\n \n$item\n)\n\n    \n{\n\n        \n$item\n-\nprice\n()\n-\nwillReturn\n(\n1000\n);\n\n    \n}\n\n\n    \nfunction\n \nit_is_initializable\n()\n\n    \n{\n\n        \n$this\n-\nshouldHaveType\n(\nBill\n::\nclass\n);\n\n    \n}\n\n\n    \nfunction\n \nit_has_no_items_by_default\n()\n\n    \n{\n\n        \n$this\n-\ngetTotal\n()\n-\nshouldBe\n(\n0\n);\n\n    \n}\n\n\n    \nfunction\n \nit_adds_an_item\n(\nPriced\n \n$item\n)\n\n    \n{\n\n        \n$this\n-\naddItem\n(\n$item\n);\n\n        \n$this\n-\ngetTotal\n()\n-\nshouldBe\n(\n1100\n)\n\n    \n}\n\n\n    \nfunction\n \nit_adds_multiple_items\n(\nPriced\n \n$item\n,\n \nPriced\n \n$anotherItem\n)\n\n    \n{\n\n        \n$anotherItem\n-\nprice\n()\n-\nwillReturn\n(\n2000\n);\n\n        \n$this\n-\naddItem\n(\n$item\n);\n\n        \n$this\n-\naddItem\n(\n$anotherItem\n);\n\n        \n$this\n-\ngetTotal\n()\n-\nshouldBe\n(\n3300\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nEstamos describiendo que nuestra cuenta, cuando se crea, no debe tener ning\u00fan elemento, y que los elementos que se a\u00f1aden incrementan la cuenta (con IVA). Debido al incremento del IVA el valor de retorno ser\u00e1 siempre flotante. Ejecutamos las pruebas, que fallar\u00e1n, y pasamos a implementar el c\u00f3digo. Pasamos a completar el c\u00f3digo de nuestra clase \nBill\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n?php\n\n\ndeclare\n(\nstrict_types\n=\n1\n);\n\n\n\nnamespace\n \nRestaurant\n;\n\n\n\nclass\n \nBill\n\n\n{\n\n    \nconst\n \nVAT\n \n=\n \n1.10\n;\n\n    \nprivate\n \n$items\n;\n\n\n    \npublic\n \nfunction\n \n__construct\n()\n\n    \n{\n\n        \n$this\n-\nitems\n \n=\n \n[];\n\n    \n}\n\n\n    \npublic\n \nfunction\n \ngetTotal\n()\n:\n \nint\n\n    \n{\n\n        \nreturn\n \narray_reduce\n(\n$this\n-\nitems\n,\n \nfunction\n \n(\n$carry\n,\n \nPriced\n \n$priced\n)\n \n{\n\n            \nreturn\n \n$carry\n \n+\n \n$priced\n-\nprice\n();\n\n        \n},\n \n0\n)\n \n*\n \nself\n::\nVAT\n;\n\n    \n}\n\n\n    \npublic\n \nfunction\n \naddItem\n(\nPriced\n \n$item\n)\n:\n \nvoid\n\n    \n{\n\n        \n$this\n-\nitems\n[]\n \n=\n \n$item\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nY ejecutamos las pruebas:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\nvendor/bin/phpspec run Restaurant\n\\\\\nBill\n\n    Restaurant\n\\B\nill\n\n\n17\n  \u2714 is initializable\n\n22\n  \u2714 has no items by default\n\n27\n  \u2714 adds an item\n\n33\n  \u2714 adds multiple items\n\n\n\n1\n specs\n\n4\n examples \n(\n4\n passed\n)\n\n112ms\n\n\n\n\n\n\nImplementando los primeros steps\n\n\nAhora estamos en posici\u00f3n de implementar los primeros steps:\n\n\n1\n2\n3\n4\n5\n6\nEscenario:\n Ganar puntos al pagar en efectivo\n\n\n    Dado \nque he comprado \n5\n men\u00fas del n\u00famero \n1\n\n\n    \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n    \nY \npago en efectivo con \n55\n euros\n\n\n    \nEntonces \nla factura est\u00e1 pagada\n\n\n    \nY \nhe obtenido \n50\n puntos\n\n\n\n\n\n\n\nQuedando el c\u00f3digo en el archivo \nFeatureContext\n como sigue:\n\n\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n?php\n\n\n\nuse\n \nBehat\\Behat\\Context\\Context\n;\n\n\nuse\n \nBehat\\Behat\\Tester\\Exception\\PendingException\n;\n\n\nuse\n \nBehat\\Gherkin\\Node\\PyStringNode\n;\n\n\nuse\n \nBehat\\Gherkin\\Node\\TableNode\n;\n\n\n\n/**\n\n\n* Defines application features from the specific context.\n\n\n*/\n\n\nclass\n \nFeatureContext\n \nimplements\n \nContext\n\n\n{\n\n    \nprivate\n \n$menus\n;\n\n\n    \nprivate\n \n$bill\n;\n\n\n\n    \n/**\n\n\n    * Initializes context.\n\n\n    *\n\n\n    * Every scenario gets its own context instance.\n\n\n    * You can also pass arbitrary arguments to the\n\n\n    * context constructor through behat.yml.\n\n\n    */\n\n    \npublic\n \nfunction\n \n__construct\n()\n\n    \n{\n\n        \n$this\n-\nmenus\n \n=\n \n[];\n\n\n        \n$this\n-\nbill\n \n=\n \nnew\n \n\\Restaurant\\Bill\n();\n\n\n    \n}\n\n\n    \n/**\n\n\n    * @Given los siguientes men\u00fas:\n\n\n    */\n\n    \npublic\n \nfunction\n \nlosSiguientesMenus\n(\nTableNode\n \n$table\n)\n\n    \n{\n\n        \nforeach\n \n(\n$table\n-\ngetHash\n()\n \nas\n \n$menu\n)\n \n{\n\n            \n$this\n-\nmenus\n[\n$menu\n[\nn\u00famero\n]]\n \n=\n \nnew\n \n\\Restaurant\\Menu\n(\n$menu\n[\nn\u00famero\n],\n \n$menu\n[\nprecio\n]\n \n*\n \n100\n);\n\n        \n}\n\n    \n}\n\n\n    \n/**\n\n\n    * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2\n\n\n    */\n\n    \npublic\n \nfunction\n \nqueHeCompradoMenusDelNumero\n(\n$count\n,\n \n$menuNumber\n)\n\n    \n{\n\n\n        \n$menu\n \n=\n \n$this\n-\nmenus\n[\n$menuNumber\n];\n\n\n\n\n        \nfor\n(\n$i\n \n=\n \n0\n;\n \n$i\n \n \n$count\n;\n \n$i\n++\n)\n \n{\n\n\n            \n$this\n-\nbill\n-\naddItem\n(\n$menu\n);\n\n\n        \n}\n\n\n    \n}\n\n\n    \n/**\n\n\n    * @When pido la cuenta recibo una factura de :arg1 euros\n\n\n    */\n\n    \npublic\n \nfunction\n \npidoLaCuentaReciboUnaFacturaDeEuros\n(\n$total\n)\n\n    \n{\n\n\n        \n\\PHPUnit\\Framework\\Assert\n::\nassertEquals\n(\n$total\n \n*\n \n100\n,\n \n$this\n-\nbill\n-\ngetTotal\n());\n\n\n    \n}\n\n\n    \n/**\n\n\n    * @When pago en efectivo con :arg1 euros\n\n\n    */\n\n    \npublic\n \nfunction\n \npagoEnEfectivoConEuros\n(\n$arg1\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n    * @Then la factura est\u00e1 pagada\n\n\n    */\n\n    \npublic\n \nfunction\n \nlaFacturaEstaPagada\n()\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n    * @Then he obtenido :arg1 puntos\n\n\n    */\n\n    \npublic\n \nfunction\n \nheObtenidoPuntos\n(\n$arg1\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n    * @When pago con :arg1 puntos y :arg2 euros\n\n\n    */\n\n    \npublic\n \nfunction\n \npagoConPuntosYEuros\n(\n$arg1\n,\n \n$arg2\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n    * @Then quedan :arg1 euros por pagar\n\n\n    */\n\n    \npublic\n \nfunction\n \nquedanEurosPorPagar\n(\n$arg1\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n    * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2\n\n\n    */\n\n    \npublic\n \nfunction\n \nqueHeCompradoMenuDelNumero\n(\n$arg1\n,\n \n$arg2\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nY comprobamos que, efectivamente, el c\u00f3digo funciona:\n\n\nbash$ vendor/bin/behat features/menu.feature:16\nCaracter\u00edstica: Pagar un men\u00fa\n  Reglas:\n\n  - 1 punto por cada euro.\n  - 10 puntos equivalen a un descuento de 1 euros.\n  - El IVA es del 10%\n\n  Antecedentes:                 # features/menu.feature:9\n    Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus()\n      | n\u00famero | precio |\n      | 1      | 10     |\n      | 2      | 12     |\n      | 3      | 8      |\n\n  Escenario: Ganar puntos al pagar en efectivo           # features/menu.feature:16\n    Dado que he comprado 5 men\u00fas del n\u00famero 1            # FeatureContext::queHeCompradoMenusDelNumero()\n    Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros()\n    Y pago en efectivo con 55 euros                      # FeatureContext::pagoEnEfectivoConEuros()\n      TODO: write pending definition\n    Entonces la factura est\u00e1 pagada                      # FeatureContext::laFacturaEstaPagada()\n    Y he obtenido 50 puntos                              # FeatureContext::heObtenidoPuntos()\n\n1 scenario (1 pending)\n6 steps (3 passed, 1 pending, 2 skipped)\n0m0.02s (10.09Mb)\n\n\n\n\n\nImplementando el pago\n\n\nPara implementar el pago debemos ser capaces de indicar una cantidad pagada en met\u00e1lico, ver cu\u00e1nto queda por pagar y ver cu\u00e1ntos puntos hemos obtenido.\n\n\nEsta ser\u00eda la especificaci\u00f3n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n?php\n\n\n\nnamespace\n \nspec\\Restaurant\n;\n\n\n\nuse\n \nRestaurant\\Bill\n;\n\n\nuse\n \nPhpSpec\\ObjectBehavior\n;\n\n\nuse\n \nProphecy\\Argument\n;\n\n\nuse\n \nRestaurant\\Priced\n;\n\n\n\nclass\n \nBillSpec\n \nextends\n \nObjectBehavior\n\n\n{\n\n    \nfunction\n \nlet\n(\nPriced\n \n$item\n)\n\n    \n{\n\n        \n$item\n-\nprice\n()\n-\nwillReturn\n(\n1000\n);\n\n    \n}\n\n\n    \nfunction\n \nit_is_initializable\n()\n\n    \n{\n\n        \n$this\n-\nshouldHaveType\n(\nBill\n::\nclass\n);\n\n    \n}\n\n\n    \nfunction\n \nit_has_no_items_by_default\n()\n\n    \n{\n\n        \n$this\n-\ngetTotal\n()\n-\nshouldBe\n(\n0\n);\n\n    \n}\n\n\n    \nfunction\n \nit_adds_an_item\n(\nPriced\n \n$item\n)\n\n    \n{\n\n        \n$this\n-\naddItem\n(\n$item\n);\n\n        \n$this\n-\ngetTotal\n()\n-\nshouldBe\n(\n1100\n);\n\n    \n}\n\n\n    \nfunction\n \nit_adds_multiple_items\n(\nPriced\n \n$item\n,\n \nPriced\n \n$anotherItem\n)\n\n    \n{\n\n        \n$anotherItem\n-\nprice\n()\n-\nwillReturn\n(\n2000\n);\n\n        \n$this\n-\naddItem\n(\n$item\n);\n\n        \n$this\n-\naddItem\n(\n$anotherItem\n);\n\n        \n$this\n-\ngetTotal\n()\n-\nshouldBe\n(\n3300\n);\n\n    \n}\n\n\n\n    \nfunction\n \nit_can_be_paid_with_money\n(\nPriced\n \n$item\n)\n\n\n    \n{\n\n\n        \n$this\n-\naddItem\n(\n$item\n);\n\n\n        \n$this\n-\npayWithMoney\n(\n1100\n);\n\n\n        \n$this\n-\nrestToPay\n()\n-\nshouldBe\n(\n0\n);\n\n\n    \n}\n\n\n\n\n    \nfunction\n \nit_can_give_points_when_is_payed_with_money\n(\nPriced\n \n$item\n)\n\n\n    \n{\n\n\n        \n$this\n-\naddItem\n(\n$item\n);\n\n\n        \n$this\n-\npayWithMoney\n(\n1100\n);\n\n\n        \n$this\n-\ngetPoints\n()\n-\nshouldBe\n(\n10\n);\n\n\n    \n}\n\n\n\n\n    \nfunction\n \nit_can_not_give_points_when_total_is_not_enough\n(\nPriced\n \n$anotherItem\n)\n\n\n    \n{\n\n\n        \n$anotherItem\n-\nprice\n()\n-\nwillReturn\n(\n99\n);\n\n\n\n\n        \n$this\n-\naddItem\n(\n$anotherItem\n);\n\n\n        \n$this\n-\npayWithMoney\n(\n109\n);\n\n\n        \n$this\n-\ngetPoints\n()\n-\nshouldBe\n(\n0\n);\n\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nEstamos describiendo distintos casos:\n\n\n\n\nCuando se paga exacto y no queda nada por pagar\n\n\nCuando se pagan justo 10 euros\n\n\nCuando se pagan menos de 1 euro\n\n\n\n\nPodr\u00edamos ser m\u00e1s exhaustivos, como determinar que no se den puntos hasta que no se pague, pero lo dejamos para los casos siguientes.\n\n\nEjecutamos las pruebas para que \nphpspec\n genere los m\u00e9todos en nuestra clase y completamos el c\u00f3digo en la clase \nBill\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n?php\n\n\ndeclare\n(\nstrict_types\n=\n1\n);\n\n\n\nnamespace\n \nRestaurant\n;\n\n\n\nclass\n \nBill\n\n\n{\n\n    \nconst\n \nVAT\n \n=\n \n1.10\n;\n\n    \nprivate\n \n$items\n;\n\n    \nprivate\n \n$amount\n;\n\n\n    \npublic\n \nfunction\n \n__construct\n()\n\n    \n{\n\n        \n$this\n-\nitems\n \n=\n \n[];\n\n    \n}\n\n\n    \npublic\n \nfunction\n \ngetTotal\n()\n:\n \nint\n\n    \n{\n\n\n        \nreturn\n \n(\nint\n)\n \nround\n(\n$this\n-\ntotalWithoutVAT\n()\n \n*\n \nself\n::\nVAT\n);\n\n\n    \n}\n\n\n    \npublic\n \nfunction\n \naddItem\n(\nPriced\n \n$item\n)\n:\n \nvoid\n\n    \n{\n\n        \n$this\n-\nitems\n[]\n \n=\n \n$item\n;\n\n    \n}\n\n\n\n    \npublic\n \nfunction\n \npayWithMoney\n(\nint\n \n$amount\n)\n:\n \nvoid\n\n\n    \n{\n\n\n        \n$this\n-\namount\n \n=\n \n$amount\n;\n\n\n    \n}\n\n\n\n\n    \npublic\n \nfunction\n \nrestToPay\n()\n:\n \nint\n\n\n    \n{\n\n\n        \nreturn\n \n$this\n-\ngetTotal\n()\n \n-\n \n$this\n-\namount\n;\n\n\n    \n}\n\n\n\n\n    \npublic\n \nfunction\n \ngetPoints\n()\n:\n \nint\n\n\n    \n{\n\n\n        \nreturn\n \n(\nint\n)\n \nfloor\n(\n$this\n-\ntotalWithoutVAT\n()\n \n/\n \n100\n);\n\n\n    \n}\n\n\n\n\n    \nprivate\n \nfunction\n \ntotalWithoutVAT\n()\n:\n \nint\n\n\n    \n{\n\n\n        \nreturn\n \narray_reduce\n(\n$this\n-\nitems\n,\n \nfunction\n \n(\n$carry\n,\n \nPriced\n \n$priced\n)\n \n{\n\n\n            \nreturn\n \n$carry\n \n+\n \n$priced\n-\nprice\n();\n\n\n        \n},\n \n0\n);\n\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nY comprobamos que pasamos las pruebas:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\nbash$ vendor/bin/phpspec run Restaurant\n\\\\\nBill\n\n    Restaurant\n\\B\nill\n\n\n17\n  \u2714 is initializable\n\n22\n  \u2714 has no items by default\n\n27\n  \u2714 adds an item\n\n33\n  \u2714 adds multiple items\n\n41\n  \u2714 can be paid with money\n\n48\n  \u2714 can give points when is payed with money\n\n55\n  \u2714 can not give points when total is not enough\n\n\n\n1\n specs\n\n7\n examples \n(\n7\n passed\n)\n\n172ms\n\n\n\n\n\n\nYa nos resta terminar de implementar la historia de usuario. Nuestra clase \nFeatureContext\n queda as\u00ed:\n\n\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n?php\n\n\n\nuse\n \nBehat\\Behat\\Context\\Context\n;\n\n\nuse\n \nBehat\\Behat\\Tester\\Exception\\PendingException\n;\n\n\nuse\n \nBehat\\Gherkin\\Node\\PyStringNode\n;\n\n\nuse\n \nBehat\\Gherkin\\Node\\TableNode\n;\n\n\n\n/**\n\n\n* Defines application features from the specific context.\n\n\n*/\n\n\nclass\n \nFeatureContext\n \nimplements\n \nContext\n\n\n{\n\n    \nprivate\n \n$menus\n;\n\n    \nprivate\n \n$bill\n;\n\n\n    \n/**\n\n\n    * Initializes context.\n\n\n    *\n\n\n    * Every scenario gets its own context instance.\n\n\n    * You can also pass arbitrary arguments to the\n\n\n    * context constructor through behat.yml.\n\n\n    */\n\n    \npublic\n \nfunction\n \n__construct\n()\n\n    \n{\n\n        \n$this\n-\nmenus\n \n=\n \n[];\n\n        \n$this\n-\nbill\n \n=\n \nnew\n \n\\Restaurant\\Bill\n();\n\n    \n}\n\n    \n/**\n\n\n    * @Given los siguientes men\u00fas:\n\n\n    */\n\n    \npublic\n \nfunction\n \nlosSiguientesMenus\n(\nTableNode\n \n$table\n)\n\n    \n{\n\n        \nforeach\n \n(\n$table\n-\ngetHash\n()\n \nas\n \n$menu\n)\n \n{\n\n            \n$this\n-\nmenus\n[\n$menu\n[\nn\u00famero\n]]\n \n=\n \nnew\n \n\\Restaurant\\Menu\n(\n$menu\n[\nn\u00famero\n],\n \n$menu\n[\nprecio\n]\n \n*\n \n100\n);\n\n        \n}\n\n    \n}\n\n\n    \n/**\n\n\n    * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2\n\n\n    */\n\n    \npublic\n \nfunction\n \nqueHeCompradoMenusDelNumero\n(\n$count\n,\n \n$menuNumber\n)\n\n    \n{\n\n        \n$menu\n \n=\n \n$this\n-\nmenus\n[\n$menuNumber\n];\n\n\n        \nfor\n(\n$i\n \n=\n \n0\n;\n \n$i\n \n \n$count\n;\n \n$i\n++\n)\n \n{\n\n            \n$this\n-\nbill\n-\naddItem\n(\n$menu\n);\n\n        \n}\n\n    \n}\n\n\n    \n/**\n\n\n    * @When pido la cuenta recibo una factura de :arg1 euros\n\n\n    */\n\n    \npublic\n \nfunction\n \npidoLaCuentaReciboUnaFacturaDeEuros\n(\n$total\n)\n\n    \n{\n\n        \n\\PHPUnit\\Framework\\Assert\n::\nassertEquals\n(\n$total\n \n*\n \n100\n,\n \n$this\n-\nbill\n-\ngetTotal\n());\n\n    \n}\n\n\n    \n/**\n\n\n    * @When pago en efectivo con :arg1 euros\n\n\n    */\n\n    \npublic\n \nfunction\n \npagoEnEfectivoConEuros\n(\n$amount\n)\n\n    \n{\n\n\n        \n$this\n-\nbill\n-\npayWithMoney\n(\n$amount\n \n*\n \n100\n);\n\n\n    \n}\n\n\n    \n/**\n\n\n    * @Then la factura est\u00e1 pagada\n\n\n    */\n\n    \npublic\n \nfunction\n \nlaFacturaEstaPagada\n()\n\n    \n{\n\n\n        \n\\PHPUnit\\Framework\\Assert\n::\nassertEquals\n(\n0\n,\n \n$this\n-\nbill\n-\nrestToPay\n());\n\n\n    \n}\n\n\n    \n/**\n\n\n    * @Then he obtenido :arg1 puntos\n\n\n    */\n\n    \npublic\n \nfunction\n \nheObtenidoPuntos\n(\n$points\n)\n\n    \n{\n\n\n        \n\\PHPUnit\\Framework\\Assert\n::\nassertEquals\n(\n$points\n,\n \n$this\n-\nbill\n-\ngetPoints\n());\n\n\n    \n}\n\n\n    \n/**\n\n\n    * @When pago con :arg1 puntos y :arg2 euros\n\n\n    */\n\n    \npublic\n \nfunction\n \npagoConPuntosYEuros\n(\n$arg1\n,\n \n$arg2\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n    * @Then quedan :arg1 euros por pagar\n\n\n    */\n\n    \npublic\n \nfunction\n \nquedanEurosPorPagar\n(\n$arg1\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n    \n/**\n\n\n    * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2\n\n\n    */\n\n    \npublic\n \nfunction\n \nqueHeCompradoMenuDelNumero\n(\n$arg1\n,\n \n$arg2\n)\n\n    \n{\n\n        \nthrow\n \nnew\n \nPendingException\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nSi ejecutamos este primer escenario debemos comprobar que se ha completado con \u00e9xito:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nbash$ vendor/bin/behat features/menu.feature:16\nCaracter\u00edstica: Pagar un men\u00fa\nReglas:\n\n- \n1\n punto por cada euro.\n- \n10\n puntos equivalen a un descuento de \n1\n euros.\n- El IVA es del \n10\n%\n\nAntecedentes:                 \n# features/menu.feature:9\n\n    Dados los siguientes men\u00fas: \n# FeatureContext::losSiguientesMenus()\n\n    \n|\n n\u00famero \n|\n precio \n|\n\n    \n|\n \n1\n      \n|\n \n10\n     \n|\n\n    \n|\n \n2\n      \n|\n \n12\n     \n|\n\n    \n|\n \n3\n      \n|\n \n8\n      \n|\n\n\nEscenario: Ganar puntos al pagar en efectivo           \n# features/menu.feature:16\n\n    Dado que he comprado \n5\n men\u00fas del n\u00famero \n1\n            \n# FeatureContext::queHeCompradoMenusDelNumero()\n\n    Cuando pido la cuenta recibo una factura de \n55\n euros \n# FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros()\n\n    Y pago en efectivo con \n55\n euros                      \n# FeatureContext::pagoEnEfectivoConEuros()\n\n    Entonces la factura est\u00e1 pagada                      \n# FeatureContext::laFacturaEstaPagada()\n\n    Y he obtenido \n50\n puntos                              \n# FeatureContext::heObtenidoPuntos()\n\n\n\n1\n scenario \n(\n1\n passed\n)\n\n\n6\n steps \n(\n6\n passed\n)\n\n0m0.02s \n(\n10\n.08Mb\n)", 
            "title": "Implementando el primer escenario"
        }, 
        {
            "location": "/first-scenario/#implementando-el-primer-escenario", 
            "text": "El primer escenario es el siguiente:  1\n2\n3\n4\n5\n6 Escenario:  Ganar puntos al pagar en efectivo      Dado  que he comprado  5  men\u00fas del n\u00famero  1       Cuando  pido la cuenta recibo una factura de  55  euros       Y  pago en efectivo con  55  euros       Entonces  la factura est\u00e1 pagada       Y  he obtenido  50  puntos    Para implementar esta escenario, que es realmente el primero de nuestro proyecto que vamos a implementar, necesitamos una clase cuenta ( Bill ) que guarde los men\u00fas que se han consumido e informe del coste total, de la cantidad que se ha ingresado (en dinero o puntos), de lo que resta por pagar y de los puntos obtenidos.", 
            "title": "Implementando el primer escenario"
        }, 
        {
            "location": "/first-scenario/#describir-la-clase-bill", 
            "text": "Usamos  PhpSpec  para crear la especificaci\u00f3n, siguiendo los pasos que anteriormente hicimos con la clase  Menu .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47 bash$ vendor/bin/phpspec desc Restaurant/Bill\nSpecification  for  Restaurant \\B ill created in /home/sergio/Developer/curso-web/bdd-by-example/bdd-by-example/spec/Restaurant/BillSpec.php.\n\nbash$ vendor/bin/phpspec run\n\n      Restaurant \\B ill\n\n   11   ! is initializable\n        class Restaurant \\B ill does not exist.\n\n      Restaurant \\M enu\n\n   19   \u2714 is initializable\n   24   \u2714 has a menu number\n   29   \u2714 has a price\n\n----  broken examples\n\n        Restaurant/Bill\n   11   ! is initializable\n        class Restaurant \\B ill does not exist. 2  specs 4  examples  ( 3  passed,  1  broken ) \n71ms\n\n  Do you want me to create  ` Restaurant \\B ill `   for  you?                           \n                                                                          [ Y/n ] \n\nClass Restaurant \\B ill created in /home/sergio/Developer/curso-web/bdd-by-example/bdd-by-example/src/Restaurant/Bill.php.\n\n\n      Restaurant \\B ill\n\n   11   \u2714 is initializable\n\n      Restaurant \\M enu\n\n   19   \u2714 is initializable\n   24   \u2714 has a menu number\n   29   \u2714 has a price 2  specs 4  examples  ( 4  passed ) \n71ms   Ya tenemos nuestra especificaci\u00f3n  spec/Restaurant/BillSpec.php  y nuestra clase  Restaurant/Bill.php  Ahora tenemos que describir la API de nuestra clase. Concretamente para este escenario nuestra clase debe proporcionar una API para:   A\u00f1adir un men\u00fa a la cuenta  Obtener el total de la cuenta  Permitir pagar una cantidad de dinero  Determinar cu\u00e1nto resta por pagar  Determinar cu\u00e1ntos puntos se han ganado   Para esta prueba vamos a suponer que tenemos ya una instancia de  Menu  que cuesta 10\u20ac. \u00bfImporta el n\u00famero de men\u00fa? No, en realidad no. En m\u00e1s, \u00bfpodr\u00edamos a\u00f1adir elementos a la cuenta que no fueran men\u00fas? Lo l\u00f3gico es que s\u00ed. Entonces, \u00bfc\u00f3mo hacemos nuestra clase compatible con cualquier clase que tenga un precio? Pues utilizando interfaces. Vamos a crear una interfaz  Priced  que obligue a las clases que lo implementen a devolver  price() . Entramos en la primera refactorizaci\u00f3n de nuestra clase  Menu .", 
            "title": "Describir la clase Bill"
        }, 
        {
            "location": "/first-scenario/#refactorizar-menu", 
            "text": "A\u00f1adimos esta especificaci\u00f3n a  MenuSpec :  1\n2\n3\n4\n5\n6\n7\n8 ?php  class   MenuSpec   extends   ObjectBehavior  {       function   it_implements_price_interface ()       {           $this - shouldImplement ( \\Restaurant\\Priced :: class );       }  }     Info  Ponemos el namespace completo de  \\Restaurant\\Price , pero podemos importarla con  use Restaurant\\Price;  en la cabecera de nuestro archivo.   En este caso  Priced  a\u00fan no existe y la prueba fallar\u00e1, como es normal. Pero en esta ocasi\u00f3n  phpspec  no crear\u00e1 la clase, simplemente se limitar\u00e1 a fallar. Vamos a crear nuestra interfaz en  Restaurant/Priced.php :  1\n2\n3\n4\n5\n6\n7\n8\n9 ?php  namespace   Restaurant ;  interface   Priced  { \n     public   function   price () :   int ;  }    Ahora necesitamos que nuestra clase  Menu  implemente la interfaz  Priced :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25 ?php  namespace   Restaurant ;  class   Menu   implements   Priced  { \n     private   $number ; \n     private   $price ; \n\n     public   function   __construct ( int   $number ,   int   $price ) \n     { \n         $this - number   =   $number ; \n         $this - price   =   $price ; \n     } \n\n     public   function   number () :   int \n     { \n         return   $this - number ; \n     } \n\n     public   function   price () :   int \n     { \n         return   $this - price ; \n     }  }    Y ya hemos conseguido que la prueba pase:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 vendor/bin/phpspec run\n\n      Restaurant \\B ill\n\n   11   \u2714 is initializable\n\n      Restaurant \\M enu\n\n   19   \u2714 implements price interface\n   24   \u2714 is initializable\n   29   \u2714 has a menu number\n   34   \u2714 has a price 2  specs 5  examples  ( 5  passed ) \n82ms", 
            "title": "Refactorizar Menu"
        }, 
        {
            "location": "/first-scenario/#anadiendo-elementos-a-la-cuenta", 
            "text": "Ahora ya podemos a\u00f1adir elementos a la cuenta, sin importarnos si es un men\u00fa o cualquier otra cosa, solo los importa que tenga precio. Vamos a hacer las pruebas con un solo elemento que cueste 10\u20ac.  Vamos a crear el m\u00e9todo  let  para configurar los datos de ejemplo:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21 ?php  namespace   spec\\Restaurant ;  use   Restaurant\\Bill ;  use   PhpSpec\\ObjectBehavior ;  use   Prophecy\\Argument ;  use   Restaurant\\Priced ;  class   BillSpec   extends   ObjectBehavior  { \n     function   let ( Priced   $item ) \n     { \n         $item - price () - willReturn ( 1000 ); \n     } \n\n     function   it_is_initializable () \n     { \n         $this - shouldHaveType ( Bill :: class ); \n     }  }    En esta ocasi\u00f3n no estamos usando  let  para configurar el constructor de la clase, que por ahora no hemos determinado que vayamos a necesitar, sino para configurar una instancia de una clase que implementa el interfaz  Priced  y que cuando se llamen a la funci\u00f3n  price()  devolver\u00e1 1000. Hay que tener en cuenta que  Priced  es una interfaz, no una clase, y que en realidad no ser\u00eda posible crear instancias de  Priced . Sin embargo,  phpspec  crear un  doble , una clase que implementa la interfaz que se le indica y que simula las respuestas a los m\u00e9todos con los valores que se le indican con las cl\u00e1usulas  willReturn .   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40 ?php  namespace   spec\\Restaurant ;  use   Restaurant\\Bill ;  use   PhpSpec\\ObjectBehavior ;  use   Prophecy\\Argument ;  use   Restaurant\\Priced ;  class   BillSpec   extends   ObjectBehavior  { \n     function   let ( Priced   $item ) \n     { \n         $item - price () - willReturn ( 1000 ); \n     } \n\n     function   it_is_initializable () \n     { \n         $this - shouldHaveType ( Bill :: class ); \n     } \n\n     function   it_has_no_items_by_default () \n     { \n         $this - getTotal () - shouldBe ( 0 ); \n     } \n\n     function   it_adds_an_item ( Priced   $item ) \n     { \n         $this - addItem ( $item ); \n         $this - getTotal () - shouldBe ( 1100 ) \n     } \n\n     function   it_adds_multiple_items ( Priced   $item ,   Priced   $anotherItem ) \n     { \n         $anotherItem - price () - willReturn ( 2000 ); \n         $this - addItem ( $item ); \n         $this - addItem ( $anotherItem ); \n         $this - getTotal () - shouldBe ( 3300 ); \n     }  }    Estamos describiendo que nuestra cuenta, cuando se crea, no debe tener ning\u00fan elemento, y que los elementos que se a\u00f1aden incrementan la cuenta (con IVA). Debido al incremento del IVA el valor de retorno ser\u00e1 siempre flotante. Ejecutamos las pruebas, que fallar\u00e1n, y pasamos a implementar el c\u00f3digo. Pasamos a completar el c\u00f3digo de nuestra clase  Bill :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27 ?php  declare ( strict_types = 1 );  namespace   Restaurant ;  class   Bill  { \n     const   VAT   =   1.10 ; \n     private   $items ; \n\n     public   function   __construct () \n     { \n         $this - items   =   []; \n     } \n\n     public   function   getTotal () :   int \n     { \n         return   array_reduce ( $this - items ,   function   ( $carry ,   Priced   $priced )   { \n             return   $carry   +   $priced - price (); \n         },   0 )   *   self :: VAT ; \n     } \n\n     public   function   addItem ( Priced   $item ) :   void \n     { \n         $this - items []   =   $item ; \n     }  }    Y ejecutamos las pruebas:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 vendor/bin/phpspec run Restaurant \\\\ Bill\n\n    Restaurant \\B ill 17   \u2714 is initializable 22   \u2714 has no items by default 27   \u2714 adds an item 33   \u2714 adds multiple items 1  specs 4  examples  ( 4  passed ) \n112ms", 
            "title": "A\u00f1adiendo elementos a la cuenta"
        }, 
        {
            "location": "/first-scenario/#implementando-los-primeros-steps", 
            "text": "Ahora estamos en posici\u00f3n de implementar los primeros steps:  1\n2\n3\n4\n5\n6 Escenario:  Ganar puntos al pagar en efectivo      Dado  que he comprado  5  men\u00fas del n\u00famero  1       Cuando  pido la cuenta recibo una factura de  55  euros       Y  pago en efectivo con  55  euros       Entonces  la factura est\u00e1 pagada       Y  he obtenido  50  puntos    Quedando el c\u00f3digo en el archivo  FeatureContext  como sigue:    1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106 ?php  use   Behat\\Behat\\Context\\Context ;  use   Behat\\Behat\\Tester\\Exception\\PendingException ;  use   Behat\\Gherkin\\Node\\PyStringNode ;  use   Behat\\Gherkin\\Node\\TableNode ;  /**  * Defines application features from the specific context.  */  class   FeatureContext   implements   Context  { \n     private   $menus ;       private   $bill ;  \n     /**      * Initializes context.      *      * Every scenario gets its own context instance.      * You can also pass arbitrary arguments to the      * context constructor through behat.yml.      */ \n     public   function   __construct () \n     { \n         $this - menus   =   [];           $this - bill   =   new   \\Restaurant\\Bill ();       } \n\n     /**      * @Given los siguientes men\u00fas:      */ \n     public   function   losSiguientesMenus ( TableNode   $table ) \n     { \n         foreach   ( $table - getHash ()   as   $menu )   { \n             $this - menus [ $menu [ n\u00famero ]]   =   new   \\Restaurant\\Menu ( $menu [ n\u00famero ],   $menu [ precio ]   *   100 ); \n         } \n     } \n\n     /**      * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2      */ \n     public   function   queHeCompradoMenusDelNumero ( $count ,   $menuNumber ) \n     {           $menu   =   $this - menus [ $menuNumber ];            for ( $i   =   0 ;   $i     $count ;   $i ++ )   {               $this - bill - addItem ( $menu );           }       } \n\n     /**      * @When pido la cuenta recibo una factura de :arg1 euros      */ \n     public   function   pidoLaCuentaReciboUnaFacturaDeEuros ( $total ) \n     {           \\PHPUnit\\Framework\\Assert :: assertEquals ( $total   *   100 ,   $this - bill - getTotal ());       } \n\n     /**      * @When pago en efectivo con :arg1 euros      */ \n     public   function   pagoEnEfectivoConEuros ( $arg1 ) \n     { \n         throw   new   PendingException (); \n     } \n\n     /**      * @Then la factura est\u00e1 pagada      */ \n     public   function   laFacturaEstaPagada () \n     { \n         throw   new   PendingException (); \n     } \n\n     /**      * @Then he obtenido :arg1 puntos      */ \n     public   function   heObtenidoPuntos ( $arg1 ) \n     { \n         throw   new   PendingException (); \n     } \n\n     /**      * @When pago con :arg1 puntos y :arg2 euros      */ \n     public   function   pagoConPuntosYEuros ( $arg1 ,   $arg2 ) \n     { \n         throw   new   PendingException (); \n     } \n\n     /**      * @Then quedan :arg1 euros por pagar      */ \n     public   function   quedanEurosPorPagar ( $arg1 ) \n     { \n         throw   new   PendingException (); \n     } \n\n     /**      * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2      */ \n     public   function   queHeCompradoMenuDelNumero ( $arg1 ,   $arg2 ) \n     { \n         throw   new   PendingException (); \n     }  }    Y comprobamos que, efectivamente, el c\u00f3digo funciona:  bash$ vendor/bin/behat features/menu.feature:16\nCaracter\u00edstica: Pagar un men\u00fa\n  Reglas:\n\n  - 1 punto por cada euro.\n  - 10 puntos equivalen a un descuento de 1 euros.\n  - El IVA es del 10%\n\n  Antecedentes:                 # features/menu.feature:9\n    Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus()\n      | n\u00famero | precio |\n      | 1      | 10     |\n      | 2      | 12     |\n      | 3      | 8      |\n\n  Escenario: Ganar puntos al pagar en efectivo           # features/menu.feature:16\n    Dado que he comprado 5 men\u00fas del n\u00famero 1            # FeatureContext::queHeCompradoMenusDelNumero()\n    Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros()\n    Y pago en efectivo con 55 euros                      # FeatureContext::pagoEnEfectivoConEuros()\n      TODO: write pending definition\n    Entonces la factura est\u00e1 pagada                      # FeatureContext::laFacturaEstaPagada()\n    Y he obtenido 50 puntos                              # FeatureContext::heObtenidoPuntos()\n\n1 scenario (1 pending)\n6 steps (3 passed, 1 pending, 2 skipped)\n0m0.02s (10.09Mb)", 
            "title": "Implementando los primeros steps"
        }, 
        {
            "location": "/first-scenario/#implementando-el-pago", 
            "text": "Para implementar el pago debemos ser capaces de indicar una cantidad pagada en met\u00e1lico, ver cu\u00e1nto queda por pagar y ver cu\u00e1ntos puntos hemos obtenido.  Esta ser\u00eda la especificaci\u00f3n:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63 ?php  namespace   spec\\Restaurant ;  use   Restaurant\\Bill ;  use   PhpSpec\\ObjectBehavior ;  use   Prophecy\\Argument ;  use   Restaurant\\Priced ;  class   BillSpec   extends   ObjectBehavior  { \n     function   let ( Priced   $item ) \n     { \n         $item - price () - willReturn ( 1000 ); \n     } \n\n     function   it_is_initializable () \n     { \n         $this - shouldHaveType ( Bill :: class ); \n     } \n\n     function   it_has_no_items_by_default () \n     { \n         $this - getTotal () - shouldBe ( 0 ); \n     } \n\n     function   it_adds_an_item ( Priced   $item ) \n     { \n         $this - addItem ( $item ); \n         $this - getTotal () - shouldBe ( 1100 ); \n     } \n\n     function   it_adds_multiple_items ( Priced   $item ,   Priced   $anotherItem ) \n     { \n         $anotherItem - price () - willReturn ( 2000 ); \n         $this - addItem ( $item ); \n         $this - addItem ( $anotherItem ); \n         $this - getTotal () - shouldBe ( 3300 ); \n     }       function   it_can_be_paid_with_money ( Priced   $item )       {           $this - addItem ( $item );           $this - payWithMoney ( 1100 );           $this - restToPay () - shouldBe ( 0 );       }        function   it_can_give_points_when_is_payed_with_money ( Priced   $item )       {           $this - addItem ( $item );           $this - payWithMoney ( 1100 );           $this - getPoints () - shouldBe ( 10 );       }        function   it_can_not_give_points_when_total_is_not_enough ( Priced   $anotherItem )       {           $anotherItem - price () - willReturn ( 99 );            $this - addItem ( $anotherItem );           $this - payWithMoney ( 109 );           $this - getPoints () - shouldBe ( 0 );       }  }    Estamos describiendo distintos casos:   Cuando se paga exacto y no queda nada por pagar  Cuando se pagan justo 10 euros  Cuando se pagan menos de 1 euro   Podr\u00edamos ser m\u00e1s exhaustivos, como determinar que no se den puntos hasta que no se pague, pero lo dejamos para los casos siguientes.  Ejecutamos las pruebas para que  phpspec  genere los m\u00e9todos en nuestra clase y completamos el c\u00f3digo en la clase  Bill :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48 ?php  declare ( strict_types = 1 );  namespace   Restaurant ;  class   Bill  { \n     const   VAT   =   1.10 ; \n     private   $items ; \n     private   $amount ; \n\n     public   function   __construct () \n     { \n         $this - items   =   []; \n     } \n\n     public   function   getTotal () :   int \n     {           return   ( int )   round ( $this - totalWithoutVAT ()   *   self :: VAT );       } \n\n     public   function   addItem ( Priced   $item ) :   void \n     { \n         $this - items []   =   $item ; \n     }       public   function   payWithMoney ( int   $amount ) :   void       {           $this - amount   =   $amount ;       }        public   function   restToPay () :   int       {           return   $this - getTotal ()   -   $this - amount ;       }        public   function   getPoints () :   int       {           return   ( int )   floor ( $this - totalWithoutVAT ()   /   100 );       }        private   function   totalWithoutVAT () :   int       {           return   array_reduce ( $this - items ,   function   ( $carry ,   Priced   $priced )   {               return   $carry   +   $priced - price ();           },   0 );       }  }    Y comprobamos que pasamos las pruebas:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16 bash$ vendor/bin/phpspec run Restaurant \\\\ Bill\n\n    Restaurant \\B ill 17   \u2714 is initializable 22   \u2714 has no items by default 27   \u2714 adds an item 33   \u2714 adds multiple items 41   \u2714 can be paid with money 48   \u2714 can give points when is payed with money 55   \u2714 can not give points when total is not enough 1  specs 7  examples  ( 7  passed ) \n172ms   Ya nos resta terminar de implementar la historia de usuario. Nuestra clase  FeatureContext  queda as\u00ed:    1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105 ?php  use   Behat\\Behat\\Context\\Context ;  use   Behat\\Behat\\Tester\\Exception\\PendingException ;  use   Behat\\Gherkin\\Node\\PyStringNode ;  use   Behat\\Gherkin\\Node\\TableNode ;  /**  * Defines application features from the specific context.  */  class   FeatureContext   implements   Context  { \n     private   $menus ; \n     private   $bill ; \n\n     /**      * Initializes context.      *      * Every scenario gets its own context instance.      * You can also pass arbitrary arguments to the      * context constructor through behat.yml.      */ \n     public   function   __construct () \n     { \n         $this - menus   =   []; \n         $this - bill   =   new   \\Restaurant\\Bill (); \n     } \n     /**      * @Given los siguientes men\u00fas:      */ \n     public   function   losSiguientesMenus ( TableNode   $table ) \n     { \n         foreach   ( $table - getHash ()   as   $menu )   { \n             $this - menus [ $menu [ n\u00famero ]]   =   new   \\Restaurant\\Menu ( $menu [ n\u00famero ],   $menu [ precio ]   *   100 ); \n         } \n     } \n\n     /**      * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2      */ \n     public   function   queHeCompradoMenusDelNumero ( $count ,   $menuNumber ) \n     { \n         $menu   =   $this - menus [ $menuNumber ]; \n\n         for ( $i   =   0 ;   $i     $count ;   $i ++ )   { \n             $this - bill - addItem ( $menu ); \n         } \n     } \n\n     /**      * @When pido la cuenta recibo una factura de :arg1 euros      */ \n     public   function   pidoLaCuentaReciboUnaFacturaDeEuros ( $total ) \n     { \n         \\PHPUnit\\Framework\\Assert :: assertEquals ( $total   *   100 ,   $this - bill - getTotal ()); \n     } \n\n     /**      * @When pago en efectivo con :arg1 euros      */ \n     public   function   pagoEnEfectivoConEuros ( $amount ) \n     {           $this - bill - payWithMoney ( $amount   *   100 );       } \n\n     /**      * @Then la factura est\u00e1 pagada      */ \n     public   function   laFacturaEstaPagada () \n     {           \\PHPUnit\\Framework\\Assert :: assertEquals ( 0 ,   $this - bill - restToPay ());       } \n\n     /**      * @Then he obtenido :arg1 puntos      */ \n     public   function   heObtenidoPuntos ( $points ) \n     {           \\PHPUnit\\Framework\\Assert :: assertEquals ( $points ,   $this - bill - getPoints ());       } \n\n     /**      * @When pago con :arg1 puntos y :arg2 euros      */ \n     public   function   pagoConPuntosYEuros ( $arg1 ,   $arg2 ) \n     { \n         throw   new   PendingException (); \n     } \n\n     /**      * @Then quedan :arg1 euros por pagar      */ \n     public   function   quedanEurosPorPagar ( $arg1 ) \n     { \n         throw   new   PendingException (); \n     } \n\n     /**      * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2      */ \n     public   function   queHeCompradoMenuDelNumero ( $arg1 ,   $arg2 ) \n     { \n         throw   new   PendingException (); \n     }  }    Si ejecutamos este primer escenario debemos comprobar que se ha completado con \u00e9xito:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25 bash$ vendor/bin/behat features/menu.feature:16\nCaracter\u00edstica: Pagar un men\u00fa\nReglas:\n\n-  1  punto por cada euro.\n-  10  puntos equivalen a un descuento de  1  euros.\n- El IVA es del  10 %\n\nAntecedentes:                  # features/menu.feature:9 \n    Dados los siguientes men\u00fas:  # FeatureContext::losSiguientesMenus() \n     |  n\u00famero  |  precio  | \n     |   1        |   10       | \n     |   2        |   12       | \n     |   3        |   8        | \n\nEscenario: Ganar puntos al pagar en efectivo            # features/menu.feature:16 \n    Dado que he comprado  5  men\u00fas del n\u00famero  1              # FeatureContext::queHeCompradoMenusDelNumero() \n    Cuando pido la cuenta recibo una factura de  55  euros  # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() \n    Y pago en efectivo con  55  euros                       # FeatureContext::pagoEnEfectivoConEuros() \n    Entonces la factura est\u00e1 pagada                       # FeatureContext::laFacturaEstaPagada() \n    Y he obtenido  50  puntos                               # FeatureContext::heObtenidoPuntos()  1  scenario  ( 1  passed )  6  steps  ( 6  passed ) \n0m0.02s  ( 10 .08Mb )", 
            "title": "Implementando el pago"
        }, 
        {
            "location": "/second-scenario/", 
            "text": "Segundo escenario\n\n\nVamos a implementar ahora el segundo escenario\n\n\n1\n2\n3\n4\n5\n6\nEscenario:\n Pagar con dinero y puntos\n\n\n    Dado \nque he comprado \n5\n men\u00fas del n\u00famero \n1\n\n\n    \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n    \nY \npago con \n10\n puntos y \n54\n euros\n\n\n    \nEntonces \nla factura est\u00e1 pagada\n\n\n    \nY \nhe obtenido \n0\n puntos\n\n\n\n\n\n\n\nSi intentamos ejecutar la prueba directamente vemos que hay ya muchos pasos que pasan:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nvendor/bin/behat features/menu.feature:23\nCaracter\u00edstica: Pagar un men\u00fa\nReglas:\n\n- \n1\n punto por cada euro.\n- \n10\n puntos equivalen a un descuento de \n1\n euros.\n- El IVA es del \n10\n%\n\nAntecedentes:                 \n# features/menu.feature:9\n\n    Dados los siguientes men\u00fas: \n# FeatureContext::losSiguientesMenus()\n\n    \n|\n n\u00famero \n|\n precio \n|\n\n    \n|\n \n1\n      \n|\n \n10\n     \n|\n\n    \n|\n \n2\n      \n|\n \n12\n     \n|\n\n    \n|\n \n3\n      \n|\n \n8\n      \n|\n\n\nEscenario: Pagar con dinero y puntos                   \n# features/menu.feature:23\n\n    Dado que he comprado \n5\n men\u00fas del n\u00famero \n1\n            \n# FeatureContext::queHeCompradoMenusDelNumero()\n\n    Cuando pido la cuenta recibo una factura de \n55\n euros \n# FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros()\n\n    Y pago con \n10\n puntos y \n54\n euros                      \n# FeatureContext::pagoConPuntosYEuros()\n\n    TODO: write pending definition\n    Entonces la factura est\u00e1 pagada                      \n# FeatureContext::laFacturaEstaPagada()\n\n    Y he obtenido \n0\n puntos                               \n# FeatureContext::heObtenidoPuntos()\n\n\n\n1\n scenario \n(\n1\n pending\n)\n\n\n6\n steps \n(\n3\n passed, \n1\n pending, \n2\n skipped\n)\n\n0m0.02s \n(\n9\n.98Mb\n)\n\n\n\n\n\n\n\nSolo tenemos que implementar el pago con puntos.\n\n\nDescribir la funcionalidad\n\n\nEl primer paso, es escribir la descripci\u00f3n en nuestra especificaci\u00f3n de la clase \nBill\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n?php\n\n\n\nnamespace\n \nspec\\Restaurant\n;\n\n\n\nuse\n \nRestaurant\\Bill\n;\n\n\nuse\n \nPhpSpec\\ObjectBehavior\n;\n\n\nuse\n \nProphecy\\Argument\n;\n\n\nuse\n \nRestaurant\\Priced\n;\n\n\n\nclass\n \nBillSpec\n \nextends\n \nObjectBehavior\n\n\n{\n\n    \n// ...\n\n\n\n    \nfunction\n \nit_can_be_paith_with_money_and_points_and_get_no_points\n(\nPriced\n \n$item\n)\n\n\n    \n{\n\n\n        \n$this\n-\naddItem\n(\n$item\n);\n\n\n        \n$this\n-\npayWithMoney\n(\n1000\n);\n\n\n        \n$this\n-\npayWithPoints\n(\n10\n);\n\n\n        \n$this\n-\nrestToPay\n()\n-\nshouldBe\n(\n0\n);\n\n\n        \n$this\n-\ngetPoints\n()\n-\nshouldBe\n(\n0\n);\n\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nDe nuevo, ejecutamos las pruebas de \nphpspec\n para que se generen los m\u00e9todos necesarios en nuestra clase \nBill\n y refactorizamos nuestro c\u00f3digo para pasar la prueba:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n?php\n\n\ndeclare\n(\nstrict_types\n=\n1\n);\n\n\n\nnamespace\n \nRestaurant\n;\n\n\n\nclass\n \nBill\n\n\n{\n\n    \nconst\n \nVAT\n \n=\n \n1.10\n;\n\n    \nprivate\n \n$items\n;\n\n    \nprivate\n \n$amount\n;\n\n    \nprivate\n \n$points\n;\n\n\n    \npublic\n \nfunction\n \n__construct\n()\n\n    \n{\n\n        \n$this\n-\nitems\n \n=\n \n[];\n\n\n        \n$this\n-\npoints\n \n=\n \n0\n;\n\n\n        \n$this\n-\namount\n \n=\n \n0\n;\n\n    \n}\n\n\n    \npublic\n \nfunction\n \ngetTotal\n()\n:\n \nint\n\n    \n{\n\n        \nreturn\n \n(\nint\n)\n \nround\n(\n$this\n-\ntotalWithoutVAT\n()\n \n*\n \nself\n::\nVAT\n);\n\n    \n}\n\n\n    \npublic\n \nfunction\n \naddItem\n(\nPriced\n \n$item\n)\n:\n \nvoid\n\n    \n{\n\n        \n$this\n-\nitems\n[]\n \n=\n \n$item\n;\n\n    \n}\n\n\n    \npublic\n \nfunction\n \npayWithMoney\n(\nint\n \n$amount\n)\n:\n \nvoid\n\n    \n{\n\n        \n$this\n-\namount\n \n=\n \n$amount\n;\n\n    \n}\n\n\n    \npublic\n \nfunction\n \nrestToPay\n()\n:\n \nint\n\n    \n{\n\n\n        \nreturn\n \n$this\n-\ngetTotal\n()\n \n-\n \n$this\n-\namount\n \n-\n \n$this\n-\ngetMoneyPoints\n();\n\n\n    \n}\n\n\n    \npublic\n \nfunction\n \ngetPoints\n()\n:\n \nint\n\n    \n{\n\n        \nif\n \n(\n$this\n-\npoints\n \n \n0\n)\n \n{\n\n            \nreturn\n \n0\n;\n\n        \n}\n\n\n        \nreturn\n \n(\nint\n)\n \nfloor\n(\n$this\n-\ntotalWithoutVAT\n()\n \n/\n \n100\n);\n\n    \n}\n\n\n    \nprivate\n \nfunction\n \ntotalWithoutVAT\n()\n:\n \nint\n\n    \n{\n\n        \nreturn\n \narray_reduce\n(\n$this\n-\nitems\n,\n \nfunction\n \n(\n$carry\n,\n \nPriced\n \n$priced\n)\n \n{\n\n            \nreturn\n \n$carry\n \n+\n \n$priced\n-\nprice\n();\n\n        \n},\n \n0\n);\n\n    \n}\n\n\n\n    \npublic\n \nfunction\n \npayWithPoints\n(\nint\n \n$points\n)\n:\n \nvoid\n\n\n    \n{\n\n\n        \n$this\n-\npoints\n \n=\n \n$points\n;\n\n\n    \n}\n\n\n\n\n    \nprivate\n \nfunction\n \ngetMoneyPoints\n()\n:\n \nint\n\n\n    \n{\n\n\n        \nreturn\n \n100\n \n*\n \n(\n$this\n-\npoints\n \n/\n \n10\n);\n\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nComprobamos que pasamos las pruebas y pasamos a implementar la historia de usuario.\n\n\nCompletando la historia de usuario\n\n\nCreamos el c\u00f3digo que implementa el paso que nos falta:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n?php\n\n\n\nuse\n \nBehat\\Behat\\Context\\Context\n;\n\n\nuse\n \nBehat\\Behat\\Tester\\Exception\\PendingException\n;\n\n\nuse\n \nBehat\\Gherkin\\Node\\PyStringNode\n;\n\n\nuse\n \nBehat\\Gherkin\\Node\\TableNode\n;\n\n\n\n/**\n\n\n* Defines application features from the specific context.\n\n\n*/\n\n\nclass\n \nFeatureContext\n \nimplements\n \nContext\n\n\n{\n\n    \n// ...\n\n\n    \n/**\n\n\n    * @When pago con :points puntos y :money euros\n\n\n    */\n\n    \npublic\n \nfunction\n \npagoConPuntosYEuros\n(\n$points\n,\n \n$money\n)\n\n    \n{\n\n        \n$this\n-\nbill\n-\npayWithMoney\n(\n$money\n \n*\n \n100\n);\n\n        \n$this\n-\nbill\n-\npayWithPoints\n(\n$points\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nY ya hemos conseguido terminar otro escenario:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nvendor/bin/behat features/menu.feature:23\nCaracter\u00edstica: Pagar un men\u00fa\n  Reglas:\n\n  - \n1\n punto por cada euro.\n  - \n10\n puntos equivalen a un descuento de \n1\n euros.\n  - El IVA es del \n10\n%\n\n  Antecedentes:                 \n# features/menu.feature:9\n\n    Dados los siguientes men\u00fas: \n# FeatureContext::losSiguientesMenus()\n\n      \n|\n n\u00famero \n|\n precio \n|\n\n      \n|\n \n1\n      \n|\n \n10\n     \n|\n\n      \n|\n \n2\n      \n|\n \n12\n     \n|\n\n      \n|\n \n3\n      \n|\n \n8\n      \n|\n\n\n  Escenario: Pagar con dinero y puntos                   \n# features/menu.feature:23\n\n    Dado que he comprado \n5\n men\u00fas del n\u00famero \n1\n            \n#     FeatureContext::queHeCompradoMenusDelNumero()\n\n    Cuando pido la cuenta recibo una factura de \n55\n euros \n#     FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros()\n\n    Y pago con \n10\n puntos y \n54\n euros                      \n#     FeatureContext::pagoConPuntosYEuros()\n\n    Entonces la factura est\u00e1 pagada                      \n#     FeatureContext::laFacturaEstaPagada()\n\n    Y he obtenido \n0\n puntos                               \n#     FeatureContext::heObtenidoPuntos()\n\n\n\n1\n scenario \n(\n1\n passed\n)\n\n\n6\n steps \n(\n6\n passed\n)\n\n0m0.02s \n(\n10\n.09Mb\n)\n\n\n\n\n\n\n\nConclusiones\n\n\nComo vamos viendo, el c\u00f3digo que se genera en \nphpspec\n es realmente el c\u00f3digo que implementa nuestras reglas de negocio. En \nbehat\n solo implementamos c\u00f3digo para poder usar el dominio en las pruebas y comprobar que nuestras dos clases (\nMenu\n y \nBill\n) trabajan bien juntas.", 
            "title": "Segundo escenario"
        }, 
        {
            "location": "/second-scenario/#segundo-escenario", 
            "text": "Vamos a implementar ahora el segundo escenario  1\n2\n3\n4\n5\n6 Escenario:  Pagar con dinero y puntos      Dado  que he comprado  5  men\u00fas del n\u00famero  1       Cuando  pido la cuenta recibo una factura de  55  euros       Y  pago con  10  puntos y  54  euros       Entonces  la factura est\u00e1 pagada       Y  he obtenido  0  puntos    Si intentamos ejecutar la prueba directamente vemos que hay ya muchos pasos que pasan:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26 vendor/bin/behat features/menu.feature:23\nCaracter\u00edstica: Pagar un men\u00fa\nReglas:\n\n-  1  punto por cada euro.\n-  10  puntos equivalen a un descuento de  1  euros.\n- El IVA es del  10 %\n\nAntecedentes:                  # features/menu.feature:9 \n    Dados los siguientes men\u00fas:  # FeatureContext::losSiguientesMenus() \n     |  n\u00famero  |  precio  | \n     |   1        |   10       | \n     |   2        |   12       | \n     |   3        |   8        | \n\nEscenario: Pagar con dinero y puntos                    # features/menu.feature:23 \n    Dado que he comprado  5  men\u00fas del n\u00famero  1              # FeatureContext::queHeCompradoMenusDelNumero() \n    Cuando pido la cuenta recibo una factura de  55  euros  # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() \n    Y pago con  10  puntos y  54  euros                       # FeatureContext::pagoConPuntosYEuros() \n    TODO: write pending definition\n    Entonces la factura est\u00e1 pagada                       # FeatureContext::laFacturaEstaPagada() \n    Y he obtenido  0  puntos                                # FeatureContext::heObtenidoPuntos()  1  scenario  ( 1  pending )  6  steps  ( 3  passed,  1  pending,  2  skipped ) \n0m0.02s  ( 9 .98Mb )    Solo tenemos que implementar el pago con puntos.", 
            "title": "Segundo escenario"
        }, 
        {
            "location": "/second-scenario/#describir-la-funcionalidad", 
            "text": "El primer paso, es escribir la descripci\u00f3n en nuestra especificaci\u00f3n de la clase  Bill :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22 ?php  namespace   spec\\Restaurant ;  use   Restaurant\\Bill ;  use   PhpSpec\\ObjectBehavior ;  use   Prophecy\\Argument ;  use   Restaurant\\Priced ;  class   BillSpec   extends   ObjectBehavior  { \n     // ...       function   it_can_be_paith_with_money_and_points_and_get_no_points ( Priced   $item )       {           $this - addItem ( $item );           $this - payWithMoney ( 1000 );           $this - payWithPoints ( 10 );           $this - restToPay () - shouldBe ( 0 );           $this - getPoints () - shouldBe ( 0 );       }  }    De nuevo, ejecutamos las pruebas de  phpspec  para que se generen los m\u00e9todos necesarios en nuestra clase  Bill  y refactorizamos nuestro c\u00f3digo para pasar la prueba:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65 ?php  declare ( strict_types = 1 );  namespace   Restaurant ;  class   Bill  { \n     const   VAT   =   1.10 ; \n     private   $items ; \n     private   $amount ; \n     private   $points ; \n\n     public   function   __construct () \n     { \n         $this - items   =   [];           $this - points   =   0 ;           $this - amount   =   0 ; \n     } \n\n     public   function   getTotal () :   int \n     { \n         return   ( int )   round ( $this - totalWithoutVAT ()   *   self :: VAT ); \n     } \n\n     public   function   addItem ( Priced   $item ) :   void \n     { \n         $this - items []   =   $item ; \n     } \n\n     public   function   payWithMoney ( int   $amount ) :   void \n     { \n         $this - amount   =   $amount ; \n     } \n\n     public   function   restToPay () :   int \n     {           return   $this - getTotal ()   -   $this - amount   -   $this - getMoneyPoints ();       } \n\n     public   function   getPoints () :   int \n     { \n         if   ( $this - points     0 )   { \n             return   0 ; \n         } \n\n         return   ( int )   floor ( $this - totalWithoutVAT ()   /   100 ); \n     } \n\n     private   function   totalWithoutVAT () :   int \n     { \n         return   array_reduce ( $this - items ,   function   ( $carry ,   Priced   $priced )   { \n             return   $carry   +   $priced - price (); \n         },   0 ); \n     }       public   function   payWithPoints ( int   $points ) :   void       {           $this - points   =   $points ;       }        private   function   getMoneyPoints () :   int       {           return   100   *   ( $this - points   /   10 );       }  }    Comprobamos que pasamos las pruebas y pasamos a implementar la historia de usuario.", 
            "title": "Describir la funcionalidad"
        }, 
        {
            "location": "/second-scenario/#completando-la-historia-de-usuario", 
            "text": "Creamos el c\u00f3digo que implementa el paso que nos falta:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23 ?php  use   Behat\\Behat\\Context\\Context ;  use   Behat\\Behat\\Tester\\Exception\\PendingException ;  use   Behat\\Gherkin\\Node\\PyStringNode ;  use   Behat\\Gherkin\\Node\\TableNode ;  /**  * Defines application features from the specific context.  */  class   FeatureContext   implements   Context  { \n     // ... \n\n     /**      * @When pago con :points puntos y :money euros      */ \n     public   function   pagoConPuntosYEuros ( $points ,   $money ) \n     { \n         $this - bill - payWithMoney ( $money   *   100 ); \n         $this - bill - payWithPoints ( $points ); \n     }  }    Y ya hemos conseguido terminar otro escenario:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25 vendor/bin/behat features/menu.feature:23\nCaracter\u00edstica: Pagar un men\u00fa\n  Reglas:\n\n  -  1  punto por cada euro.\n  -  10  puntos equivalen a un descuento de  1  euros.\n  - El IVA es del  10 %\n\n  Antecedentes:                  # features/menu.feature:9 \n    Dados los siguientes men\u00fas:  # FeatureContext::losSiguientesMenus() \n       |  n\u00famero  |  precio  | \n       |   1        |   10       | \n       |   2        |   12       | \n       |   3        |   8        | \n\n  Escenario: Pagar con dinero y puntos                    # features/menu.feature:23 \n    Dado que he comprado  5  men\u00fas del n\u00famero  1              #     FeatureContext::queHeCompradoMenusDelNumero() \n    Cuando pido la cuenta recibo una factura de  55  euros  #     FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() \n    Y pago con  10  puntos y  54  euros                       #     FeatureContext::pagoConPuntosYEuros() \n    Entonces la factura est\u00e1 pagada                       #     FeatureContext::laFacturaEstaPagada() \n    Y he obtenido  0  puntos                                #     FeatureContext::heObtenidoPuntos()  1  scenario  ( 1  passed )  6  steps  ( 6  passed ) \n0m0.02s  ( 10 .09Mb )", 
            "title": "Completando la historia de usuario"
        }, 
        {
            "location": "/second-scenario/#conclusiones", 
            "text": "Como vamos viendo, el c\u00f3digo que se genera en  phpspec  es realmente el c\u00f3digo que implementa nuestras reglas de negocio. En  behat  solo implementamos c\u00f3digo para poder usar el dominio en las pruebas y comprobar que nuestras dos clases ( Menu  y  Bill ) trabajan bien juntas.", 
            "title": "Conclusiones"
        }, 
        {
            "location": "/third-scenario/", 
            "text": "Tercer escenario\n\n\nVamos a implementar el tercer escenario\n\n\n1\n2\n3\n4\n5\n6\nEscenario:\n Pagar con puntos\n\n\n    Dado \nque he comprado \n5\n men\u00fas del n\u00famero \n1\n\n\n    \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n    \nY \npago con \n500\n puntos y \n5\n euros\n\n\n    \nEntonces \nla factura est\u00e1 pagada\n\n\n    \nY \nhe obtenido \n0\n puntos\n\n\n\n\n\n\n\nSi ejecutamos la prueba:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nvendor/bin/behat features/menu.feature:30\nCaracter\u00edstica: Pagar un men\u00fa\nReglas:\n\n- \n1\n punto por cada euro.\n- \n10\n puntos equivalen a un descuento de \n1\n euros.\n- El IVA es del \n10\n%\n\nAntecedentes:                 \n# features/menu.feature:9\n\n    Dados los siguientes men\u00fas: \n# FeatureContext::losSiguientesMenus()\n\n    \n|\n n\u00famero \n|\n precio \n|\n\n    \n|\n \n1\n      \n|\n \n10\n     \n|\n\n    \n|\n \n2\n      \n|\n \n12\n     \n|\n\n    \n|\n \n3\n      \n|\n \n8\n      \n|\n\n\nEscenario: Pagar con puntos                            \n# features/menu.feature:30\n\n    Dado que he comprado \n5\n men\u00fas del n\u00famero \n1\n            \n# FeatureContext::queHeCompradoMenusDelNumero()\n\n    Cuando pido la cuenta recibo una factura de \n55\n euros \n# FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros()\n\n    Y pago con \n500\n puntos y \n5\n euros                      \n# FeatureContext::pagoConPuntosYEuros()\n\n    Entonces la factura est\u00e1 pagada                      \n# FeatureContext::laFacturaEstaPagada()\n\n    Y he obtenido \n0\n puntos                               \n# FeatureContext::heObtenidoPuntos()\n\n\n\n1\n scenario \n(\n1\n passed\n)\n\n\n6\n steps \n(\n6\n passed\n)\n\n0m0.02s \n(\n10\n.09Mb\n)\n\n\n\n\n\n\n\n\u00a1La prueba pasa! No tenemos que implementar nada nuevo. Una cuesti\u00f3n importante a la hora de escribir los pasos (\nsteps\n), es intentarlos escribir siempre de la misma manera, de tal manera que podamos reutilizarlos en sucesivas pruebas. De esta manera, en muchas ocasiones comprobaremos que no tenemos que implementar escenarios porque ya se ejecutan con los pasos definidos en los anteriores.", 
            "title": "Tercer escenario"
        }, 
        {
            "location": "/third-scenario/#tercer-escenario", 
            "text": "Vamos a implementar el tercer escenario  1\n2\n3\n4\n5\n6 Escenario:  Pagar con puntos      Dado  que he comprado  5  men\u00fas del n\u00famero  1       Cuando  pido la cuenta recibo una factura de  55  euros       Y  pago con  500  puntos y  5  euros       Entonces  la factura est\u00e1 pagada       Y  he obtenido  0  puntos    Si ejecutamos la prueba:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25 vendor/bin/behat features/menu.feature:30\nCaracter\u00edstica: Pagar un men\u00fa\nReglas:\n\n-  1  punto por cada euro.\n-  10  puntos equivalen a un descuento de  1  euros.\n- El IVA es del  10 %\n\nAntecedentes:                  # features/menu.feature:9 \n    Dados los siguientes men\u00fas:  # FeatureContext::losSiguientesMenus() \n     |  n\u00famero  |  precio  | \n     |   1        |   10       | \n     |   2        |   12       | \n     |   3        |   8        | \n\nEscenario: Pagar con puntos                             # features/menu.feature:30 \n    Dado que he comprado  5  men\u00fas del n\u00famero  1              # FeatureContext::queHeCompradoMenusDelNumero() \n    Cuando pido la cuenta recibo una factura de  55  euros  # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() \n    Y pago con  500  puntos y  5  euros                       # FeatureContext::pagoConPuntosYEuros() \n    Entonces la factura est\u00e1 pagada                       # FeatureContext::laFacturaEstaPagada() \n    Y he obtenido  0  puntos                                # FeatureContext::heObtenidoPuntos()  1  scenario  ( 1  passed )  6  steps  ( 6  passed ) \n0m0.02s  ( 10 .09Mb )    \u00a1La prueba pasa! No tenemos que implementar nada nuevo. Una cuesti\u00f3n importante a la hora de escribir los pasos ( steps ), es intentarlos escribir siempre de la misma manera, de tal manera que podamos reutilizarlos en sucesivas pruebas. De esta manera, en muchas ocasiones comprobaremos que no tenemos que implementar escenarios porque ya se ejecutan con los pasos definidos en los anteriores.", 
            "title": "Tercer escenario"
        }, 
        {
            "location": "/fourth-scenario/", 
            "text": "Cuarto escenario\n\n\nVamos a implementar el cuarto escenario\n\n\n1\n2\n3\n4\n5\nEscenario:\n Intentar pagar el IVA con puntos\n\n\n    Dado \nque he comprado \n5\n men\u00fas del n\u00famero \n1\n\n\n    \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n    \nY \npago con \n550\n puntos y \n0\n euros\n\n\n    \nEntonces \nquedan \n5\n euros por pagar\n\n\n\n\n\n\n\nSi ejecutamos la prueba:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nvendor/bin/behat features/menu.feature:37\nCaracter\u00edstica: Pagar un men\u00fa\nReglas:\n\n- \n1\n punto por cada euro.\n- \n10\n puntos equivalen a un descuento de \n1\n euros.\n- El IVA es del \n10\n%\n\nAntecedentes:                 \n# features/menu.feature:9\n\n    Dados los siguientes men\u00fas: \n# FeatureContext::losSiguientesMenus()\n\n    \n|\n n\u00famero \n|\n precio \n|\n\n    \n|\n \n1\n      \n|\n \n10\n     \n|\n\n    \n|\n \n2\n      \n|\n \n12\n     \n|\n\n    \n|\n \n3\n      \n|\n \n8\n      \n|\n\n\nEscenario: Intentar pagar el IVA con puntos            \n# features/menu.feature:37\n\n    Dado que he comprado \n5\n men\u00fas del n\u00famero \n1\n            \n# FeatureContext::queHeCompradoMenusDelNumero()\n\n    Cuando pido la cuenta recibo una factura de \n55\n euros \n# FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros()\n\n    Y pago con \n550\n puntos y \n0\n euros                      \n# FeatureContext::pagoConPuntosYEuros()\n\n    Entonces quedan \n5\n euros por pagar                    \n# FeatureContext::quedanEurosPorPagar()\n\n    TODO: write pending definition\n\n\n1\n scenario \n(\n1\n pending\n)\n\n\n5\n steps \n(\n4\n passed, \n1\n pending\n)\n\n0m0.02s \n(\n9\n.98Mb\n)\n\n\n\n\n\n\n\nEn esta ocasi\u00f3n, las funcionalidades que queremos comprobar ya las tenemos, solo que no con esas sentencias. Vamos a implementar directamente esas sentencias en el \nFeatureContext\n y ver si nuestra clase funciona:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n?php\n\n\n\nuse\n \nBehat\\Behat\\Context\\Context\n;\n\n\nuse\n \nBehat\\Behat\\Tester\\Exception\\PendingException\n;\n\n\nuse\n \nBehat\\Gherkin\\Node\\PyStringNode\n;\n\n\nuse\n \nBehat\\Gherkin\\Node\\TableNode\n;\n\n\n\n/**\n\n\n* Defines application features from the specific context.\n\n\n*/\n\n\nclass\n \nFeatureContext\n \nimplements\n \nContext\n\n\n{\n\n    \n//...\n\n\n    \n/**\n\n\n    * @Then quedan :amount euros por pagar\n\n\n    */\n\n    \npublic\n \nfunction\n \nquedanEurosPorPagar\n(\n$amount\n)\n\n    \n{\n\n\n        \n\\PHPUnit\\Framework\\Assert\n::\nassertEquals\n(\n$amount\n \n*\n \n100\n,\n \n$this\n-\nbill\n-\nrestToPay\n());\n\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nEjecutamos de nuevo la prueba:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nbash$\u00a0vendor/bin/behat features/menu.feature:37\nCaracter\u00edstica: Pagar un men\u00fa\n  Reglas:\n\n  - \n1\n punto por cada euro.\n  - \n10\n puntos equivalen a un descuento de \n1\n euros.\n  - El IVA es del \n10\n%\n\n  Antecedentes:                 \n# features/menu.feature:9\n\n    Dados los siguientes men\u00fas: \n# FeatureContext::losSiguientesMenus()\n\n      \n|\n n\u00famero \n|\n precio \n|\n\n      \n|\n \n1\n      \n|\n \n10\n     \n|\n\n      \n|\n \n2\n      \n|\n \n12\n     \n|\n\n      \n|\n \n3\n      \n|\n \n8\n      \n|\n\n\n  Escenario: Intentar pagar el IVA con puntos            \n# features/menu.feature:37\n\n    Dado que he comprado \n5\n men\u00fas del n\u00famero \n1\n            \n#     FeatureContext::queHeCompradoMenusDelNumero()\n\n    Cuando pido la cuenta recibo una factura de \n55\n euros \n#     FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros()\n\n    Y pago con \n550\n puntos y \n0\n euros                      \n#     FeatureContext::pagoConPuntosYEuros()\n\n    Entonces quedan \n5\n euros por pagar                    \n#     FeatureContext::quedanEurosPorPagar()\n\n      Failed asserting that \n0\n matches expected \n5\n.\n\n--- Failed scenarios:\n\n    features/menu.feature:37\n\n\n1\n scenario \n(\n1\n failed\n)\n\n\n5\n steps \n(\n4\n passed, \n1\n failed\n)\n\n0m0.02s \n(\n10\n.20Mb\n)\n\n\n\n\n\n\n\nEl escenario falla porque en la especificaci\u00f3n no hemos indicado que el IVA no se puede pagar con puntos. As\u00ed que creamos una nueva regla en \nBillSpec\n para tener en cuenta este comportamiento.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n?php\n\n\n\nnamespace\n \nspec\\Restaurant\n;\n\n\n\nuse\n \nRestaurant\\Bill\n;\n\n\nuse\n \nPhpSpec\\ObjectBehavior\n;\n\n\nuse\n \nProphecy\\Argument\n;\n\n\nuse\n \nRestaurant\\Priced\n;\n\n\n\nclass\n \nBillSpec\n \nextends\n \nObjectBehavior\n\n\n{\n\n    \n// ...\n\n\n\n    \nfunction\n \nit_can_not_pay_VAT_with_points\n(\nPriced\n \n$item\n)\n\n\n    \n{\n\n\n        \n$this\n-\naddItem\n(\n$item\n);\n\n\n        \n$this\n-\npayWithPoints\n(\n110\n);\n\n\n        \n$this\n-\nrestToPay\n()\n-\nshouldBe\n(\n100\n);\n\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nY modificamos nuestra clase \nBill\n para pasar la especificaci\u00f3n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n?php\n\n\ndeclare\n(\nstrict_types\n=\n1\n);\n\n\n\nnamespace\n \nRestaurant\n;\n\n\n\nclass\n \nBill\n\n\n{\n\n    \nconst\n \nVAT\n \n=\n \n1.10\n;\n\n    \nprivate\n \n$items\n;\n\n    \nprivate\n \n$amount\n;\n\n    \nprivate\n \n$points\n;\n\n\n    \npublic\n \nfunction\n \n__construct\n()\n\n    \n{\n\n        \n$this\n-\nitems\n \n=\n \n[];\n\n        \n$this\n-\npoints\n \n=\n \n0\n;\n\n        \n$this\n-\namount\n \n=\n \n0\n;\n\n    \n}\n\n\n    \npublic\n \nfunction\n \ngetTotal\n()\n:\n \nint\n\n    \n{\n\n        \nreturn\n \n(\nint\n)\n \nround\n(\n$this\n-\ntotalWithoutVAT\n()\n \n*\n \nself\n::\nVAT\n);\n\n    \n}\n\n\n    \npublic\n \nfunction\n \naddItem\n(\nPriced\n \n$item\n)\n:\n \nvoid\n\n    \n{\n\n        \n$this\n-\nitems\n[]\n \n=\n \n$item\n;\n\n    \n}\n\n\n    \npublic\n \nfunction\n \npayWithMoney\n(\nint\n \n$amount\n)\n:\n \nvoid\n\n    \n{\n\n        \n$this\n-\namount\n \n=\n \n$amount\n;\n\n    \n}\n\n\n    \npublic\n \nfunction\n \nrestToPay\n()\n:\n \nint\n\n    \n{\n\n        \nreturn\n \n$this\n-\ngetTotal\n()\n \n-\n \n$this\n-\namount\n \n-\n \n$this\n-\ngetMoneyPoints\n();\n\n    \n}\n\n\n    \npublic\n \nfunction\n \ngetPoints\n()\n:\n \nint\n\n    \n{\n\n        \nif\n \n(\n$this\n-\npoints\n \n \n0\n)\n \n{\n\n            \nreturn\n \n0\n;\n\n        \n}\n\n\n        \nreturn\n \n(\nint\n)\n \nfloor\n(\n$this\n-\ntotalWithoutVAT\n()\n \n/\n \n100\n);\n\n    \n}\n\n\n    \nprivate\n \nfunction\n \ntotalWithoutVAT\n()\n:\n \nint\n\n    \n{\n\n        \nreturn\n \narray_reduce\n(\n$this\n-\nitems\n,\n \nfunction\n \n(\n$carry\n,\n \nPriced\n \n$priced\n)\n \n{\n\n            \nreturn\n \n$carry\n \n+\n \n$priced\n-\nprice\n();\n\n        \n},\n \n0\n);\n\n    \n}\n\n\n    \npublic\n \nfunction\n \npayWithPoints\n(\nint\n \n$points\n)\n:\n \nvoid\n\n    \n{\n\n        \n$this\n-\npoints\n \n=\n \n$points\n;\n\n    \n}\n\n\n    \nprivate\n \nfunction\n \ngetMoneyPoints\n()\n:\n \nint\n\n    \n{\n\n\n        \n$maxMoneyPoints\n \n=\n \n$this\n-\ntotalWithoutVAT\n();\n\n\n        \n$moneyPoints\n \n=\n \n100\n \n*\n \n$this\n-\npoints\n \n/\n \n10\n;\n\n\n\n\n        \nreturn\n \n$moneyPoints\n \n \n$maxMoneyPoints\n \n?\n \n$maxMoneyPoints\n \n:\n \n$moneyPoints\n;\n\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nY comprobamos que esto consigue que la prueba pase:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nbash$ \u00a0vendor/bin/behat features/menu.feature:37\nCaracter\u00edstica: Pagar un men\u00fa\n  Reglas:\n\n  - \n1\n punto por cada euro.\n  - \n10\n puntos equivalen a un descuento de \n1\n euros.\n  - El IVA es del \n10\n%\n\n  Antecedentes:                 \n# features/menu.feature:9\n\n    Dados los siguientes men\u00fas: \n# FeatureContext::losSiguientesMenus()\n\n      \n|\n n\u00famero \n|\n precio \n|\n\n      \n|\n \n1\n      \n|\n \n10\n     \n|\n\n      \n|\n \n2\n      \n|\n \n12\n     \n|\n\n      \n|\n \n3\n      \n|\n \n8\n      \n|\n\n\n  Escenario: Intentar pagar el IVA con puntos            \n# features/menu.feature:37\n\n    Dado que he comprado \n5\n men\u00fas del n\u00famero \n1\n            \n#     FeatureContext::queHeCompradoMenusDelNumero()\n\n    Cuando pido la cuenta recibo una factura de \n55\n euros \n#     FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros()\n\n    Y pago con \n550\n puntos y \n0\n euros                      \n#     FeatureContext::pagoConPuntosYEuros()\n\n    Entonces quedan \n5\n euros por pagar                    \n#     FeatureContext::quedanEurosPorPagar()\n\n\n\n1\n scenario \n(\n1\n passed\n)\n\n\n5\n steps \n(\n5\n passed\n)\n\n0m0.02s \n(\n9\n.97Mb\n)", 
            "title": "Cuarto escenario"
        }, 
        {
            "location": "/fourth-scenario/#cuarto-escenario", 
            "text": "Vamos a implementar el cuarto escenario  1\n2\n3\n4\n5 Escenario:  Intentar pagar el IVA con puntos      Dado  que he comprado  5  men\u00fas del n\u00famero  1       Cuando  pido la cuenta recibo una factura de  55  euros       Y  pago con  550  puntos y  0  euros       Entonces  quedan  5  euros por pagar    Si ejecutamos la prueba:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25 vendor/bin/behat features/menu.feature:37\nCaracter\u00edstica: Pagar un men\u00fa\nReglas:\n\n-  1  punto por cada euro.\n-  10  puntos equivalen a un descuento de  1  euros.\n- El IVA es del  10 %\n\nAntecedentes:                  # features/menu.feature:9 \n    Dados los siguientes men\u00fas:  # FeatureContext::losSiguientesMenus() \n     |  n\u00famero  |  precio  | \n     |   1        |   10       | \n     |   2        |   12       | \n     |   3        |   8        | \n\nEscenario: Intentar pagar el IVA con puntos             # features/menu.feature:37 \n    Dado que he comprado  5  men\u00fas del n\u00famero  1              # FeatureContext::queHeCompradoMenusDelNumero() \n    Cuando pido la cuenta recibo una factura de  55  euros  # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() \n    Y pago con  550  puntos y  0  euros                       # FeatureContext::pagoConPuntosYEuros() \n    Entonces quedan  5  euros por pagar                     # FeatureContext::quedanEurosPorPagar() \n    TODO: write pending definition 1  scenario  ( 1  pending )  5  steps  ( 4  passed,  1  pending ) \n0m0.02s  ( 9 .98Mb )    En esta ocasi\u00f3n, las funcionalidades que queremos comprobar ya las tenemos, solo que no con esas sentencias. Vamos a implementar directamente esas sentencias en el  FeatureContext  y ver si nuestra clase funciona:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22 ?php  use   Behat\\Behat\\Context\\Context ;  use   Behat\\Behat\\Tester\\Exception\\PendingException ;  use   Behat\\Gherkin\\Node\\PyStringNode ;  use   Behat\\Gherkin\\Node\\TableNode ;  /**  * Defines application features from the specific context.  */  class   FeatureContext   implements   Context  { \n     //... \n\n     /**      * @Then quedan :amount euros por pagar      */ \n     public   function   quedanEurosPorPagar ( $amount ) \n     {           \\PHPUnit\\Framework\\Assert :: assertEquals ( $amount   *   100 ,   $this - bill - restToPay ());       }  }    Ejecutamos de nuevo la prueba:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29 bash$\u00a0vendor/bin/behat features/menu.feature:37\nCaracter\u00edstica: Pagar un men\u00fa\n  Reglas:\n\n  -  1  punto por cada euro.\n  -  10  puntos equivalen a un descuento de  1  euros.\n  - El IVA es del  10 %\n\n  Antecedentes:                  # features/menu.feature:9 \n    Dados los siguientes men\u00fas:  # FeatureContext::losSiguientesMenus() \n       |  n\u00famero  |  precio  | \n       |   1        |   10       | \n       |   2        |   12       | \n       |   3        |   8        | \n\n  Escenario: Intentar pagar el IVA con puntos             # features/menu.feature:37 \n    Dado que he comprado  5  men\u00fas del n\u00famero  1              #     FeatureContext::queHeCompradoMenusDelNumero() \n    Cuando pido la cuenta recibo una factura de  55  euros  #     FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() \n    Y pago con  550  puntos y  0  euros                       #     FeatureContext::pagoConPuntosYEuros() \n    Entonces quedan  5  euros por pagar                     #     FeatureContext::quedanEurosPorPagar() \n      Failed asserting that  0  matches expected  5 .\n\n--- Failed scenarios:\n\n    features/menu.feature:37 1  scenario  ( 1  failed )  5  steps  ( 4  passed,  1  failed ) \n0m0.02s  ( 10 .20Mb )    El escenario falla porque en la especificaci\u00f3n no hemos indicado que el IVA no se puede pagar con puntos. As\u00ed que creamos una nueva regla en  BillSpec  para tener en cuenta este comportamiento.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20 ?php  namespace   spec\\Restaurant ;  use   Restaurant\\Bill ;  use   PhpSpec\\ObjectBehavior ;  use   Prophecy\\Argument ;  use   Restaurant\\Priced ;  class   BillSpec   extends   ObjectBehavior  { \n     // ...       function   it_can_not_pay_VAT_with_points ( Priced   $item )       {           $this - addItem ( $item );           $this - payWithPoints ( 110 );           $this - restToPay () - shouldBe ( 100 );       }  }    Y modificamos nuestra clase  Bill  para pasar la especificaci\u00f3n:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68 ?php  declare ( strict_types = 1 );  namespace   Restaurant ;  class   Bill  { \n     const   VAT   =   1.10 ; \n     private   $items ; \n     private   $amount ; \n     private   $points ; \n\n     public   function   __construct () \n     { \n         $this - items   =   []; \n         $this - points   =   0 ; \n         $this - amount   =   0 ; \n     } \n\n     public   function   getTotal () :   int \n     { \n         return   ( int )   round ( $this - totalWithoutVAT ()   *   self :: VAT ); \n     } \n\n     public   function   addItem ( Priced   $item ) :   void \n     { \n         $this - items []   =   $item ; \n     } \n\n     public   function   payWithMoney ( int   $amount ) :   void \n     { \n         $this - amount   =   $amount ; \n     } \n\n     public   function   restToPay () :   int \n     { \n         return   $this - getTotal ()   -   $this - amount   -   $this - getMoneyPoints (); \n     } \n\n     public   function   getPoints () :   int \n     { \n         if   ( $this - points     0 )   { \n             return   0 ; \n         } \n\n         return   ( int )   floor ( $this - totalWithoutVAT ()   /   100 ); \n     } \n\n     private   function   totalWithoutVAT () :   int \n     { \n         return   array_reduce ( $this - items ,   function   ( $carry ,   Priced   $priced )   { \n             return   $carry   +   $priced - price (); \n         },   0 ); \n     } \n\n     public   function   payWithPoints ( int   $points ) :   void \n     { \n         $this - points   =   $points ; \n     } \n\n     private   function   getMoneyPoints () :   int \n     {           $maxMoneyPoints   =   $this - totalWithoutVAT ();           $moneyPoints   =   100   *   $this - points   /   10 ;            return   $moneyPoints     $maxMoneyPoints   ?   $maxMoneyPoints   :   $moneyPoints ;       }  }    Y comprobamos que esto consigue que la prueba pase:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24 bash$ \u00a0vendor/bin/behat features/menu.feature:37\nCaracter\u00edstica: Pagar un men\u00fa\n  Reglas:\n\n  -  1  punto por cada euro.\n  -  10  puntos equivalen a un descuento de  1  euros.\n  - El IVA es del  10 %\n\n  Antecedentes:                  # features/menu.feature:9 \n    Dados los siguientes men\u00fas:  # FeatureContext::losSiguientesMenus() \n       |  n\u00famero  |  precio  | \n       |   1        |   10       | \n       |   2        |   12       | \n       |   3        |   8        | \n\n  Escenario: Intentar pagar el IVA con puntos             # features/menu.feature:37 \n    Dado que he comprado  5  men\u00fas del n\u00famero  1              #     FeatureContext::queHeCompradoMenusDelNumero() \n    Cuando pido la cuenta recibo una factura de  55  euros  #     FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() \n    Y pago con  550  puntos y  0  euros                       #     FeatureContext::pagoConPuntosYEuros() \n    Entonces quedan  5  euros por pagar                     #     FeatureContext::quedanEurosPorPagar()  1  scenario  ( 1  passed )  5  steps  ( 5  passed ) \n0m0.02s  ( 9 .97Mb )", 
            "title": "Cuarto escenario"
        }, 
        {
            "location": "/fifth-scenario/", 
            "text": "Quinto escenario\n\n\nVamos a implementar el \u00faltimo escenario\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nEscenario:\n Comprar men\u00fas de varios tipos\n\n\n    Dado \nque he comprado \n1\n men\u00fa del n\u00famero \n1\n\n\n    \nY \nque he comprado \n2\n men\u00fas del n\u00famero \n2\n\n\n    \nY \nque he comprado \n2\n men\u00fas del n\u00famero \n3\n\n\n    \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n    \nY \npago en efectivo con \n55\n euros\n\n\n    \nEntonces \nla factura est\u00e1 pagada\n\n\n    \nY \nhe obtenido \n50\n puntos\n\n\n\n\n\n\n\nSi ejecutamos la prueba:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nbash$ \u00a0vendor/bin/behat features/menu.feature:43\nCaracter\u00edstica: Pagar un men\u00fa\n  Reglas:\n\n  - \n1\n punto por cada euro.\n  - \n10\n puntos equivalen a un descuento de \n1\n euros.\n  - El IVA es del \n10\n%\n\n  Antecedentes:                 \n# features/menu.feature:9\n\n    Dados los siguientes men\u00fas: \n# FeatureContext::losSiguientesMenus()\n\n      \n|\n n\u00famero \n|\n precio \n|\n\n      \n|\n \n1\n      \n|\n \n10\n     \n|\n\n      \n|\n \n2\n      \n|\n \n12\n     \n|\n\n      \n|\n \n3\n      \n|\n \n8\n      \n|\n\n\n  Escenario: Comprar men\u00fas de varios tipos               \n# features/menu.feature:43\n\n    Dado que he comprado \n1\n men\u00fa del n\u00famero \n1\n             \n#     FeatureContext::queHeCompradoMenuDelNumero()\n\n      TODO: write pending definition\n    Y que he comprado \n2\n men\u00fas del n\u00famero \n2\n               \n#     FeatureContext::queHeCompradoMenusDelNumero()\n\n    Y que he comprado \n2\n men\u00fas del n\u00famero \n3\n               \n#     FeatureContext::queHeCompradoMenusDelNumero()\n\n    Cuando pido la cuenta recibo una factura de \n55\n euros \n#     FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros()\n\n    Y pago en efectivo con \n55\n euros                      \n#     FeatureContext::pagoEnEfectivoConEuros()\n\n    Entonces la factura est\u00e1 pagada                      \n#     FeatureContext::laFacturaEstaPagada()\n\n    Y he obtenido \n50\n puntos                              \n#     FeatureContext::heObtenidoPuntos()\n\n\n\n1\n scenario \n(\n1\n pending\n)\n\n\n8\n steps \n(\n1\n passed, \n1\n pending, \n6\n skipped\n)\n\n0m0.02s \n(\n9\n.65Mb\n)\n\n\n\n\n\n\n\nFalla en el primer paso. Realmente la frase \"que he comprado 1 men\u00fa del n\u00famero 1\" difiere de \"que he comprado 2 men\u00fas del n\u00famero 2\" en el plural de \nmen\u00fas\n. Al ser frases distintas behat las interpreta como pasos distintos. Tenemos varias formas de solucionar esto que no pasen por escribir dos veces el mismo c\u00f3digo, es decir, conseguir que un mismo paso se ejecute con sentencias distintas.\n\n\nPor lo pronto el c\u00f3digo siguiente:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n?php\n\n\n\n/**\n\n\n * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2\n\n\n */\n\n\npublic\n \nfunction\n \nqueHeCompradoMenuDelNumero\n(\n$arg1\n,\n \n$arg2\n)\n\n\n{\n\n    \nthrow\n \nnew\n \nPendingException\n();\n\n\n}\n\n\n\n\n\n\n\nQue pertenece a nuestro \nFeatureContext.php\n sobra y lo eliminamos.\n\n\nPrimer m\u00e9todo: Escribir varias sentencias @Given\n\n\nUna posible soluci\u00f3n es a\u00f1adir a la cabecera del \nstep\n todas las anotaciones que queramos que lo activen:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n?php\n\n\n\n/**\n\n\n * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2\n\n\n * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2\n\n\n */\n\n\npublic\n \nfunction\n \nqueHeCompradoMenusDelNumero\n(\n$count\n,\n \n$menuNumber\n)\n\n\n{\n\n    \n$menu\n \n=\n \n$this\n-\nmenus\n[\n$menuNumber\n];\n\n\n    \nfor\n(\n$i\n \n=\n \n0\n;\n \n$i\n \n \n$count\n;\n \n$i\n++\n)\n \n{\n\n        \n$this\n-\nbill\n-\naddItem\n(\n$menu\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nSegundo m\u00e9todo: Escribir las reglas como expresiones regulares\n\n\nPodemos usar expresiones regulares:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n?php\n\n\n\n/**\n\n\n * @Given /^que he comprado (\\d+) men\u00fas? del n\u00famero (\\d+)$/\n\n\n */\n\n\npublic\n \nfunction\n \nqueHeCompradoMenusDelNumero\n(\n$count\n,\n \n$menuNumber\n)\n\n\n{\n\n    \n$menu\n \n=\n \n$this\n-\nmenus\n[\n$menuNumber\n];\n\n\n    \nfor\n(\n$i\n \n=\n \n0\n;\n \n$i\n \n \n$count\n;\n \n$i\n++\n)\n \n{\n\n        \n$this\n-\nbill\n-\naddItem\n(\n$menu\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nEn el caso de usar expresiones regulares, debemos usar grupos de captura (el contenido entre par\u00e9ntesis) de aquellos valores que queramos pasar a la funci\u00f3n.\n\n\nEstado final\n\n\nVamos a poner el c\u00f3digo del \nFeatureContext\n usando el primer m\u00e9todo:\n\n\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n?php\n\n\n\nuse\n \nBehat\\Behat\\Context\\Context\n;\n\n\nuse\n \nBehat\\Behat\\Tester\\Exception\\PendingException\n;\n\n\nuse\n \nBehat\\Gherkin\\Node\\PyStringNode\n;\n\n\nuse\n \nBehat\\Gherkin\\Node\\TableNode\n;\n\n\n\n/**\n\n\n* Defines application features from the specific context.\n\n\n*/\n\n\nclass\n \nFeatureContext\n \nimplements\n \nContext\n\n\n{\n\n    \nprivate\n \n$menus\n;\n\n    \nprivate\n \n$bill\n;\n\n\n    \n/**\n\n\n    * Initializes context.\n\n\n    *\n\n\n    * Every scenario gets its own context instance.\n\n\n    * You can also pass arbitrary arguments to the\n\n\n    * context constructor through behat.yml.\n\n\n    */\n\n    \npublic\n \nfunction\n \n__construct\n()\n\n    \n{\n\n        \n$this\n-\nmenus\n \n=\n \n[];\n\n        \n$this\n-\nbill\n \n=\n \nnew\n \n\\Restaurant\\Bill\n();\n\n    \n}\n\n\n    \n/**\n\n\n    * @Given los siguientes men\u00fas:\n\n\n    */\n\n    \npublic\n \nfunction\n \nlosSiguientesMenus\n(\nTableNode\n \n$table\n)\n\n    \n{\n\n        \nforeach\n \n(\n$table\n-\ngetHash\n()\n \nas\n \n$menu\n)\n \n{\n\n            \n$this\n-\nmenus\n[\n$menu\n[\nn\u00famero\n]]\n \n=\n \nnew\n \n\\Restaurant\\Menu\n(\n$menu\n[\nn\u00famero\n],\n \n$menu\n[\nprecio\n]\n \n*\n \n100\n);\n\n        \n}\n\n    \n}\n\n\n    \n/**\n\n\n    * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2\n\n\n    * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2\n\n\n    */\n\n    \npublic\n \nfunction\n \nqueHeCompradoMenusDelNumero\n(\n$count\n,\n \n$menuNumber\n)\n\n    \n{\n\n        \n$menu\n \n=\n \n$this\n-\nmenus\n[\n$menuNumber\n];\n\n\n        \nfor\n(\n$i\n \n=\n \n0\n;\n \n$i\n \n \n$count\n;\n \n$i\n++\n)\n \n{\n\n            \n$this\n-\nbill\n-\naddItem\n(\n$menu\n);\n\n        \n}\n\n    \n}\n\n\n    \n/**\n\n\n    * @When pido la cuenta recibo una factura de :arg1 euros\n\n\n    */\n\n    \npublic\n \nfunction\n \npidoLaCuentaReciboUnaFacturaDeEuros\n(\n$total\n)\n\n    \n{\n\n        \n\\PHPUnit\\Framework\\Assert\n::\nassertEquals\n(\n$total\n \n*\n \n100\n,\n \n$this\n-\nbill\n-\ngetTotal\n());\n\n    \n}\n\n\n    \n/**\n\n\n    * @When pago en efectivo con :arg1 euros\n\n\n    */\n\n    \npublic\n \nfunction\n \npagoEnEfectivoConEuros\n(\n$amount\n)\n\n    \n{\n\n        \n$this\n-\nbill\n-\npayWithMoney\n(\n$amount\n \n*\n \n100\n);\n\n    \n}\n\n\n    \n/**\n\n\n    * @Then la factura est\u00e1 pagada\n\n\n    */\n\n    \npublic\n \nfunction\n \nlaFacturaEstaPagada\n()\n\n    \n{\n\n        \n\\PHPUnit\\Framework\\Assert\n::\nassertEquals\n(\n0\n,\n \n$this\n-\nbill\n-\nrestToPay\n());\n\n    \n}\n\n\n    \n/**\n\n\n    * @Then he obtenido :arg1 puntos\n\n\n    */\n\n    \npublic\n \nfunction\n \nheObtenidoPuntos\n(\n$points\n)\n\n    \n{\n\n        \n\\PHPUnit\\Framework\\Assert\n::\nassertEquals\n(\n$points\n,\n \n$this\n-\nbill\n-\ngetPoints\n());\n\n    \n}\n\n\n    \n/**\n\n\n    * @When pago con :points puntos y :money euros\n\n\n    */\n\n    \npublic\n \nfunction\n \npagoConPuntosYEuros\n(\n$points\n,\n \n$money\n)\n\n    \n{\n\n        \n$this\n-\nbill\n-\npayWithMoney\n(\n$money\n \n*\n \n100\n);\n\n        \n$this\n-\nbill\n-\npayWithPoints\n(\n$points\n);\n\n    \n}\n\n\n    \n/**\n\n\n    * @Then quedan :amount euros por pagar\n\n\n    */\n\n    \npublic\n \nfunction\n \nquedanEurosPorPagar\n(\n$amount\n)\n\n    \n{\n\n        \n\\PHPUnit\\Framework\\Assert\n::\nassertEquals\n(\n$amount\n \n*\n \n100\n,\n \n$this\n-\nbill\n-\nrestToPay\n());\n\n    \n}\n#\n\n\n}\n\n\n\n\n\n\n\nY ejecutamos, ahora s\u00ed, todas las pruebas:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\nbash$\u00a0vendor/bin/behat features/menu.feature\nCaracter\u00edstica: Pagar un men\u00fa\n  Reglas:\n\n  - \n1\n punto por cada euro.\n  - \n10\n puntos equivalen a un descuento de \n1\n euros.\n  - El IVA es del \n10\n%\n\n  Antecedentes:                 \n# features/menu.feature:9\n\n    Dados los siguientes men\u00fas: \n# FeatureContext::losSiguientesMenus()\n\n      \n|\n n\u00famero \n|\n precio \n|\n\n      \n|\n \n1\n      \n|\n \n10\n     \n|\n\n      \n|\n \n2\n      \n|\n \n12\n     \n|\n\n      \n|\n \n3\n      \n|\n \n8\n      \n|\n\n\n  Escenario: Ganar puntos al pagar en efectivo           \n# features/menu.feature:16\n\n    Dado que he comprado \n5\n men\u00fas del n\u00famero \n1\n            \n#     FeatureContext::queHeCompradoMenusDelNumero()\n\n    Cuando pido la cuenta recibo una factura de \n55\n euros \n#     FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros()\n\n    Y pago en efectivo con \n55\n euros                      \n#     FeatureContext::pagoEnEfectivoConEuros()\n\n    Entonces la factura est\u00e1 pagada                      \n#     FeatureContext::laFacturaEstaPagada()\n\n    Y he obtenido \n50\n puntos                              \n#     FeatureContext::heObtenidoPuntos()\n\n\n  Escenario: Pagar con dinero y puntos                   \n# features/menu.feature:23\n\n    Dado que he comprado \n5\n men\u00fas del n\u00famero \n1\n            \n#     FeatureContext::queHeCompradoMenusDelNumero()\n\n    Cuando pido la cuenta recibo una factura de \n55\n euros \n#     FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros()\n\n    Y pago con \n10\n puntos y \n54\n euros                      \n#     FeatureContext::pagoConPuntosYEuros()\n\n    Entonces la factura est\u00e1 pagada                      \n#     FeatureContext::laFacturaEstaPagada()\n\n    Y he obtenido \n0\n puntos                               \n#     FeatureContext::heObtenidoPuntos()\n\n\n  Escenario: Pagar con puntos                            \n# features/menu.feature:30\n\n    Dado que he comprado \n5\n men\u00fas del n\u00famero \n1\n            \n#     FeatureContext::queHeCompradoMenusDelNumero()\n\n    Cuando pido la cuenta recibo una factura de \n55\n euros \n#     FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros()\n\n    Y pago con \n500\n puntos y \n5\n euros                      \n#     FeatureContext::pagoConPuntosYEuros()\n\n    Entonces la factura est\u00e1 pagada                      \n#     FeatureContext::laFacturaEstaPagada()\n\n    Y he obtenido \n0\n puntos                               \n#     FeatureContext::heObtenidoPuntos()\n\n\n  Escenario: Intentar pagar el IVA con puntos            \n# features/menu.feature:37\n\n    Dado que he comprado \n5\n men\u00fas del n\u00famero \n1\n            \n#     FeatureContext::queHeCompradoMenusDelNumero()\n\n    Cuando pido la cuenta recibo una factura de \n55\n euros \n#     FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros()\n\n    Y pago con \n550\n puntos y \n0\n euros                      \n#     FeatureContext::pagoConPuntosYEuros()\n\n    Entonces quedan \n5\n euros por pagar                    \n#     FeatureContext::quedanEurosPorPagar()\n\n\n  Escenario: Comprar men\u00fas de varios tipos               \n# features/menu.feature:43\n\n    Dado que he comprado \n1\n men\u00fa del n\u00famero \n1\n             \n#     FeatureContext::queHeCompradoMenusDelNumero()\n\n    Y que he comprado \n2\n men\u00fas del n\u00famero \n2\n               \n#     FeatureContext::queHeCompradoMenusDelNumero()\n\n    Y que he comprado \n2\n men\u00fas del n\u00famero \n3\n               \n#     FeatureContext::queHeCompradoMenusDelNumero()\n\n    Cuando pido la cuenta recibo una factura de \n55\n euros \n#     FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros()\n\n    Y pago en efectivo con \n55\n euros                      \n#     FeatureContext::pagoEnEfectivoConEuros()\n\n    Entonces la factura est\u00e1 pagada                      \n#     FeatureContext::laFacturaEstaPagada()\n\n    Y he obtenido \n50\n puntos                              \n#     FeatureContext::heObtenidoPuntos()\n\n\n\n5\n scenarios \n(\n5\n passed\n)\n\n\n31\n steps \n(\n31\n passed\n)\n\n0m0.04s \n(\n10\n.07Mb\n)\n\n\n\n\n\n\n\nPodemos comprobar que hemos conseguido pasar todas las pruebas y nuestra aplicaci\u00f3n cumplir\u00eda todas las especificaciones.", 
            "title": "Quinto escenario"
        }, 
        {
            "location": "/fifth-scenario/#quinto-escenario", 
            "text": "Vamos a implementar el \u00faltimo escenario  1\n2\n3\n4\n5\n6\n7\n8 Escenario:  Comprar men\u00fas de varios tipos      Dado  que he comprado  1  men\u00fa del n\u00famero  1       Y  que he comprado  2  men\u00fas del n\u00famero  2       Y  que he comprado  2  men\u00fas del n\u00famero  3       Cuando  pido la cuenta recibo una factura de  55  euros       Y  pago en efectivo con  55  euros       Entonces  la factura est\u00e1 pagada       Y  he obtenido  50  puntos    Si ejecutamos la prueba:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28 bash$ \u00a0vendor/bin/behat features/menu.feature:43\nCaracter\u00edstica: Pagar un men\u00fa\n  Reglas:\n\n  -  1  punto por cada euro.\n  -  10  puntos equivalen a un descuento de  1  euros.\n  - El IVA es del  10 %\n\n  Antecedentes:                  # features/menu.feature:9 \n    Dados los siguientes men\u00fas:  # FeatureContext::losSiguientesMenus() \n       |  n\u00famero  |  precio  | \n       |   1        |   10       | \n       |   2        |   12       | \n       |   3        |   8        | \n\n  Escenario: Comprar men\u00fas de varios tipos                # features/menu.feature:43 \n    Dado que he comprado  1  men\u00fa del n\u00famero  1               #     FeatureContext::queHeCompradoMenuDelNumero() \n      TODO: write pending definition\n    Y que he comprado  2  men\u00fas del n\u00famero  2                 #     FeatureContext::queHeCompradoMenusDelNumero() \n    Y que he comprado  2  men\u00fas del n\u00famero  3                 #     FeatureContext::queHeCompradoMenusDelNumero() \n    Cuando pido la cuenta recibo una factura de  55  euros  #     FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() \n    Y pago en efectivo con  55  euros                       #     FeatureContext::pagoEnEfectivoConEuros() \n    Entonces la factura est\u00e1 pagada                       #     FeatureContext::laFacturaEstaPagada() \n    Y he obtenido  50  puntos                               #     FeatureContext::heObtenidoPuntos()  1  scenario  ( 1  pending )  8  steps  ( 1  passed,  1  pending,  6  skipped ) \n0m0.02s  ( 9 .65Mb )    Falla en el primer paso. Realmente la frase \"que he comprado 1 men\u00fa del n\u00famero 1\" difiere de \"que he comprado 2 men\u00fas del n\u00famero 2\" en el plural de  men\u00fas . Al ser frases distintas behat las interpreta como pasos distintos. Tenemos varias formas de solucionar esto que no pasen por escribir dos veces el mismo c\u00f3digo, es decir, conseguir que un mismo paso se ejecute con sentencias distintas.  Por lo pronto el c\u00f3digo siguiente:  1\n2\n3\n4\n5\n6\n7\n8\n9 ?php  /**   * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2   */  public   function   queHeCompradoMenuDelNumero ( $arg1 ,   $arg2 )  { \n     throw   new   PendingException ();  }    Que pertenece a nuestro  FeatureContext.php  sobra y lo eliminamos.", 
            "title": "Quinto escenario"
        }, 
        {
            "location": "/fifth-scenario/#primer-metodo-escribir-varias-sentencias-given", 
            "text": "Una posible soluci\u00f3n es a\u00f1adir a la cabecera del  step  todas las anotaciones que queramos que lo activen:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 ?php  /**   * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2   * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2   */  public   function   queHeCompradoMenusDelNumero ( $count ,   $menuNumber )  { \n     $menu   =   $this - menus [ $menuNumber ]; \n\n     for ( $i   =   0 ;   $i     $count ;   $i ++ )   { \n         $this - bill - addItem ( $menu ); \n     }  }", 
            "title": "Primer m\u00e9todo: Escribir varias sentencias @Given"
        }, 
        {
            "location": "/fifth-scenario/#segundo-metodo-escribir-las-reglas-como-expresiones-regulares", 
            "text": "Podemos usar expresiones regulares:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 ?php  /**   * @Given /^que he comprado (\\d+) men\u00fas? del n\u00famero (\\d+)$/   */  public   function   queHeCompradoMenusDelNumero ( $count ,   $menuNumber )  { \n     $menu   =   $this - menus [ $menuNumber ]; \n\n     for ( $i   =   0 ;   $i     $count ;   $i ++ )   { \n         $this - bill - addItem ( $menu ); \n     }  }    En el caso de usar expresiones regulares, debemos usar grupos de captura (el contenido entre par\u00e9ntesis) de aquellos valores que queramos pasar a la funci\u00f3n.", 
            "title": "Segundo m\u00e9todo: Escribir las reglas como expresiones regulares"
        }, 
        {
            "location": "/fifth-scenario/#estado-final", 
            "text": "Vamos a poner el c\u00f3digo del  FeatureContext  usando el primer m\u00e9todo:    1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100 ?php  use   Behat\\Behat\\Context\\Context ;  use   Behat\\Behat\\Tester\\Exception\\PendingException ;  use   Behat\\Gherkin\\Node\\PyStringNode ;  use   Behat\\Gherkin\\Node\\TableNode ;  /**  * Defines application features from the specific context.  */  class   FeatureContext   implements   Context  { \n     private   $menus ; \n     private   $bill ; \n\n     /**      * Initializes context.      *      * Every scenario gets its own context instance.      * You can also pass arbitrary arguments to the      * context constructor through behat.yml.      */ \n     public   function   __construct () \n     { \n         $this - menus   =   []; \n         $this - bill   =   new   \\Restaurant\\Bill (); \n     } \n\n     /**      * @Given los siguientes men\u00fas:      */ \n     public   function   losSiguientesMenus ( TableNode   $table ) \n     { \n         foreach   ( $table - getHash ()   as   $menu )   { \n             $this - menus [ $menu [ n\u00famero ]]   =   new   \\Restaurant\\Menu ( $menu [ n\u00famero ],   $menu [ precio ]   *   100 ); \n         } \n     } \n\n     /**      * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2      * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2      */ \n     public   function   queHeCompradoMenusDelNumero ( $count ,   $menuNumber ) \n     { \n         $menu   =   $this - menus [ $menuNumber ]; \n\n         for ( $i   =   0 ;   $i     $count ;   $i ++ )   { \n             $this - bill - addItem ( $menu ); \n         } \n     } \n\n     /**      * @When pido la cuenta recibo una factura de :arg1 euros      */ \n     public   function   pidoLaCuentaReciboUnaFacturaDeEuros ( $total ) \n     { \n         \\PHPUnit\\Framework\\Assert :: assertEquals ( $total   *   100 ,   $this - bill - getTotal ()); \n     } \n\n     /**      * @When pago en efectivo con :arg1 euros      */ \n     public   function   pagoEnEfectivoConEuros ( $amount ) \n     { \n         $this - bill - payWithMoney ( $amount   *   100 ); \n     } \n\n     /**      * @Then la factura est\u00e1 pagada      */ \n     public   function   laFacturaEstaPagada () \n     { \n         \\PHPUnit\\Framework\\Assert :: assertEquals ( 0 ,   $this - bill - restToPay ()); \n     } \n\n     /**      * @Then he obtenido :arg1 puntos      */ \n     public   function   heObtenidoPuntos ( $points ) \n     { \n         \\PHPUnit\\Framework\\Assert :: assertEquals ( $points ,   $this - bill - getPoints ()); \n     } \n\n     /**      * @When pago con :points puntos y :money euros      */ \n     public   function   pagoConPuntosYEuros ( $points ,   $money ) \n     { \n         $this - bill - payWithMoney ( $money   *   100 ); \n         $this - bill - payWithPoints ( $points ); \n     } \n\n     /**      * @Then quedan :amount euros por pagar      */ \n     public   function   quedanEurosPorPagar ( $amount ) \n     { \n         \\PHPUnit\\Framework\\Assert :: assertEquals ( $amount   *   100 ,   $this - bill - restToPay ()); \n     } #  }    Y ejecutamos, ahora s\u00ed, todas las pruebas:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54 bash$\u00a0vendor/bin/behat features/menu.feature\nCaracter\u00edstica: Pagar un men\u00fa\n  Reglas:\n\n  -  1  punto por cada euro.\n  -  10  puntos equivalen a un descuento de  1  euros.\n  - El IVA es del  10 %\n\n  Antecedentes:                  # features/menu.feature:9 \n    Dados los siguientes men\u00fas:  # FeatureContext::losSiguientesMenus() \n       |  n\u00famero  |  precio  | \n       |   1        |   10       | \n       |   2        |   12       | \n       |   3        |   8        | \n\n  Escenario: Ganar puntos al pagar en efectivo            # features/menu.feature:16 \n    Dado que he comprado  5  men\u00fas del n\u00famero  1              #     FeatureContext::queHeCompradoMenusDelNumero() \n    Cuando pido la cuenta recibo una factura de  55  euros  #     FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() \n    Y pago en efectivo con  55  euros                       #     FeatureContext::pagoEnEfectivoConEuros() \n    Entonces la factura est\u00e1 pagada                       #     FeatureContext::laFacturaEstaPagada() \n    Y he obtenido  50  puntos                               #     FeatureContext::heObtenidoPuntos() \n\n  Escenario: Pagar con dinero y puntos                    # features/menu.feature:23 \n    Dado que he comprado  5  men\u00fas del n\u00famero  1              #     FeatureContext::queHeCompradoMenusDelNumero() \n    Cuando pido la cuenta recibo una factura de  55  euros  #     FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() \n    Y pago con  10  puntos y  54  euros                       #     FeatureContext::pagoConPuntosYEuros() \n    Entonces la factura est\u00e1 pagada                       #     FeatureContext::laFacturaEstaPagada() \n    Y he obtenido  0  puntos                                #     FeatureContext::heObtenidoPuntos() \n\n  Escenario: Pagar con puntos                             # features/menu.feature:30 \n    Dado que he comprado  5  men\u00fas del n\u00famero  1              #     FeatureContext::queHeCompradoMenusDelNumero() \n    Cuando pido la cuenta recibo una factura de  55  euros  #     FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() \n    Y pago con  500  puntos y  5  euros                       #     FeatureContext::pagoConPuntosYEuros() \n    Entonces la factura est\u00e1 pagada                       #     FeatureContext::laFacturaEstaPagada() \n    Y he obtenido  0  puntos                                #     FeatureContext::heObtenidoPuntos() \n\n  Escenario: Intentar pagar el IVA con puntos             # features/menu.feature:37 \n    Dado que he comprado  5  men\u00fas del n\u00famero  1              #     FeatureContext::queHeCompradoMenusDelNumero() \n    Cuando pido la cuenta recibo una factura de  55  euros  #     FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() \n    Y pago con  550  puntos y  0  euros                       #     FeatureContext::pagoConPuntosYEuros() \n    Entonces quedan  5  euros por pagar                     #     FeatureContext::quedanEurosPorPagar() \n\n  Escenario: Comprar men\u00fas de varios tipos                # features/menu.feature:43 \n    Dado que he comprado  1  men\u00fa del n\u00famero  1               #     FeatureContext::queHeCompradoMenusDelNumero() \n    Y que he comprado  2  men\u00fas del n\u00famero  2                 #     FeatureContext::queHeCompradoMenusDelNumero() \n    Y que he comprado  2  men\u00fas del n\u00famero  3                 #     FeatureContext::queHeCompradoMenusDelNumero() \n    Cuando pido la cuenta recibo una factura de  55  euros  #     FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() \n    Y pago en efectivo con  55  euros                       #     FeatureContext::pagoEnEfectivoConEuros() \n    Entonces la factura est\u00e1 pagada                       #     FeatureContext::laFacturaEstaPagada() \n    Y he obtenido  50  puntos                               #     FeatureContext::heObtenidoPuntos()  5  scenarios  ( 5  passed )  31  steps  ( 31  passed ) \n0m0.04s  ( 10 .07Mb )    Podemos comprobar que hemos conseguido pasar todas las pruebas y nuestra aplicaci\u00f3n cumplir\u00eda todas las especificaciones.", 
            "title": "Estado final"
        }
    ]
}