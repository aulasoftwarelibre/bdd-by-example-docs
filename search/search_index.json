{
    "docs": [
        {
            "location": "/", 
            "text": "BDD by example\n\n\n\n\nEste taller forma parte de las actividades del \nAula de Software Libre de la\nUniversidad de C\u00f3rdoba\n.\n\n\nEl material de esta documentaci\u00f3n est\u00e1 sacado de las presentaciones de \nhttps://es.slideshare.net/CiaranMcNulty\n:\n\n\n\n\nTDD with PhpSpec\n\n\nDriving Design through Examples", 
            "title": "Inicio"
        }, 
        {
            "location": "/#bdd-by-example", 
            "text": "Este taller forma parte de las actividades del  Aula de Software Libre de la\nUniversidad de C\u00f3rdoba .  El material de esta documentaci\u00f3n est\u00e1 sacado de las presentaciones de  https://es.slideshare.net/CiaranMcNulty :   TDD with PhpSpec  Driving Design through Examples", 
            "title": "BDD by example"
        }, 
        {
            "location": "/introduction/", 
            "text": "Introducci\u00f3n\n\n\nDesarrollo orientado a pruebas (TDD)\n\n\nTest Driven Development (TDD), o desarrollo orientado a pruebas, es un proceso de desarrollo de software muy conocido, que consiste en la repetici\u00f3n de ciclos de desarrollo muy cortos.\n\n\n\n\nLos requisitos se convierten en pruebas, unidades de c\u00f3digo que prueban una determinada funcionalidad.\n\n\nEntonces, se produce el c\u00f3digo justo que permite pasar dicha prueba.\n\n\n\n\nEste proceso es opuesto a otros sistemas de desarrollo que permiten incorporar c\u00f3digo que no se sabe con certeza si concuerdan o no con los requisitos.\n\n\nLos test que se pueden realizar pueden ser de unidad, funcionales y de aceptaci\u00f3n. Para todos estos tipos de test, en PHP podemos usar PHPUnit.\n\n\nCiclo del desarrollo orientado a pruebas\n\n\n\n\nA\u00f1ade un test\n\n\nEjecuta los test y comprueba que el nuevo test falla\n\n\nEscribe el c\u00f3digo\n\n\nEjecuta los test\n\n\nRefactoriza el c\u00f3digo\n\n\nRepite\n\n\n\n\nEjemplo de un test de unidad con PHPUnit\n\n\nSi queremos implementar una clase que implemente funciones matem\u00e1ticas, este ser\u00eda el c\u00f3digo de una prueba unitaria que, con PHPUnit, escribir\u00edamos para implementar la funcionalidad \nsuma\n:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n?php\n\n\nuse\n \nPHPUnit\\Framework\\TestCase\n;\n\n\n\nclass\n \nCalculatorTest\n \nextends\n \nTestCase\n\n\n{\n\n    \npublic\n \nfunction\n \ntestAdd\n()\n\n    \n{\n\n        \n$calculator\n \n=\n \nnew\n \nCalculator\n();\n\n        \n$result\n \n=\n \n$calculator\n-\nadd\n(\n3\n,\n \n2\n);\n\n\n        \n$this\n-\nassertEquals\n(\n5\n,\n \n$result\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nSolo cuando tengamos el test escrito podremos desarrollar el c\u00f3digo:\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n?php\n\n\nclass\n \nCalculator\n\n\n{\n\n    \npublic\n \nfunction\n \nadd\n \n(\nint\n \n$a\n,\n \nint\n \n$b\n)\n:\n \nint\n\n    \n{\n\n        \nreturn\n \n$a\n \n+\n \n$b\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nLas tres reglas\n\n\nRobert Martin, en su libro \"Clean Code. A Handbook of agile software craftsmanship\", especifica las tres reglas que deben seguirse cuando se desarrolla con TDD:\n\n\n\n\nNo debes escribir c\u00f3digo de producci\u00f3n hasta que hayas escrito una prueba unitaria que falle.\n\n\nNo debes escribir m\u00e1s de una prueba unitaria que sea suficiente para fallar y el sistema no compile.\n\n\nNo debes escribir m\u00e1s c\u00f3digo de producci\u00f3n que el suficiente para superar la prueba que est\u00e9 fallando actualmente.\n\n\n\n\nDesarrollo orientado a comportamiento (BDD)\n\n\nBehaviour Driven Development (BDD), o desarrollo orientado a comportamiento, es un proceso de desarrollo similar a TDD, solo que con BDD lo que se realiza es definir el comportamiento y las especificaciones, al contrario que con TDD que se limita solamente a comprobar funcionalidades.\n\n\nLos test que se pueden realizar pueden ser de unidad, funcionales y de aceptaci\u00f3n. Para los test de unidad el software m\u00e1s apropiado en PhpSpec y para el resto Behat.\n\n\nCiclo del desarrollo orientado a comportamiento\n\n\n\n\nDescribe el comportamiento del software a trav\u00e9s de pruebas\n\n\nEjecuta los test y comprueba que el nuevo test falla\n\n\nImplementa el nuevo comportamiento\n\n\nEjecuta los test\n\n\nMejora el c\u00f3digo\n\n\nRepite\n\n\n\n\nEjemplo de un test de unidad con PHPSpec\n\n\nSi usamos el ejemplo de la calculadora, esta ser\u00eda la forma de describir el comportamiento de la calculadora:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n?php\n\n\nuse\n \nPhpSpec\\ObjectBehavior\n;\n\n\n\nclass\n \nCalculatorSpec\n \nextends\n \nObjectBehavior\n\n\n{\n\n    \nfunction\n \nit_is_initializable\n()\n\n    \n{\n\n        \n$this\n-\nshouldHaveType\n(\nCalculator\n::\nclass\n);\n\n    \n}\n\n\n    \nfunction\n \nit_adds_to_numbers\n()\n\n    \n{\n\n        \n$this\n-\nadd\n(\n2\n,\n \n3\n)\n-\nshouldReturn\n(\n5\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nLas diferencias principales con PHPUnit son dos:\n\n\n\n\nEl nombre de la funci\u00f3n describe el comportamiento a implementar. Debe empezar por \nit_\n o \nits_\n.\n\n\nNo es necesario instanciar la clase que queremos probar. La clase \nCalculatorSpec\n adquiere los m\u00e9todos de la clase que estamos describiendo.\n\n\n\n\nHay muchas m\u00e1s diferencias, pero a grandes rasgos nos vamos a quedar con esas dos.\n\n\nEjemplo de un test con Behat\n\n\nBehat utiliza un lenguaje llamado Gherkin para describir historias de usuario. Es m\u00e1s apropiado para hacer test de aceptaci\u00f3n. Este ser\u00eda un ejemplo de un test de aceptaci\u00f3n con Gherkin:\n\n\n1\n2\n3\n4\n5\n6\n7\nCaracter\u00edstica:\n Crear una calculadora\n\n\n\n    \nEscenario:\n Sumar dos n\u00fameros\n\n\n        Dado \nque quiero sumar dos n\u00fameros\n\n\n        \nCuando \nintroduzco el n\u00famero \n2\n\n\n        \nE \nintroduzco el n\u00famero \n3\n\n\n        \nEntonces \nrecibo el n\u00famero \n5\n\n\n\n\n\n\n\nEsta prueba es una simplificaci\u00f3n de lo que permite hacer Gherkin. La forma en c\u00f3mo se ejecuta e implementa este tipo de test lo veremos m\u00e1s adelante.", 
            "title": "Introducci\u00f3n"
        }, 
        {
            "location": "/introduction/#introduccion", 
            "text": "", 
            "title": "Introducci\u00f3n"
        }, 
        {
            "location": "/introduction/#desarrollo-orientado-a-pruebas-tdd", 
            "text": "Test Driven Development (TDD), o desarrollo orientado a pruebas, es un proceso de desarrollo de software muy conocido, que consiste en la repetici\u00f3n de ciclos de desarrollo muy cortos.   Los requisitos se convierten en pruebas, unidades de c\u00f3digo que prueban una determinada funcionalidad.  Entonces, se produce el c\u00f3digo justo que permite pasar dicha prueba.   Este proceso es opuesto a otros sistemas de desarrollo que permiten incorporar c\u00f3digo que no se sabe con certeza si concuerdan o no con los requisitos.  Los test que se pueden realizar pueden ser de unidad, funcionales y de aceptaci\u00f3n. Para todos estos tipos de test, en PHP podemos usar PHPUnit.", 
            "title": "Desarrollo orientado a pruebas (TDD)"
        }, 
        {
            "location": "/introduction/#ciclo-del-desarrollo-orientado-a-pruebas", 
            "text": "A\u00f1ade un test  Ejecuta los test y comprueba que el nuevo test falla  Escribe el c\u00f3digo  Ejecuta los test  Refactoriza el c\u00f3digo  Repite", 
            "title": "Ciclo del desarrollo orientado a pruebas"
        }, 
        {
            "location": "/introduction/#ejemplo-de-un-test-de-unidad-con-phpunit", 
            "text": "Si queremos implementar una clase que implemente funciones matem\u00e1ticas, este ser\u00eda el c\u00f3digo de una prueba unitaria que, con PHPUnit, escribir\u00edamos para implementar la funcionalidad  suma :   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 ?php  use   PHPUnit\\Framework\\TestCase ;  class   CalculatorTest   extends   TestCase  { \n     public   function   testAdd () \n     { \n         $calculator   =   new   Calculator (); \n         $result   =   $calculator - add ( 3 ,   2 ); \n\n         $this - assertEquals ( 5 ,   $result ); \n     }  }    Solo cuando tengamos el test escrito podremos desarrollar el c\u00f3digo:  1\n2\n3\n4\n5\n6\n7\n8 ?php  class   Calculator  { \n     public   function   add   ( int   $a ,   int   $b ) :   int \n     { \n         return   $a   +   $b ; \n     }  }", 
            "title": "Ejemplo de un test de unidad con PHPUnit"
        }, 
        {
            "location": "/introduction/#las-tres-reglas", 
            "text": "Robert Martin, en su libro \"Clean Code. A Handbook of agile software craftsmanship\", especifica las tres reglas que deben seguirse cuando se desarrolla con TDD:   No debes escribir c\u00f3digo de producci\u00f3n hasta que hayas escrito una prueba unitaria que falle.  No debes escribir m\u00e1s de una prueba unitaria que sea suficiente para fallar y el sistema no compile.  No debes escribir m\u00e1s c\u00f3digo de producci\u00f3n que el suficiente para superar la prueba que est\u00e9 fallando actualmente.", 
            "title": "Las tres reglas"
        }, 
        {
            "location": "/introduction/#desarrollo-orientado-a-comportamiento-bdd", 
            "text": "Behaviour Driven Development (BDD), o desarrollo orientado a comportamiento, es un proceso de desarrollo similar a TDD, solo que con BDD lo que se realiza es definir el comportamiento y las especificaciones, al contrario que con TDD que se limita solamente a comprobar funcionalidades.  Los test que se pueden realizar pueden ser de unidad, funcionales y de aceptaci\u00f3n. Para los test de unidad el software m\u00e1s apropiado en PhpSpec y para el resto Behat.", 
            "title": "Desarrollo orientado a comportamiento (BDD)"
        }, 
        {
            "location": "/introduction/#ciclo-del-desarrollo-orientado-a-comportamiento", 
            "text": "Describe el comportamiento del software a trav\u00e9s de pruebas  Ejecuta los test y comprueba que el nuevo test falla  Implementa el nuevo comportamiento  Ejecuta los test  Mejora el c\u00f3digo  Repite", 
            "title": "Ciclo del desarrollo orientado a comportamiento"
        }, 
        {
            "location": "/introduction/#ejemplo-de-un-test-de-unidad-con-phpspec", 
            "text": "Si usamos el ejemplo de la calculadora, esta ser\u00eda la forma de describir el comportamiento de la calculadora:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15 ?php  use   PhpSpec\\ObjectBehavior ;  class   CalculatorSpec   extends   ObjectBehavior  { \n     function   it_is_initializable () \n     { \n         $this - shouldHaveType ( Calculator :: class ); \n     } \n\n     function   it_adds_to_numbers () \n     { \n         $this - add ( 2 ,   3 ) - shouldReturn ( 5 ); \n     }  }    Las diferencias principales con PHPUnit son dos:   El nombre de la funci\u00f3n describe el comportamiento a implementar. Debe empezar por  it_  o  its_ .  No es necesario instanciar la clase que queremos probar. La clase  CalculatorSpec  adquiere los m\u00e9todos de la clase que estamos describiendo.   Hay muchas m\u00e1s diferencias, pero a grandes rasgos nos vamos a quedar con esas dos.", 
            "title": "Ejemplo de un test de unidad con PHPSpec"
        }, 
        {
            "location": "/introduction/#ejemplo-de-un-test-con-behat", 
            "text": "Behat utiliza un lenguaje llamado Gherkin para describir historias de usuario. Es m\u00e1s apropiado para hacer test de aceptaci\u00f3n. Este ser\u00eda un ejemplo de un test de aceptaci\u00f3n con Gherkin:  1\n2\n3\n4\n5\n6\n7 Caracter\u00edstica:  Crear una calculadora       Escenario:  Sumar dos n\u00fameros          Dado  que quiero sumar dos n\u00fameros           Cuando  introduzco el n\u00famero  2           E  introduzco el n\u00famero  3           Entonces  recibo el n\u00famero  5    Esta prueba es una simplificaci\u00f3n de lo que permite hacer Gherkin. La forma en c\u00f3mo se ejecuta e implementa este tipo de test lo veremos m\u00e1s adelante.", 
            "title": "Ejemplo de un test con Behat"
        }, 
        {
            "location": "/modelling/", 
            "text": "Modelando con ejemplos\n\n\nCaptura de requisitos\n\n\nImaginemos que queremos crear un sistema de fidelizaci\u00f3n de clientes de un restaurante, d\u00e1ndoles una serie de puntos que le permitan obtener descuentos en sucesivas visitas. Cuando usamos reglas para la captura de requisitos, corremos el riesgo de ser ambiguos.\n\n\nPor ejemplo, veamos que ocurre cuando especificamos solo con reglas:\n\n\n\n\nExample\n\n\n\n\nRF01\n: Los clientes obtienen un punto por cada euro gastado en un men\u00fa.\n\n\nRF02\n: Diez puntos pueden ser canjeados por un euro de descuento al pagar un men\u00fa.\n\n\nRF03\n: El IVA es del 10%.\n\n\n\n\n\n\nEl problema es que nos surgen una serie de dudas que estas reglas no resuelven:\n\n\n\n\n\u00bfSi gasto puntos a\u00fan puedo ganar puntos?\n\n\n\u00bfPuedo gastar m\u00e1s de diez puntos en un solo men\u00fa?\n\n\n\u00bfEl IVA se aplica al precio descontado o al total?\n\n\n\n\nSi modelamos los requisitos con ejemplos obtenemos esto:\n\n\n\n\nExample\n\n\nSi un men\u00fa para una familia de cinco personas cuesta 50 euros:\n\n\n\n\nSi pagan en efectivo pagar\u00e1n 50\u20ac m\u00e1s 5\u20ac de IVA y obtendr\u00e1n 50 puntos.\n\n\nSi pagan con 10 puntos, costar\u00e1 10 puntos y 49\u20ac + 5\u20ac de IVA y obtendr\u00e1n 0 puntos.\n\n\nSi pagan solo con puntos, entregar\u00e1n 500 puntos + 5\u20ac de IVA y obtendr\u00e1n 0 puntos.\n\n\n\n\n\n\nEvidentemente el ejemplo cuenta con pocas reglas, pero lo que se quiere hacer notar es que es relativamente sencillo llegar a ambig\u00fcedades que con los ejemplos no obtendr\u00edamos. Por ello, en UML contamos con los casos de uso, que es una forma de captura de requisitos funcionales que permite evitar este tipo de problemas.\n\n\nNos vamos a ahorrar la parte de crear los casos de uso y vamos ir directamente a crear las historias de usuario con Gherkin.\n\n\nGherkin\n\n\nGherkin\n es un lenguaje que permite describir el comportamiento del software sin entrar en detalles de c\u00f3mo se ha implementado dicho comportamiento. Cada caracter\u00edstica que se define con \ngherkin\n debe ir en un fichero con extensi\u00f3n \n.feature\n. A continuaci\u00f3n se puede ver una plantilla de ejemplo:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n# language: es\n\n\nCaracter\u00edstica:\n Internal operations\n\n\n    In order to stay secret\n\n\n    As a secret organization\n\n\n    We need to be able to erase past agents\n memory\n\n\n\n    \nAntecedentes:\n\n\n        [Dados|Dadas|Dada|Dado|*] there is agent A\n\n\n        [*|Y|E] there is agent B\n\n\n\n    Escenario: Erasing agent memory\n\n\n        [Dados|Dadas|Dada|Dado|*] there is agent J\n\n\n        [*|Y|E] there is agent K\n\n\n        [Cuando|*] I erase agent K\ns memory\n\n\n        [Entonces|*] there should be agent J\n\n\n        [Pero|*] there should not be agent K\n\n\n\n    Esquema del escenario: Erasing other agents\n memory\n\n\n        [Dados|Dadas|Dada|Dado|*] there is agent \nagent1\n\n\n        [*|Y|E] there is agent \nagent2\n\n\n        [Cuando|*] I erase agent \nagent2\ns memory\n\n\n        [Entonces|*] there should be agent \nagent1\n\n\n        [Pero|*] there should not be agent \nagent2\n\n\n\n        Ejemplos:\n\n\n        | agent1 | agent2 |\n\n\n        | D      | M      |\n\n\n\n\n\n\n\nLas palabras entre [ ] indican una entre las posibles. Para ver el formato en ingl\u00e9s lee la documentaci\u00f3n oficial.\n\n\nIntroducci\u00f3n de la caracter\u00edstica\n\n\nCada archivo .feature consiste convencionalmente en una \u00fanica caracter\u00edstica. Una l\u00ednea que comienza con la palabra clave \nCaracter\u00edstica\n seguida de texto tabulado que la describe. Una caracter\u00edstica generalmente contiene una lista de escenarios y unos antecedentes. Cada escenario consiste en una lista de pasos, que debe comenzar con una de las palabras clave indicadas en la plantilla.\n\n\nLos \nantecedentes\n son datos disponibles antes de cada prueba. Lo habitual es resetear el estado de la aplicaci\u00f3n para que al comienzo de cada escenario est\u00e9 tal y como indican los antecedentes.\n\n\nLos \nescenarios\n son las caracter\u00edsticas que deben ser implementadas y se componen de tres secciones:\n\n\n\n\n\"\nDado\n unos antecedentes\": Permiten establecer un estado de la aplicaci\u00f3n espec\u00edfico para esta prueba.\n\n\n\"\nCuando\n\" ocurre o se realiza una acci\u00f3n: Aqu\u00ed es donde se prueba la caracter\u00edstica a programar.\n\n\n\"\nEntonces\n\" ocurre una consecuencia: Aqu\u00ed es donde se comprueba que la caracter\u00edstica funciona correctamente.\n\n\n\n\nSe pueden concatenar sentencias con las palabras \nY\n, \nE\n y \nPERO\n, tal y como se ve en la plantilla.\n\n\nCreando los escenarios\n\n\nVamos a describir un posible archivo \ngherkin\n para nuestro ejemplo del restaurante:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n#language: es\n\n\nCaracter\u00edstica:\n Pagar un men\u00fa\n\n\n    Reglas:\n\n\n\n    - 1 punto por cada euro.\n\n\n    - 10 puntos equivalen a un descuento de 1 euros.\n\n\n    - El IVA es del 10%\n\n\n\n    \nAntecedentes:\n\n\n        Dados los siguientes men\u00fas:\n\n\n        | n\u00famero | precio |\n\n\n        | 1      | 10     |\n\n\n        | 2      | 12     |\n\n\n        | 3      |  8     |\n\n\n\n    Escenario: Ganar puntos al pagar en efectivo\n\n\n        Dado \nque he comprado \n5\n men\u00fas del n\u00famero \n1\n\n\n        \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n        \nY \npago en efectivo con \n55\n euros\n\n\n        \nEntonces \nla factura est\u00e1 pagada\n\n\n        \nY \nhe obtenido \n50\n puntos\n\n\n\n    \nEscenario:\n Pagar con dinero y puntos\n\n\n        Dado \nque he comprado \n5\n men\u00fas del n\u00famero \n1\n\n\n        \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n        \nY \npago con \n10\n puntos y \n54\n euros\n\n\n        \nEntonces \nla factura est\u00e1 pagada\n\n\n        \nY \nhe obtenido \n0\n puntos\n\n\n\n    \nEscenario:\n Pagar con puntos\n\n\n        Dado \nque he comprado \n5\n men\u00fas del n\u00famero \n1\n\n\n        \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n        \nY \npago con \n500\n puntos y \n5\n euros\n\n\n        \nEntonces \nla factura est\u00e1 pagada\n\n\n        \nY \nhe obtenido \n0\n puntos\n\n\n\n    \nEscenario:\n Intentar pagar el IVA con puntos\n\n\n        Dado \nque he comprado \n5\n men\u00fas del n\u00famero \n1\n\n\n        \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n        \nY \npago con \n550\n puntos y \n0\n euros\n\n\n        \nEntonces \nla factura no est\u00e1 pagada\n\n\n        \nY \nquedan \n5\n euros por pagar\n\n\n\n    \nEscenario:\n Comprar men\u00fas de varios tipos\n\n\n        Dado \nque he comprado \n1\n men\u00fa del n\u00famero \n1\n\n\n        \nY \nque he comprado \n2\n men\u00fas del n\u00famero \n2\n\n\n        \nY \nque he comprado \n2\n men\u00fas del n\u00famero \n3\n\n\n        \nCuando \npido la cuenta recibo una factura de \n55\n euros\n\n\n        \nY \npago en efectivo con \n55\n euros\n\n\n        \nEntonces \nla factura est\u00e1 pagada\n\n\n        \nY \nhe obtenido \n50\n puntos\n\n\n\n\n\n\n\nEl anterior archivo describe las caracter\u00edsticas, en un lenguaje de negocio, de las caracter\u00edsticas del software que debemos implementar. En los siguientes cap\u00edtulos iremos implementando el proyecto paso a paso.", 
            "title": "Modelando con ejemplos"
        }, 
        {
            "location": "/modelling/#modelando-con-ejemplos", 
            "text": "", 
            "title": "Modelando con ejemplos"
        }, 
        {
            "location": "/modelling/#captura-de-requisitos", 
            "text": "Imaginemos que queremos crear un sistema de fidelizaci\u00f3n de clientes de un restaurante, d\u00e1ndoles una serie de puntos que le permitan obtener descuentos en sucesivas visitas. Cuando usamos reglas para la captura de requisitos, corremos el riesgo de ser ambiguos.  Por ejemplo, veamos que ocurre cuando especificamos solo con reglas:   Example   RF01 : Los clientes obtienen un punto por cada euro gastado en un men\u00fa.  RF02 : Diez puntos pueden ser canjeados por un euro de descuento al pagar un men\u00fa.  RF03 : El IVA es del 10%.    El problema es que nos surgen una serie de dudas que estas reglas no resuelven:   \u00bfSi gasto puntos a\u00fan puedo ganar puntos?  \u00bfPuedo gastar m\u00e1s de diez puntos en un solo men\u00fa?  \u00bfEl IVA se aplica al precio descontado o al total?   Si modelamos los requisitos con ejemplos obtenemos esto:   Example  Si un men\u00fa para una familia de cinco personas cuesta 50 euros:   Si pagan en efectivo pagar\u00e1n 50\u20ac m\u00e1s 5\u20ac de IVA y obtendr\u00e1n 50 puntos.  Si pagan con 10 puntos, costar\u00e1 10 puntos y 49\u20ac + 5\u20ac de IVA y obtendr\u00e1n 0 puntos.  Si pagan solo con puntos, entregar\u00e1n 500 puntos + 5\u20ac de IVA y obtendr\u00e1n 0 puntos.    Evidentemente el ejemplo cuenta con pocas reglas, pero lo que se quiere hacer notar es que es relativamente sencillo llegar a ambig\u00fcedades que con los ejemplos no obtendr\u00edamos. Por ello, en UML contamos con los casos de uso, que es una forma de captura de requisitos funcionales que permite evitar este tipo de problemas.  Nos vamos a ahorrar la parte de crear los casos de uso y vamos ir directamente a crear las historias de usuario con Gherkin.", 
            "title": "Captura de requisitos"
        }, 
        {
            "location": "/modelling/#gherkin", 
            "text": "Gherkin  es un lenguaje que permite describir el comportamiento del software sin entrar en detalles de c\u00f3mo se ha implementado dicho comportamiento. Cada caracter\u00edstica que se define con  gherkin  debe ir en un fichero con extensi\u00f3n  .feature . A continuaci\u00f3n se puede ver una plantilla de ejemplo:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27 # language: es  Caracter\u00edstica:  Internal operations      In order to stay secret      As a secret organization      We need to be able to erase past agents  memory       Antecedentes:          [Dados|Dadas|Dada|Dado|*] there is agent A          [*|Y|E] there is agent B      Escenario: Erasing agent memory          [Dados|Dadas|Dada|Dado|*] there is agent J          [*|Y|E] there is agent K          [Cuando|*] I erase agent K s memory          [Entonces|*] there should be agent J          [Pero|*] there should not be agent K      Esquema del escenario: Erasing other agents  memory          [Dados|Dadas|Dada|Dado|*] there is agent  agent1          [*|Y|E] there is agent  agent2          [Cuando|*] I erase agent  agent2 s memory          [Entonces|*] there should be agent  agent1          [Pero|*] there should not be agent  agent2          Ejemplos:          | agent1 | agent2 |          | D      | M      |    Las palabras entre [ ] indican una entre las posibles. Para ver el formato en ingl\u00e9s lee la documentaci\u00f3n oficial.", 
            "title": "Gherkin"
        }, 
        {
            "location": "/modelling/#introduccion-de-la-caracteristica", 
            "text": "Cada archivo .feature consiste convencionalmente en una \u00fanica caracter\u00edstica. Una l\u00ednea que comienza con la palabra clave  Caracter\u00edstica  seguida de texto tabulado que la describe. Una caracter\u00edstica generalmente contiene una lista de escenarios y unos antecedentes. Cada escenario consiste en una lista de pasos, que debe comenzar con una de las palabras clave indicadas en la plantilla.  Los  antecedentes  son datos disponibles antes de cada prueba. Lo habitual es resetear el estado de la aplicaci\u00f3n para que al comienzo de cada escenario est\u00e9 tal y como indican los antecedentes.  Los  escenarios  son las caracter\u00edsticas que deben ser implementadas y se componen de tres secciones:   \" Dado  unos antecedentes\": Permiten establecer un estado de la aplicaci\u00f3n espec\u00edfico para esta prueba.  \" Cuando \" ocurre o se realiza una acci\u00f3n: Aqu\u00ed es donde se prueba la caracter\u00edstica a programar.  \" Entonces \" ocurre una consecuencia: Aqu\u00ed es donde se comprueba que la caracter\u00edstica funciona correctamente.   Se pueden concatenar sentencias con las palabras  Y ,  E  y  PERO , tal y como se ve en la plantilla.", 
            "title": "Introducci\u00f3n de la caracter\u00edstica"
        }, 
        {
            "location": "/modelling/#creando-los-escenarios", 
            "text": "Vamos a describir un posible archivo  gherkin  para nuestro ejemplo del restaurante:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51 #language: es  Caracter\u00edstica:  Pagar un men\u00fa      Reglas:      - 1 punto por cada euro.      - 10 puntos equivalen a un descuento de 1 euros.      - El IVA es del 10%       Antecedentes:          Dados los siguientes men\u00fas:          | n\u00famero | precio |          | 1      | 10     |          | 2      | 12     |          | 3      |  8     |      Escenario: Ganar puntos al pagar en efectivo          Dado  que he comprado  5  men\u00fas del n\u00famero  1           Cuando  pido la cuenta recibo una factura de  55  euros           Y  pago en efectivo con  55  euros           Entonces  la factura est\u00e1 pagada           Y  he obtenido  50  puntos       Escenario:  Pagar con dinero y puntos          Dado  que he comprado  5  men\u00fas del n\u00famero  1           Cuando  pido la cuenta recibo una factura de  55  euros           Y  pago con  10  puntos y  54  euros           Entonces  la factura est\u00e1 pagada           Y  he obtenido  0  puntos       Escenario:  Pagar con puntos          Dado  que he comprado  5  men\u00fas del n\u00famero  1           Cuando  pido la cuenta recibo una factura de  55  euros           Y  pago con  500  puntos y  5  euros           Entonces  la factura est\u00e1 pagada           Y  he obtenido  0  puntos       Escenario:  Intentar pagar el IVA con puntos          Dado  que he comprado  5  men\u00fas del n\u00famero  1           Cuando  pido la cuenta recibo una factura de  55  euros           Y  pago con  550  puntos y  0  euros           Entonces  la factura no est\u00e1 pagada           Y  quedan  5  euros por pagar       Escenario:  Comprar men\u00fas de varios tipos          Dado  que he comprado  1  men\u00fa del n\u00famero  1           Y  que he comprado  2  men\u00fas del n\u00famero  2           Y  que he comprado  2  men\u00fas del n\u00famero  3           Cuando  pido la cuenta recibo una factura de  55  euros           Y  pago en efectivo con  55  euros           Entonces  la factura est\u00e1 pagada           Y  he obtenido  50  puntos    El anterior archivo describe las caracter\u00edsticas, en un lenguaje de negocio, de las caracter\u00edsticas del software que debemos implementar. En los siguientes cap\u00edtulos iremos implementando el proyecto paso a paso.", 
            "title": "Creando los escenarios"
        }
    ]
}