{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BDD by example \u00b6 Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba . El material de esta documentaci\u00f3n est\u00e1 sacado de las presentaciones de Ciaran McNulty : TDD with PhpSpec Driving Design through Examples Agradecimientos \u00b6 Este taller ha sido impartido por las siguientes personas: Javier Ca\u00f1ete Sergio G\u00f3mez","title":"Inicio"},{"location":"#bdd-by-example","text":"Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba . El material de esta documentaci\u00f3n est\u00e1 sacado de las presentaciones de Ciaran McNulty : TDD with PhpSpec Driving Design through Examples","title":"BDD by example"},{"location":"#agradecimientos","text":"Este taller ha sido impartido por las siguientes personas: Javier Ca\u00f1ete Sergio G\u00f3mez","title":"Agradecimientos"},{"location":"fifth-scenario/","text":"Quinto escenario \u00b6 Vamos a implementar el \u00faltimo escenario Escenario: Comprar men\u00fas de varios tipos Dado que he comprado 1 men\u00fa del n\u00famero 1 Y que he comprado 2 men\u00fas del n\u00famero 2 Y que he comprado 2 men\u00fas del n\u00famero 3 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Si ejecutamos la prueba: bash$ vendor/bin/behat features/menu.feature:43 Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Comprar men\u00fas de varios tipos # features/menu.feature:43 Dado que he comprado 1 men\u00fa del n\u00famero 1 # FeatureContext::queHeCompradoMenuDelNumero() TODO: write pending definition Y que he comprado 2 men\u00fas del n\u00famero 2 # FeatureContext::queHeCompradoMenusDelNumero() Y que he comprado 2 men\u00fas del n\u00famero 3 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago en efectivo con 55 euros # FeatureContext::pagoEnEfectivoConEuros() Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 50 puntos # FeatureContext::heObtenidoPuntos() 1 scenario ( 1 pending ) 8 steps ( 1 passed, 1 pending, 6 skipped ) 0m0.02s ( 9 .65Mb ) Falla en el primer paso. Realmente la frase \"que he comprado 1 men\u00fa del n\u00famero 1\" difiere de \"que he comprado 2 men\u00fas del n\u00famero 2\" en el plural de men\u00fas . Al ser frases distintas behat las interpreta como pasos distintos. Tenemos varias formas de solucionar esto que no pasen por escribir dos veces el mismo c\u00f3digo, es decir, conseguir que un mismo paso se ejecute con sentencias distintas. Por lo pronto el c\u00f3digo siguiente: <?php /** * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2 */ public function queHeCompradoMenuDelNumero ( $arg1 , $arg2 ) { throw new PendingException (); } Que pertenece a nuestro FeatureContext.php sobra y lo eliminamos. Primer m\u00e9todo: Escribir varias sentencias @Given \u00b6 Una posible soluci\u00f3n es a\u00f1adir a la cabecera del step todas las anotaciones que queramos que lo activen: <?php /** * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2 * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2 */ public function queHeCompradoMenusDelNumero ( $count , $menuNumber ) { $menu = $this -> menus [ $menuNumber ]; for ( $i = 0 ; $i < $count ; $i ++ ) { $this -> bill -> addItem ( $menu ); } } Segundo m\u00e9todo: Escribir las reglas como expresiones regulares \u00b6 Podemos usar expresiones regulares: <?php /** * @Given /^que he comprado (\\d+) men\u00fas? del n\u00famero (\\d+)$/ */ public function queHeCompradoMenusDelNumero ( $count , $menuNumber ) { $menu = $this -> menus [ $menuNumber ]; for ( $i = 0 ; $i < $count ; $i ++ ) { $this -> bill -> addItem ( $menu ); } } En el caso de usar expresiones regulares, debemos usar grupos de captura (el contenido entre par\u00e9ntesis) de aquellos valores que queramos pasar a la funci\u00f3n. Estado final \u00b6 Vamos a poner el c\u00f3digo del FeatureContext usando el primer m\u00e9todo: <?php use Behat\\Behat\\Context\\Context ; use Behat\\Behat\\Tester\\Exception\\PendingException ; use Behat\\Gherkin\\Node\\PyStringNode ; use Behat\\Gherkin\\Node\\TableNode ; /** * Defines application features from the specific context. */ class FeatureContext implements Context { private $menus ; private $bill ; /** * Initializes context. * * Every scenario gets its own context instance. * You can also pass arbitrary arguments to the * context constructor through behat.yml. */ public function __construct () { $this -> menus = []; $this -> bill = new \\Restaurant\\Bill (); } /** * @Given los siguientes men\u00fas: */ public function losSiguientesMenus ( TableNode $table ) { foreach ( $table -> getHash () as $menu ) { $this -> menus [ $menu [ 'n\u00famero' ]] = new \\Restaurant\\Menu ( $menu [ 'n\u00famero' ], $menu [ 'precio' ] * 100 ); } } /** * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2 * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2 */ public function queHeCompradoMenusDelNumero ( $count , $menuNumber ) { $menu = $this -> menus [ $menuNumber ]; for ( $i = 0 ; $i < $count ; $i ++ ) { $this -> bill -> addItem ( $menu ); } } /** * @When pido la cuenta recibo una factura de :arg1 euros */ public function pidoLaCuentaReciboUnaFacturaDeEuros ( $total ) { \\PHPUnit\\Framework\\Assert :: assertEquals ( $total * 100 , $this -> bill -> getTotal ()); } /** * @When pago en efectivo con :arg1 euros */ public function pagoEnEfectivoConEuros ( $amount ) { $this -> bill -> payWithMoney ( $amount * 100 ); } /** * @Then la factura est\u00e1 pagada */ public function laFacturaEstaPagada () { \\PHPUnit\\Framework\\Assert :: assertEquals ( 0 , $this -> bill -> restToPay ()); } /** * @Then he obtenido :arg1 puntos */ public function heObtenidoPuntos ( $points ) { \\PHPUnit\\Framework\\Assert :: assertEquals ( $points , $this -> bill -> getPoints ()); } /** * @When pago con :points puntos y :money euros */ public function pagoConPuntosYEuros ( $points , $money ) { $this -> bill -> payWithMoney ( $money * 100 ); $this -> bill -> payWithPoints ( $points ); } /** * @Then quedan :amount euros por pagar */ public function quedanEurosPorPagar ( $amount ) { \\PHPUnit\\Framework\\Assert :: assertEquals ( $amount * 100 , $this -> bill -> restToPay ()); } # } Y ejecutamos, ahora s\u00ed, todas las pruebas: bash$ vendor/bin/behat features/menu.feature Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Ganar puntos al pagar en efectivo # features/menu.feature:16 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago en efectivo con 55 euros # FeatureContext::pagoEnEfectivoConEuros() Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 50 puntos # FeatureContext::heObtenidoPuntos() Escenario: Pagar con dinero y puntos # features/menu.feature:23 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago con 10 puntos y 54 euros # FeatureContext::pagoConPuntosYEuros() Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 0 puntos # FeatureContext::heObtenidoPuntos() Escenario: Pagar con puntos # features/menu.feature:30 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago con 500 puntos y 5 euros # FeatureContext::pagoConPuntosYEuros() Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 0 puntos # FeatureContext::heObtenidoPuntos() Escenario: Intentar pagar el IVA con puntos # features/menu.feature:37 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago con 550 puntos y 0 euros # FeatureContext::pagoConPuntosYEuros() Entonces quedan 5 euros por pagar # FeatureContext::quedanEurosPorPagar() Escenario: Comprar men\u00fas de varios tipos # features/menu.feature:43 Dado que he comprado 1 men\u00fa del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Y que he comprado 2 men\u00fas del n\u00famero 2 # FeatureContext::queHeCompradoMenusDelNumero() Y que he comprado 2 men\u00fas del n\u00famero 3 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago en efectivo con 55 euros # FeatureContext::pagoEnEfectivoConEuros() Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 50 puntos # FeatureContext::heObtenidoPuntos() 5 scenarios ( 5 passed ) 31 steps ( 31 passed ) 0m0.04s ( 10 .07Mb ) Podemos comprobar que hemos conseguido pasar todas las pruebas y nuestra aplicaci\u00f3n cumplir\u00eda todas las especificaciones.","title":"Quinto escenario"},{"location":"fifth-scenario/#quinto-escenario","text":"Vamos a implementar el \u00faltimo escenario Escenario: Comprar men\u00fas de varios tipos Dado que he comprado 1 men\u00fa del n\u00famero 1 Y que he comprado 2 men\u00fas del n\u00famero 2 Y que he comprado 2 men\u00fas del n\u00famero 3 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Si ejecutamos la prueba: bash$ vendor/bin/behat features/menu.feature:43 Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Comprar men\u00fas de varios tipos # features/menu.feature:43 Dado que he comprado 1 men\u00fa del n\u00famero 1 # FeatureContext::queHeCompradoMenuDelNumero() TODO: write pending definition Y que he comprado 2 men\u00fas del n\u00famero 2 # FeatureContext::queHeCompradoMenusDelNumero() Y que he comprado 2 men\u00fas del n\u00famero 3 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago en efectivo con 55 euros # FeatureContext::pagoEnEfectivoConEuros() Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 50 puntos # FeatureContext::heObtenidoPuntos() 1 scenario ( 1 pending ) 8 steps ( 1 passed, 1 pending, 6 skipped ) 0m0.02s ( 9 .65Mb ) Falla en el primer paso. Realmente la frase \"que he comprado 1 men\u00fa del n\u00famero 1\" difiere de \"que he comprado 2 men\u00fas del n\u00famero 2\" en el plural de men\u00fas . Al ser frases distintas behat las interpreta como pasos distintos. Tenemos varias formas de solucionar esto que no pasen por escribir dos veces el mismo c\u00f3digo, es decir, conseguir que un mismo paso se ejecute con sentencias distintas. Por lo pronto el c\u00f3digo siguiente: <?php /** * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2 */ public function queHeCompradoMenuDelNumero ( $arg1 , $arg2 ) { throw new PendingException (); } Que pertenece a nuestro FeatureContext.php sobra y lo eliminamos.","title":"Quinto escenario"},{"location":"fifth-scenario/#primer-metodo-escribir-varias-sentencias-given","text":"Una posible soluci\u00f3n es a\u00f1adir a la cabecera del step todas las anotaciones que queramos que lo activen: <?php /** * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2 * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2 */ public function queHeCompradoMenusDelNumero ( $count , $menuNumber ) { $menu = $this -> menus [ $menuNumber ]; for ( $i = 0 ; $i < $count ; $i ++ ) { $this -> bill -> addItem ( $menu ); } }","title":"Primer m\u00e9todo: Escribir varias sentencias @Given"},{"location":"fifth-scenario/#segundo-metodo-escribir-las-reglas-como-expresiones-regulares","text":"Podemos usar expresiones regulares: <?php /** * @Given /^que he comprado (\\d+) men\u00fas? del n\u00famero (\\d+)$/ */ public function queHeCompradoMenusDelNumero ( $count , $menuNumber ) { $menu = $this -> menus [ $menuNumber ]; for ( $i = 0 ; $i < $count ; $i ++ ) { $this -> bill -> addItem ( $menu ); } } En el caso de usar expresiones regulares, debemos usar grupos de captura (el contenido entre par\u00e9ntesis) de aquellos valores que queramos pasar a la funci\u00f3n.","title":"Segundo m\u00e9todo: Escribir las reglas como expresiones regulares"},{"location":"fifth-scenario/#estado-final","text":"Vamos a poner el c\u00f3digo del FeatureContext usando el primer m\u00e9todo: <?php use Behat\\Behat\\Context\\Context ; use Behat\\Behat\\Tester\\Exception\\PendingException ; use Behat\\Gherkin\\Node\\PyStringNode ; use Behat\\Gherkin\\Node\\TableNode ; /** * Defines application features from the specific context. */ class FeatureContext implements Context { private $menus ; private $bill ; /** * Initializes context. * * Every scenario gets its own context instance. * You can also pass arbitrary arguments to the * context constructor through behat.yml. */ public function __construct () { $this -> menus = []; $this -> bill = new \\Restaurant\\Bill (); } /** * @Given los siguientes men\u00fas: */ public function losSiguientesMenus ( TableNode $table ) { foreach ( $table -> getHash () as $menu ) { $this -> menus [ $menu [ 'n\u00famero' ]] = new \\Restaurant\\Menu ( $menu [ 'n\u00famero' ], $menu [ 'precio' ] * 100 ); } } /** * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2 * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2 */ public function queHeCompradoMenusDelNumero ( $count , $menuNumber ) { $menu = $this -> menus [ $menuNumber ]; for ( $i = 0 ; $i < $count ; $i ++ ) { $this -> bill -> addItem ( $menu ); } } /** * @When pido la cuenta recibo una factura de :arg1 euros */ public function pidoLaCuentaReciboUnaFacturaDeEuros ( $total ) { \\PHPUnit\\Framework\\Assert :: assertEquals ( $total * 100 , $this -> bill -> getTotal ()); } /** * @When pago en efectivo con :arg1 euros */ public function pagoEnEfectivoConEuros ( $amount ) { $this -> bill -> payWithMoney ( $amount * 100 ); } /** * @Then la factura est\u00e1 pagada */ public function laFacturaEstaPagada () { \\PHPUnit\\Framework\\Assert :: assertEquals ( 0 , $this -> bill -> restToPay ()); } /** * @Then he obtenido :arg1 puntos */ public function heObtenidoPuntos ( $points ) { \\PHPUnit\\Framework\\Assert :: assertEquals ( $points , $this -> bill -> getPoints ()); } /** * @When pago con :points puntos y :money euros */ public function pagoConPuntosYEuros ( $points , $money ) { $this -> bill -> payWithMoney ( $money * 100 ); $this -> bill -> payWithPoints ( $points ); } /** * @Then quedan :amount euros por pagar */ public function quedanEurosPorPagar ( $amount ) { \\PHPUnit\\Framework\\Assert :: assertEquals ( $amount * 100 , $this -> bill -> restToPay ()); } # } Y ejecutamos, ahora s\u00ed, todas las pruebas: bash$ vendor/bin/behat features/menu.feature Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Ganar puntos al pagar en efectivo # features/menu.feature:16 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago en efectivo con 55 euros # FeatureContext::pagoEnEfectivoConEuros() Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 50 puntos # FeatureContext::heObtenidoPuntos() Escenario: Pagar con dinero y puntos # features/menu.feature:23 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago con 10 puntos y 54 euros # FeatureContext::pagoConPuntosYEuros() Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 0 puntos # FeatureContext::heObtenidoPuntos() Escenario: Pagar con puntos # features/menu.feature:30 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago con 500 puntos y 5 euros # FeatureContext::pagoConPuntosYEuros() Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 0 puntos # FeatureContext::heObtenidoPuntos() Escenario: Intentar pagar el IVA con puntos # features/menu.feature:37 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago con 550 puntos y 0 euros # FeatureContext::pagoConPuntosYEuros() Entonces quedan 5 euros por pagar # FeatureContext::quedanEurosPorPagar() Escenario: Comprar men\u00fas de varios tipos # features/menu.feature:43 Dado que he comprado 1 men\u00fa del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Y que he comprado 2 men\u00fas del n\u00famero 2 # FeatureContext::queHeCompradoMenusDelNumero() Y que he comprado 2 men\u00fas del n\u00famero 3 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago en efectivo con 55 euros # FeatureContext::pagoEnEfectivoConEuros() Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 50 puntos # FeatureContext::heObtenidoPuntos() 5 scenarios ( 5 passed ) 31 steps ( 31 passed ) 0m0.04s ( 10 .07Mb ) Podemos comprobar que hemos conseguido pasar todas las pruebas y nuestra aplicaci\u00f3n cumplir\u00eda todas las especificaciones.","title":"Estado final"},{"location":"first-scenario/","text":"Implementando el primer escenario \u00b6 El primer escenario es el siguiente: Escenario: Ganar puntos al pagar en efectivo Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Para implementar esta escenario, que es realmente el primero de nuestro proyecto que vamos a implementar, necesitamos una clase cuenta ( Bill ) que guarde los men\u00fas que se han consumido e informe del coste total, de la cantidad que se ha ingresado (en dinero o puntos), de lo que resta por pagar y de los puntos obtenidos. Describir la clase Bill \u00b6 Usamos PhpSpec para crear la especificaci\u00f3n, siguiendo los pasos que anteriormente hicimos con la clase Menu . vendor/bin/phpspec desc Restaurant/Bill Y como resultado tendremos nuestra nueva clase Bill : bash$ vendor/bin/phpspec desc Restaurant/Bill Specification for Restaurant \\B ill created in /home/sergio/Developer/curso-web/bdd-by-example/bdd-by-example/spec/Restaurant/BillSpec.php. bash$ vendor/bin/phpspec run Restaurant \\B ill 11 ! is initializable class Restaurant \\B ill does not exist. Restaurant \\M enu 19 \u2714 is initializable 24 \u2714 has a menu number 29 \u2714 has a price ---- broken examples Restaurant/Bill 11 ! is initializable class Restaurant \\B ill does not exist. 2 specs 4 examples ( 3 passed, 1 broken ) 71ms Do you want me to create ` Restaurant \\B ill ` for you? [ Y/n ] Class Restaurant \\B ill created in /home/sergio/Developer/curso-web/bdd-by-example/bdd-by-example/src/Restaurant/Bill.php. Restaurant \\B ill 11 \u2714 is initializable Restaurant \\M enu 19 \u2714 is initializable 24 \u2714 has a menu number 29 \u2714 has a price 2 specs 4 examples ( 4 passed ) 71ms Ya tenemos nuestra especificaci\u00f3n spec/Restaurant/BillSpec.php y nuestra clase Restaurant/Bill.php Ahora tenemos que describir la API de nuestra clase. Concretamente para este escenario nuestra clase debe proporcionar una API para: A\u00f1adir un men\u00fa a la cuenta Obtener el total de la cuenta Permitir pagar una cantidad de dinero Determinar cu\u00e1nto resta por pagar Determinar cu\u00e1ntos puntos se han ganado Para esta prueba vamos a suponer que tenemos ya una instancia de Menu que cuesta 10\u20ac. A\u00f1adiendo elementos a la cuenta \u00b6 Ahora ya podemos a\u00f1adir elementos a la cuenta, sin importarnos si es un men\u00fa o cualquier otra cosa, solo los importa que tenga precio. Vamos a hacer las pruebas con un solo elemento que cueste 10\u20ac. Vamos a crear el m\u00e9todo let para configurar los datos de ejemplo: <?php namespace spec\\Restaurant ; use Restaurant\\Bill ; use PhpSpec\\ObjectBehavior ; use Prophecy\\Argument ; use Restaurant\\Menu ; class BillSpec extends ObjectBehavior { function let ( Menu $item ) { $item -> price () -> willReturn ( 1000 ); } function it_is_initializable () { $this -> shouldHaveType ( Bill :: class ); } } En esta ocasi\u00f3n no estamos usando let para configurar el constructor de la clase, que por ahora no hemos determinado que vayamos a necesitar, sino para configurar una instancia de la clase Menu y que cuando se llamen a la funci\u00f3n price() devolver\u00e1 1000. Hay que tener en cuenta que Menu no es algo que hayamos instanciado nosotros. Lo que ha ocurrido es que phpspec ha creado un doble , una clase que simula las respuestas a los m\u00e9todos con los valores que se le indican con las cl\u00e1usulas willReturn . <?php namespace spec\\Restaurant ; use Restaurant\\Bill ; use PhpSpec\\ObjectBehavior ; use Prophecy\\Argument ; use Restaurant\\Menu ; class BillSpec extends ObjectBehavior { function let ( Menu $item ) { $item -> price () -> willReturn ( 1000 ); } function it_is_initializable () { $this -> shouldHaveType ( Bill :: class ); } function it_has_no_items_by_default () { $this -> getTotal () -> shouldBe ( 0 ); } function it_adds_an_item ( Menu $item ) { $this -> addItem ( $item ); $this -> getTotal () -> shouldBe ( 1100 ); } } Estamos describiendo que nuestra cuenta, cuando se crea, no debe tener ning\u00fan elemento, y que los elementos que se a\u00f1aden incrementan la cuenta (con IVA). Debido al incremento del IVA el valor de retorno ser\u00e1 siempre flotante. Ejecutamos las pruebas, que fallar\u00e1n, y pasamos a implementar el c\u00f3digo. Pasamos a completar el c\u00f3digo de nuestra clase Bill : <?php declare ( strict_types = 1 ); namespace Restaurant ; class Bill { const VAT = '1.10' ; private $items ; public function __construct () { $this -> items = []; } public function getTotal () : int { return ( int ) ( array_reduce ( $this -> items , function ( $carry , Menu $menu ) { return $carry + $menu -> price (); }, 0 ) * self :: VAT ); } public function addItem ( Menu $item ) : void { $this -> items [] = $item ; } } Y ejecutamos las pruebas: vendor/bin/phpspec run Restaurant \\\\ Bill Restaurant \\B ill 17 \u2714 is initializable 22 \u2714 has no items by default 27 \u2714 adds an item 33 \u2714 adds multiple items 1 specs 4 examples ( 4 passed ) 112ms Refactorizar Menu \u00b6 A la clase Bill, \u00bfle importa el n\u00famero del men\u00fa? No, en realidad no. En m\u00e1s, \u00bfpodr\u00edamos a\u00f1adir elementos a la cuenta que no fueran men\u00fas? Lo l\u00f3gico es que s\u00ed. Entonces, \u00bfc\u00f3mo hacemos nuestra clase compatible con cualquier clase que tenga un precio? Pues utilizando interfaces. Vamos a crear una interfaz Priced que obligue a las clases que lo implementen a devolver price() . De esa manera, a Bill solo le interesa que elemento que a\u00f1adimos a la cuenta tenga un m\u00e9todo price . A\u00f1adimos esta especificaci\u00f3n a MenuSpec : <?php class MenuSpec extends ObjectBehavior { function it_implements_price_interface () { $this -> shouldImplement ( \\Restaurant\\Priced :: class ); } } Info Ponemos el namespace completo de \\Restaurant\\Price , pero podemos importarla con use Restaurant\\Price; en la cabecera de nuestro archivo. En este caso Priced a\u00fan no existe y la prueba fallar\u00e1, como es normal. Pero en esta ocasi\u00f3n phpspec no crear\u00e1 la clase, simplemente se limitar\u00e1 a fallar. Vamos a crear nuestra interfaz en Restaurant/Priced.php : <?php namespace Restaurant ; interface Priced { public function price () : int ; } Ahora necesitamos que nuestra clase _Menu_ implemente la interfaz _Priced_ : `` ` php hl_lines = \"5\" <? php namespace Restaurant ; class Menu implements Priced { private $number ; private $price ; public function __construct ( int $number , int $price ) { $this -> number = $number ; $this -> price = $price ; } public function number () : int { return $this -> number ; } public function price () : int { return $this -> price ; } } Y ya hemos conseguido que la prueba pase: vendor/bin/phpspec run Restaurant \\B ill 11 \u2714 is initializable Restaurant \\M enu 19 \u2714 implements price interface 24 \u2714 is initializable 29 \u2714 has a menu number 34 \u2714 has a price 2 specs 5 examples ( 5 passed ) 82ms Refactorizamos la especificaci\u00f3n de Bill: <?php namespace spec\\Restaurant ; use Restaurant\\Bill ; use PhpSpec\\ObjectBehavior ; use Prophecy\\Argument ; use Restaurant\\Priced ; class BillSpec extends ObjectBehavior { function let ( Priced $item ) { $item -> price () -> willReturn ( 1000 ); } function it_is_initializable () { $this -> shouldHaveType ( Bill :: class ); } function it_has_no_items_by_default () { $this -> getTotal () -> shouldBe ( 0 ); } function it_adds_an_item ( Priced $item ) { $this -> addItem ( $item ); $this -> getTotal () -> shouldBe ( 1100 ); } function it_adds_multiple_items ( Priced $item , Priced $anotherItem ) { $anotherItem -> price () -> willReturn ( 2000 ); $this -> addItem ( $item ); $this -> addItem ( $anotherItem ); $this -> getTotal () -> shouldBe ( 3300 ); } } Y refactorizamos la clase Bill : <?php declare ( strict_types = 1 ); namespace Restaurant ; class Bill { const VAT = '1.10' ; private $items ; public function __construct () { $this -> items = []; } public function getTotal () : int { return ( int ) ( array_reduce ( $this -> items , function ( $carry , Priced $menu ) { return $carry + $menu -> price (); }, 0 ) * self :: VAT ); } public function addItem ( Priced $item ) : void { $this -> items [] = $item ; } } Implementando los primeros steps \u00b6 Ahora estamos en posici\u00f3n de implementar los primeros steps: Escenario: Ganar puntos al pagar en efectivo Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Quedando el c\u00f3digo en el archivo FeatureContext como sigue: <?php use Behat\\Behat\\Context\\Context ; use Behat\\Behat\\Tester\\Exception\\PendingException ; use Behat\\Gherkin\\Node\\PyStringNode ; use Behat\\Gherkin\\Node\\TableNode ; /** * Defines application features from the specific context. */ class FeatureContext implements Context { private $menus ; private $bill ; /** * Initializes context. * * Every scenario gets its own context instance. * You can also pass arbitrary arguments to the * context constructor through behat.yml. */ public function __construct () { $this -> menus = []; $this -> bill = new \\Restaurant\\Bill (); } /** * @Given los siguientes men\u00fas: */ public function losSiguientesMenus ( TableNode $table ) { foreach ( $table -> getHash () as $menu ) { $this -> menus [ $menu [ 'n\u00famero' ]] = new \\Restaurant\\Menu ( $menu [ 'n\u00famero' ], $menu [ 'precio' ] * 100 ); } } /** * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2 */ public function queHeCompradoMenusDelNumero ( $count , $menuNumber ) { $menu = $this -> menus [ $menuNumber ]; for ( $i = 0 ; $i < $count ; $i ++ ) { $this -> bill -> addItem ( $menu ); } } /** * @When pido la cuenta recibo una factura de :arg1 euros */ public function pidoLaCuentaReciboUnaFacturaDeEuros ( $total ) { \\PHPUnit\\Framework\\Assert :: assertEquals ( $total * 100 , $this -> bill -> getTotal ()); } /** * @When pago en efectivo con :arg1 euros */ public function pagoEnEfectivoConEuros ( $arg1 ) { throw new PendingException (); } /** * @Then la factura est\u00e1 pagada */ public function laFacturaEstaPagada () { throw new PendingException (); } /** * @Then he obtenido :arg1 puntos */ public function heObtenidoPuntos ( $arg1 ) { throw new PendingException (); } /** * @When pago con :arg1 puntos y :arg2 euros */ public function pagoConPuntosYEuros ( $arg1 , $arg2 ) { throw new PendingException (); } /** * @Then quedan :arg1 euros por pagar */ public function quedanEurosPorPagar ( $arg1 ) { throw new PendingException (); } } Y comprobamos que, efectivamente, el c\u00f3digo funciona: bash$ vendor/bin/behat features/menu.feature:16 Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Ganar puntos al pagar en efectivo # features/menu.feature:16 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago en efectivo con 55 euros # FeatureContext::pagoEnEfectivoConEuros() TODO: write pending definition Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 50 puntos # FeatureContext::heObtenidoPuntos() 1 scenario ( 1 pending ) 6 steps ( 3 passed, 1 pending, 2 skipped ) 0m0.02s ( 10 .09Mb ) Implementando el pago \u00b6 Para implementar el pago debemos ser capaces de indicar una cantidad pagada en met\u00e1lico, ver cu\u00e1nto queda por pagar y ver cu\u00e1ntos puntos hemos obtenido. Esta ser\u00eda la especificaci\u00f3n: <?php namespace spec\\Restaurant ; use Restaurant\\Bill ; use PhpSpec\\ObjectBehavior ; use Prophecy\\Argument ; use Restaurant\\Priced ; class BillSpec extends ObjectBehavior { function let ( Priced $item ) { $item -> price () -> willReturn ( 1000 ); } function it_is_initializable () { $this -> shouldHaveType ( Bill :: class ); } function it_has_no_items_by_default () { $this -> getTotal () -> shouldBe ( 0 ); } function it_adds_an_item ( Priced $item ) { $this -> addItem ( $item ); $this -> getTotal () -> shouldBe ( 1100 ); } function it_adds_multiple_items ( Priced $item , Priced $anotherItem ) { $anotherItem -> price () -> willReturn ( 2000 ); $this -> addItem ( $item ); $this -> addItem ( $anotherItem ); $this -> getTotal () -> shouldBe ( 3300 ); } function it_can_be_paid_with_money ( Priced $item ) { $this -> addItem ( $item ); $this -> payWithMoney ( 1100 ); $this -> restToPay () -> shouldBe ( 0 ); } function it_can_give_points_when_is_payed_with_money ( Priced $item ) { $this -> addItem ( $item ); $this -> payWithMoney ( 1100 ); $this -> getPoints () -> shouldBe ( 10 ); } function it_can_not_give_points_when_total_is_not_enough ( Priced $anotherItem ) { $anotherItem -> price () -> willReturn ( 99 ); $this -> addItem ( $anotherItem ); $this -> payWithMoney ( 109 ); $this -> getPoints () -> shouldBe ( 0 ); } } Estamos describiendo distintos casos: Cuando se paga exacto y no queda nada por pagar Cuando se pagan justo 10 euros Cuando se pagan menos de 1 euro Podr\u00edamos ser m\u00e1s exhaustivos, como determinar que no se den puntos hasta que no se pague, pero lo dejamos para los casos siguientes. Ejecutamos las pruebas para que phpspec genere los m\u00e9todos en nuestra clase y completamos el c\u00f3digo en la clase Bill : <?php declare ( strict_types = 1 ); namespace Restaurant ; class Bill { const VAT = '1.10' ; private $items ; private $amount ; public function __construct () { $this -> items = []; } public function getTotal () : int { return ( int ) round ( $this -> totalWithoutVAT () * self :: VAT ); } public function addItem ( Priced $item ) : void { $this -> items [] = $item ; } public function payWithMoney ( int $amount ) : void { $this -> amount = $amount ; } public function restToPay () : int { return $this -> getTotal () - $this -> amount ; } public function getPoints () : int { return ( int ) floor ( $this -> totalWithoutVAT () / 100 ); } private function totalWithoutVAT () : int { return array_reduce ( $this -> items , function ( $carry , Priced $priced ) { return $carry + $priced -> price (); }, 0 ); } } Y comprobamos que pasamos las pruebas: bash$ vendor/bin/phpspec run Restaurant \\\\ Bill Restaurant \\B ill 17 \u2714 is initializable 22 \u2714 has no items by default 27 \u2714 adds an item 33 \u2714 adds multiple items 41 \u2714 can be paid with money 48 \u2714 can give points when is payed with money 55 \u2714 can not give points when total is not enough 1 specs 7 examples ( 7 passed ) 172ms Ya nos resta terminar de implementar la historia de usuario. Nuestra clase FeatureContext queda as\u00ed: <?php use Behat\\Behat\\Context\\Context ; use Behat\\Behat\\Tester\\Exception\\PendingException ; use Behat\\Gherkin\\Node\\PyStringNode ; use Behat\\Gherkin\\Node\\TableNode ; /** * Defines application features from the specific context. */ class FeatureContext implements Context { private $menus ; private $bill ; /** * Initializes context. * * Every scenario gets its own context instance. * You can also pass arbitrary arguments to the * context constructor through behat.yml. */ public function __construct () { $this -> menus = []; $this -> bill = new \\Restaurant\\Bill (); } /** * @Given los siguientes men\u00fas: */ public function losSiguientesMenus ( TableNode $table ) { foreach ( $table -> getHash () as $menu ) { $this -> menus [ $menu [ 'n\u00famero' ]] = new \\Restaurant\\Menu ( $menu [ 'n\u00famero' ], $menu [ 'precio' ] * 100 ); } } /** * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2 */ public function queHeCompradoMenusDelNumero ( $count , $menuNumber ) { $menu = $this -> menus [ $menuNumber ]; for ( $i = 0 ; $i < $count ; $i ++ ) { $this -> bill -> addItem ( $menu ); } } /** * @When pido la cuenta recibo una factura de :arg1 euros */ public function pidoLaCuentaReciboUnaFacturaDeEuros ( $total ) { \\PHPUnit\\Framework\\Assert :: assertEquals ( $total * 100 , $this -> bill -> getTotal ()); } /** * @When pago en efectivo con :arg1 euros */ public function pagoEnEfectivoConEuros ( $amount ) { $this -> bill -> payWithMoney ( $amount * 100 ); } /** * @Then la factura est\u00e1 pagada */ public function laFacturaEstaPagada () { \\PHPUnit\\Framework\\Assert :: assertEquals ( 0 , $this -> bill -> restToPay ()); } /** * @Then he obtenido :arg1 puntos */ public function heObtenidoPuntos ( $points ) { \\PHPUnit\\Framework\\Assert :: assertEquals ( $points , $this -> bill -> getPoints ()); } /** * @When pago con :arg1 puntos y :arg2 euros */ public function pagoConPuntosYEuros ( $arg1 , $arg2 ) { throw new PendingException (); } /** * @Then quedan :arg1 euros por pagar */ public function quedanEurosPorPagar ( $arg1 ) { throw new PendingException (); } } Si ejecutamos este primer escenario debemos comprobar que se ha completado con \u00e9xito: bash$ vendor/bin/behat features/menu.feature:16 Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Ganar puntos al pagar en efectivo # features/menu.feature:16 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago en efectivo con 55 euros # FeatureContext::pagoEnEfectivoConEuros() Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 50 puntos # FeatureContext::heObtenidoPuntos() 1 scenario ( 1 passed ) 6 steps ( 6 passed ) 0m0.02s ( 10 .08Mb )","title":"Implementando el primer escenario"},{"location":"first-scenario/#implementando-el-primer-escenario","text":"El primer escenario es el siguiente: Escenario: Ganar puntos al pagar en efectivo Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Para implementar esta escenario, que es realmente el primero de nuestro proyecto que vamos a implementar, necesitamos una clase cuenta ( Bill ) que guarde los men\u00fas que se han consumido e informe del coste total, de la cantidad que se ha ingresado (en dinero o puntos), de lo que resta por pagar y de los puntos obtenidos.","title":"Implementando el primer escenario"},{"location":"first-scenario/#describir-la-clase-bill","text":"Usamos PhpSpec para crear la especificaci\u00f3n, siguiendo los pasos que anteriormente hicimos con la clase Menu . vendor/bin/phpspec desc Restaurant/Bill Y como resultado tendremos nuestra nueva clase Bill : bash$ vendor/bin/phpspec desc Restaurant/Bill Specification for Restaurant \\B ill created in /home/sergio/Developer/curso-web/bdd-by-example/bdd-by-example/spec/Restaurant/BillSpec.php. bash$ vendor/bin/phpspec run Restaurant \\B ill 11 ! is initializable class Restaurant \\B ill does not exist. Restaurant \\M enu 19 \u2714 is initializable 24 \u2714 has a menu number 29 \u2714 has a price ---- broken examples Restaurant/Bill 11 ! is initializable class Restaurant \\B ill does not exist. 2 specs 4 examples ( 3 passed, 1 broken ) 71ms Do you want me to create ` Restaurant \\B ill ` for you? [ Y/n ] Class Restaurant \\B ill created in /home/sergio/Developer/curso-web/bdd-by-example/bdd-by-example/src/Restaurant/Bill.php. Restaurant \\B ill 11 \u2714 is initializable Restaurant \\M enu 19 \u2714 is initializable 24 \u2714 has a menu number 29 \u2714 has a price 2 specs 4 examples ( 4 passed ) 71ms Ya tenemos nuestra especificaci\u00f3n spec/Restaurant/BillSpec.php y nuestra clase Restaurant/Bill.php Ahora tenemos que describir la API de nuestra clase. Concretamente para este escenario nuestra clase debe proporcionar una API para: A\u00f1adir un men\u00fa a la cuenta Obtener el total de la cuenta Permitir pagar una cantidad de dinero Determinar cu\u00e1nto resta por pagar Determinar cu\u00e1ntos puntos se han ganado Para esta prueba vamos a suponer que tenemos ya una instancia de Menu que cuesta 10\u20ac.","title":"Describir la clase Bill"},{"location":"first-scenario/#anadiendo-elementos-a-la-cuenta","text":"Ahora ya podemos a\u00f1adir elementos a la cuenta, sin importarnos si es un men\u00fa o cualquier otra cosa, solo los importa que tenga precio. Vamos a hacer las pruebas con un solo elemento que cueste 10\u20ac. Vamos a crear el m\u00e9todo let para configurar los datos de ejemplo: <?php namespace spec\\Restaurant ; use Restaurant\\Bill ; use PhpSpec\\ObjectBehavior ; use Prophecy\\Argument ; use Restaurant\\Menu ; class BillSpec extends ObjectBehavior { function let ( Menu $item ) { $item -> price () -> willReturn ( 1000 ); } function it_is_initializable () { $this -> shouldHaveType ( Bill :: class ); } } En esta ocasi\u00f3n no estamos usando let para configurar el constructor de la clase, que por ahora no hemos determinado que vayamos a necesitar, sino para configurar una instancia de la clase Menu y que cuando se llamen a la funci\u00f3n price() devolver\u00e1 1000. Hay que tener en cuenta que Menu no es algo que hayamos instanciado nosotros. Lo que ha ocurrido es que phpspec ha creado un doble , una clase que simula las respuestas a los m\u00e9todos con los valores que se le indican con las cl\u00e1usulas willReturn . <?php namespace spec\\Restaurant ; use Restaurant\\Bill ; use PhpSpec\\ObjectBehavior ; use Prophecy\\Argument ; use Restaurant\\Menu ; class BillSpec extends ObjectBehavior { function let ( Menu $item ) { $item -> price () -> willReturn ( 1000 ); } function it_is_initializable () { $this -> shouldHaveType ( Bill :: class ); } function it_has_no_items_by_default () { $this -> getTotal () -> shouldBe ( 0 ); } function it_adds_an_item ( Menu $item ) { $this -> addItem ( $item ); $this -> getTotal () -> shouldBe ( 1100 ); } } Estamos describiendo que nuestra cuenta, cuando se crea, no debe tener ning\u00fan elemento, y que los elementos que se a\u00f1aden incrementan la cuenta (con IVA). Debido al incremento del IVA el valor de retorno ser\u00e1 siempre flotante. Ejecutamos las pruebas, que fallar\u00e1n, y pasamos a implementar el c\u00f3digo. Pasamos a completar el c\u00f3digo de nuestra clase Bill : <?php declare ( strict_types = 1 ); namespace Restaurant ; class Bill { const VAT = '1.10' ; private $items ; public function __construct () { $this -> items = []; } public function getTotal () : int { return ( int ) ( array_reduce ( $this -> items , function ( $carry , Menu $menu ) { return $carry + $menu -> price (); }, 0 ) * self :: VAT ); } public function addItem ( Menu $item ) : void { $this -> items [] = $item ; } } Y ejecutamos las pruebas: vendor/bin/phpspec run Restaurant \\\\ Bill Restaurant \\B ill 17 \u2714 is initializable 22 \u2714 has no items by default 27 \u2714 adds an item 33 \u2714 adds multiple items 1 specs 4 examples ( 4 passed ) 112ms","title":"A\u00f1adiendo elementos a la cuenta"},{"location":"first-scenario/#refactorizar-menu","text":"A la clase Bill, \u00bfle importa el n\u00famero del men\u00fa? No, en realidad no. En m\u00e1s, \u00bfpodr\u00edamos a\u00f1adir elementos a la cuenta que no fueran men\u00fas? Lo l\u00f3gico es que s\u00ed. Entonces, \u00bfc\u00f3mo hacemos nuestra clase compatible con cualquier clase que tenga un precio? Pues utilizando interfaces. Vamos a crear una interfaz Priced que obligue a las clases que lo implementen a devolver price() . De esa manera, a Bill solo le interesa que elemento que a\u00f1adimos a la cuenta tenga un m\u00e9todo price . A\u00f1adimos esta especificaci\u00f3n a MenuSpec : <?php class MenuSpec extends ObjectBehavior { function it_implements_price_interface () { $this -> shouldImplement ( \\Restaurant\\Priced :: class ); } } Info Ponemos el namespace completo de \\Restaurant\\Price , pero podemos importarla con use Restaurant\\Price; en la cabecera de nuestro archivo. En este caso Priced a\u00fan no existe y la prueba fallar\u00e1, como es normal. Pero en esta ocasi\u00f3n phpspec no crear\u00e1 la clase, simplemente se limitar\u00e1 a fallar. Vamos a crear nuestra interfaz en Restaurant/Priced.php : <?php namespace Restaurant ; interface Priced { public function price () : int ; } Ahora necesitamos que nuestra clase _Menu_ implemente la interfaz _Priced_ : `` ` php hl_lines = \"5\" <? php namespace Restaurant ; class Menu implements Priced { private $number ; private $price ; public function __construct ( int $number , int $price ) { $this -> number = $number ; $this -> price = $price ; } public function number () : int { return $this -> number ; } public function price () : int { return $this -> price ; } } Y ya hemos conseguido que la prueba pase: vendor/bin/phpspec run Restaurant \\B ill 11 \u2714 is initializable Restaurant \\M enu 19 \u2714 implements price interface 24 \u2714 is initializable 29 \u2714 has a menu number 34 \u2714 has a price 2 specs 5 examples ( 5 passed ) 82ms Refactorizamos la especificaci\u00f3n de Bill: <?php namespace spec\\Restaurant ; use Restaurant\\Bill ; use PhpSpec\\ObjectBehavior ; use Prophecy\\Argument ; use Restaurant\\Priced ; class BillSpec extends ObjectBehavior { function let ( Priced $item ) { $item -> price () -> willReturn ( 1000 ); } function it_is_initializable () { $this -> shouldHaveType ( Bill :: class ); } function it_has_no_items_by_default () { $this -> getTotal () -> shouldBe ( 0 ); } function it_adds_an_item ( Priced $item ) { $this -> addItem ( $item ); $this -> getTotal () -> shouldBe ( 1100 ); } function it_adds_multiple_items ( Priced $item , Priced $anotherItem ) { $anotherItem -> price () -> willReturn ( 2000 ); $this -> addItem ( $item ); $this -> addItem ( $anotherItem ); $this -> getTotal () -> shouldBe ( 3300 ); } } Y refactorizamos la clase Bill : <?php declare ( strict_types = 1 ); namespace Restaurant ; class Bill { const VAT = '1.10' ; private $items ; public function __construct () { $this -> items = []; } public function getTotal () : int { return ( int ) ( array_reduce ( $this -> items , function ( $carry , Priced $menu ) { return $carry + $menu -> price (); }, 0 ) * self :: VAT ); } public function addItem ( Priced $item ) : void { $this -> items [] = $item ; } }","title":"Refactorizar Menu"},{"location":"first-scenario/#implementando-los-primeros-steps","text":"Ahora estamos en posici\u00f3n de implementar los primeros steps: Escenario: Ganar puntos al pagar en efectivo Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Quedando el c\u00f3digo en el archivo FeatureContext como sigue: <?php use Behat\\Behat\\Context\\Context ; use Behat\\Behat\\Tester\\Exception\\PendingException ; use Behat\\Gherkin\\Node\\PyStringNode ; use Behat\\Gherkin\\Node\\TableNode ; /** * Defines application features from the specific context. */ class FeatureContext implements Context { private $menus ; private $bill ; /** * Initializes context. * * Every scenario gets its own context instance. * You can also pass arbitrary arguments to the * context constructor through behat.yml. */ public function __construct () { $this -> menus = []; $this -> bill = new \\Restaurant\\Bill (); } /** * @Given los siguientes men\u00fas: */ public function losSiguientesMenus ( TableNode $table ) { foreach ( $table -> getHash () as $menu ) { $this -> menus [ $menu [ 'n\u00famero' ]] = new \\Restaurant\\Menu ( $menu [ 'n\u00famero' ], $menu [ 'precio' ] * 100 ); } } /** * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2 */ public function queHeCompradoMenusDelNumero ( $count , $menuNumber ) { $menu = $this -> menus [ $menuNumber ]; for ( $i = 0 ; $i < $count ; $i ++ ) { $this -> bill -> addItem ( $menu ); } } /** * @When pido la cuenta recibo una factura de :arg1 euros */ public function pidoLaCuentaReciboUnaFacturaDeEuros ( $total ) { \\PHPUnit\\Framework\\Assert :: assertEquals ( $total * 100 , $this -> bill -> getTotal ()); } /** * @When pago en efectivo con :arg1 euros */ public function pagoEnEfectivoConEuros ( $arg1 ) { throw new PendingException (); } /** * @Then la factura est\u00e1 pagada */ public function laFacturaEstaPagada () { throw new PendingException (); } /** * @Then he obtenido :arg1 puntos */ public function heObtenidoPuntos ( $arg1 ) { throw new PendingException (); } /** * @When pago con :arg1 puntos y :arg2 euros */ public function pagoConPuntosYEuros ( $arg1 , $arg2 ) { throw new PendingException (); } /** * @Then quedan :arg1 euros por pagar */ public function quedanEurosPorPagar ( $arg1 ) { throw new PendingException (); } } Y comprobamos que, efectivamente, el c\u00f3digo funciona: bash$ vendor/bin/behat features/menu.feature:16 Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Ganar puntos al pagar en efectivo # features/menu.feature:16 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago en efectivo con 55 euros # FeatureContext::pagoEnEfectivoConEuros() TODO: write pending definition Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 50 puntos # FeatureContext::heObtenidoPuntos() 1 scenario ( 1 pending ) 6 steps ( 3 passed, 1 pending, 2 skipped ) 0m0.02s ( 10 .09Mb )","title":"Implementando los primeros steps"},{"location":"first-scenario/#implementando-el-pago","text":"Para implementar el pago debemos ser capaces de indicar una cantidad pagada en met\u00e1lico, ver cu\u00e1nto queda por pagar y ver cu\u00e1ntos puntos hemos obtenido. Esta ser\u00eda la especificaci\u00f3n: <?php namespace spec\\Restaurant ; use Restaurant\\Bill ; use PhpSpec\\ObjectBehavior ; use Prophecy\\Argument ; use Restaurant\\Priced ; class BillSpec extends ObjectBehavior { function let ( Priced $item ) { $item -> price () -> willReturn ( 1000 ); } function it_is_initializable () { $this -> shouldHaveType ( Bill :: class ); } function it_has_no_items_by_default () { $this -> getTotal () -> shouldBe ( 0 ); } function it_adds_an_item ( Priced $item ) { $this -> addItem ( $item ); $this -> getTotal () -> shouldBe ( 1100 ); } function it_adds_multiple_items ( Priced $item , Priced $anotherItem ) { $anotherItem -> price () -> willReturn ( 2000 ); $this -> addItem ( $item ); $this -> addItem ( $anotherItem ); $this -> getTotal () -> shouldBe ( 3300 ); } function it_can_be_paid_with_money ( Priced $item ) { $this -> addItem ( $item ); $this -> payWithMoney ( 1100 ); $this -> restToPay () -> shouldBe ( 0 ); } function it_can_give_points_when_is_payed_with_money ( Priced $item ) { $this -> addItem ( $item ); $this -> payWithMoney ( 1100 ); $this -> getPoints () -> shouldBe ( 10 ); } function it_can_not_give_points_when_total_is_not_enough ( Priced $anotherItem ) { $anotherItem -> price () -> willReturn ( 99 ); $this -> addItem ( $anotherItem ); $this -> payWithMoney ( 109 ); $this -> getPoints () -> shouldBe ( 0 ); } } Estamos describiendo distintos casos: Cuando se paga exacto y no queda nada por pagar Cuando se pagan justo 10 euros Cuando se pagan menos de 1 euro Podr\u00edamos ser m\u00e1s exhaustivos, como determinar que no se den puntos hasta que no se pague, pero lo dejamos para los casos siguientes. Ejecutamos las pruebas para que phpspec genere los m\u00e9todos en nuestra clase y completamos el c\u00f3digo en la clase Bill : <?php declare ( strict_types = 1 ); namespace Restaurant ; class Bill { const VAT = '1.10' ; private $items ; private $amount ; public function __construct () { $this -> items = []; } public function getTotal () : int { return ( int ) round ( $this -> totalWithoutVAT () * self :: VAT ); } public function addItem ( Priced $item ) : void { $this -> items [] = $item ; } public function payWithMoney ( int $amount ) : void { $this -> amount = $amount ; } public function restToPay () : int { return $this -> getTotal () - $this -> amount ; } public function getPoints () : int { return ( int ) floor ( $this -> totalWithoutVAT () / 100 ); } private function totalWithoutVAT () : int { return array_reduce ( $this -> items , function ( $carry , Priced $priced ) { return $carry + $priced -> price (); }, 0 ); } } Y comprobamos que pasamos las pruebas: bash$ vendor/bin/phpspec run Restaurant \\\\ Bill Restaurant \\B ill 17 \u2714 is initializable 22 \u2714 has no items by default 27 \u2714 adds an item 33 \u2714 adds multiple items 41 \u2714 can be paid with money 48 \u2714 can give points when is payed with money 55 \u2714 can not give points when total is not enough 1 specs 7 examples ( 7 passed ) 172ms Ya nos resta terminar de implementar la historia de usuario. Nuestra clase FeatureContext queda as\u00ed: <?php use Behat\\Behat\\Context\\Context ; use Behat\\Behat\\Tester\\Exception\\PendingException ; use Behat\\Gherkin\\Node\\PyStringNode ; use Behat\\Gherkin\\Node\\TableNode ; /** * Defines application features from the specific context. */ class FeatureContext implements Context { private $menus ; private $bill ; /** * Initializes context. * * Every scenario gets its own context instance. * You can also pass arbitrary arguments to the * context constructor through behat.yml. */ public function __construct () { $this -> menus = []; $this -> bill = new \\Restaurant\\Bill (); } /** * @Given los siguientes men\u00fas: */ public function losSiguientesMenus ( TableNode $table ) { foreach ( $table -> getHash () as $menu ) { $this -> menus [ $menu [ 'n\u00famero' ]] = new \\Restaurant\\Menu ( $menu [ 'n\u00famero' ], $menu [ 'precio' ] * 100 ); } } /** * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2 */ public function queHeCompradoMenusDelNumero ( $count , $menuNumber ) { $menu = $this -> menus [ $menuNumber ]; for ( $i = 0 ; $i < $count ; $i ++ ) { $this -> bill -> addItem ( $menu ); } } /** * @When pido la cuenta recibo una factura de :arg1 euros */ public function pidoLaCuentaReciboUnaFacturaDeEuros ( $total ) { \\PHPUnit\\Framework\\Assert :: assertEquals ( $total * 100 , $this -> bill -> getTotal ()); } /** * @When pago en efectivo con :arg1 euros */ public function pagoEnEfectivoConEuros ( $amount ) { $this -> bill -> payWithMoney ( $amount * 100 ); } /** * @Then la factura est\u00e1 pagada */ public function laFacturaEstaPagada () { \\PHPUnit\\Framework\\Assert :: assertEquals ( 0 , $this -> bill -> restToPay ()); } /** * @Then he obtenido :arg1 puntos */ public function heObtenidoPuntos ( $points ) { \\PHPUnit\\Framework\\Assert :: assertEquals ( $points , $this -> bill -> getPoints ()); } /** * @When pago con :arg1 puntos y :arg2 euros */ public function pagoConPuntosYEuros ( $arg1 , $arg2 ) { throw new PendingException (); } /** * @Then quedan :arg1 euros por pagar */ public function quedanEurosPorPagar ( $arg1 ) { throw new PendingException (); } } Si ejecutamos este primer escenario debemos comprobar que se ha completado con \u00e9xito: bash$ vendor/bin/behat features/menu.feature:16 Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Ganar puntos al pagar en efectivo # features/menu.feature:16 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago en efectivo con 55 euros # FeatureContext::pagoEnEfectivoConEuros() Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 50 puntos # FeatureContext::heObtenidoPuntos() 1 scenario ( 1 passed ) 6 steps ( 6 passed ) 0m0.02s ( 10 .08Mb )","title":"Implementando el pago"},{"location":"fourth-scenario/","text":"Cuarto escenario \u00b6 Vamos a implementar el cuarto escenario Escenario: Intentar pagar el IVA con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 550 puntos y 0 euros Entonces quedan 5 euros por pagar Si ejecutamos la prueba: vendor/bin/behat features/menu.feature:37 Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Intentar pagar el IVA con puntos # features/menu.feature:37 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago con 550 puntos y 0 euros # FeatureContext::pagoConPuntosYEuros() Entonces quedan 5 euros por pagar # FeatureContext::quedanEurosPorPagar() TODO: write pending definition 1 scenario ( 1 pending ) 5 steps ( 4 passed, 1 pending ) 0m0.02s ( 9 .98Mb ) En esta ocasi\u00f3n, las funcionalidades que queremos comprobar ya las tenemos, solo que no con esas sentencias. Vamos a implementar directamente esas sentencias en el FeatureContext y ver si nuestra clase funciona: <?php use Behat\\Behat\\Context\\Context ; use Behat\\Behat\\Tester\\Exception\\PendingException ; use Behat\\Gherkin\\Node\\PyStringNode ; use Behat\\Gherkin\\Node\\TableNode ; /** * Defines application features from the specific context. */ class FeatureContext implements Context { //... /** * @Then quedan :amount euros por pagar */ public function quedanEurosPorPagar ( $amount ) { \\PHPUnit\\Framework\\Assert :: assertEquals ( $amount * 100 , $this -> bill -> restToPay ()); } } Ejecutamos de nuevo la prueba: bash$ vendor/bin/behat features/menu.feature:37 Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Intentar pagar el IVA con puntos # features/menu.feature:37 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago con 550 puntos y 0 euros # FeatureContext::pagoConPuntosYEuros() Entonces quedan 5 euros por pagar # FeatureContext::quedanEurosPorPagar() Failed asserting that 0 matches expected '5' . --- Failed scenarios: features/menu.feature:37 1 scenario ( 1 failed ) 5 steps ( 4 passed, 1 failed ) 0m0.02s ( 10 .20Mb ) El escenario falla porque en la especificaci\u00f3n no hemos indicado que el IVA no se puede pagar con puntos. As\u00ed que creamos una nueva regla en BillSpec para tener en cuenta este comportamiento. <?php namespace spec\\Restaurant ; use Restaurant\\Bill ; use PhpSpec\\ObjectBehavior ; use Prophecy\\Argument ; use Restaurant\\Priced ; class BillSpec extends ObjectBehavior { // ... function it_can_not_pay_VAT_with_points ( Priced $item ) { $this -> addItem ( $item ); $this -> payWithPoints ( 110 ); $this -> restToPay () -> shouldBe ( 100 ); } } Y modificamos nuestra clase Bill para pasar la especificaci\u00f3n: <?php declare ( strict_types = 1 ); namespace Restaurant ; class Bill { const VAT = '1.10' ; private $items ; private $amount ; private $points ; public function __construct () { $this -> items = []; $this -> points = 0 ; $this -> amount = 0 ; } public function getTotal () : int { return ( int ) round ( $this -> totalWithoutVAT () * self :: VAT ); } public function addItem ( Priced $item ) : void { $this -> items [] = $item ; } public function payWithMoney ( int $amount ) : void { $this -> amount = $amount ; } public function restToPay () : int { return $this -> getTotal () - $this -> amount - $this -> getMoneyPoints (); } public function getPoints () : int { if ( $this -> points > 0 ) { return 0 ; } return ( int ) floor ( $this -> totalWithoutVAT () / 100 ); } private function totalWithoutVAT () : int { return array_reduce ( $this -> items , function ( $carry , Priced $priced ) { return $carry + $priced -> price (); }, 0 ); } public function payWithPoints ( int $points ) : void { $this -> points = $points ; } private function getMoneyPoints () : int { $maxMoneyPoints = $this -> totalWithoutVAT (); $moneyPoints = 100 * $this -> points / 10 ; return $moneyPoints > $maxMoneyPoints ? $maxMoneyPoints : $moneyPoints ; } } Y comprobamos que esto consigue que la prueba pase: bash$ vendor/bin/behat features/menu.feature:37 Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Intentar pagar el IVA con puntos # features/menu.feature:37 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago con 550 puntos y 0 euros # FeatureContext::pagoConPuntosYEuros() Entonces quedan 5 euros por pagar # FeatureContext::quedanEurosPorPagar() 1 scenario ( 1 passed ) 5 steps ( 5 passed ) 0m0.02s ( 9 .97Mb )","title":"Cuarto escenario"},{"location":"fourth-scenario/#cuarto-escenario","text":"Vamos a implementar el cuarto escenario Escenario: Intentar pagar el IVA con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 550 puntos y 0 euros Entonces quedan 5 euros por pagar Si ejecutamos la prueba: vendor/bin/behat features/menu.feature:37 Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Intentar pagar el IVA con puntos # features/menu.feature:37 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago con 550 puntos y 0 euros # FeatureContext::pagoConPuntosYEuros() Entonces quedan 5 euros por pagar # FeatureContext::quedanEurosPorPagar() TODO: write pending definition 1 scenario ( 1 pending ) 5 steps ( 4 passed, 1 pending ) 0m0.02s ( 9 .98Mb ) En esta ocasi\u00f3n, las funcionalidades que queremos comprobar ya las tenemos, solo que no con esas sentencias. Vamos a implementar directamente esas sentencias en el FeatureContext y ver si nuestra clase funciona: <?php use Behat\\Behat\\Context\\Context ; use Behat\\Behat\\Tester\\Exception\\PendingException ; use Behat\\Gherkin\\Node\\PyStringNode ; use Behat\\Gherkin\\Node\\TableNode ; /** * Defines application features from the specific context. */ class FeatureContext implements Context { //... /** * @Then quedan :amount euros por pagar */ public function quedanEurosPorPagar ( $amount ) { \\PHPUnit\\Framework\\Assert :: assertEquals ( $amount * 100 , $this -> bill -> restToPay ()); } } Ejecutamos de nuevo la prueba: bash$ vendor/bin/behat features/menu.feature:37 Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Intentar pagar el IVA con puntos # features/menu.feature:37 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago con 550 puntos y 0 euros # FeatureContext::pagoConPuntosYEuros() Entonces quedan 5 euros por pagar # FeatureContext::quedanEurosPorPagar() Failed asserting that 0 matches expected '5' . --- Failed scenarios: features/menu.feature:37 1 scenario ( 1 failed ) 5 steps ( 4 passed, 1 failed ) 0m0.02s ( 10 .20Mb ) El escenario falla porque en la especificaci\u00f3n no hemos indicado que el IVA no se puede pagar con puntos. As\u00ed que creamos una nueva regla en BillSpec para tener en cuenta este comportamiento. <?php namespace spec\\Restaurant ; use Restaurant\\Bill ; use PhpSpec\\ObjectBehavior ; use Prophecy\\Argument ; use Restaurant\\Priced ; class BillSpec extends ObjectBehavior { // ... function it_can_not_pay_VAT_with_points ( Priced $item ) { $this -> addItem ( $item ); $this -> payWithPoints ( 110 ); $this -> restToPay () -> shouldBe ( 100 ); } } Y modificamos nuestra clase Bill para pasar la especificaci\u00f3n: <?php declare ( strict_types = 1 ); namespace Restaurant ; class Bill { const VAT = '1.10' ; private $items ; private $amount ; private $points ; public function __construct () { $this -> items = []; $this -> points = 0 ; $this -> amount = 0 ; } public function getTotal () : int { return ( int ) round ( $this -> totalWithoutVAT () * self :: VAT ); } public function addItem ( Priced $item ) : void { $this -> items [] = $item ; } public function payWithMoney ( int $amount ) : void { $this -> amount = $amount ; } public function restToPay () : int { return $this -> getTotal () - $this -> amount - $this -> getMoneyPoints (); } public function getPoints () : int { if ( $this -> points > 0 ) { return 0 ; } return ( int ) floor ( $this -> totalWithoutVAT () / 100 ); } private function totalWithoutVAT () : int { return array_reduce ( $this -> items , function ( $carry , Priced $priced ) { return $carry + $priced -> price (); }, 0 ); } public function payWithPoints ( int $points ) : void { $this -> points = $points ; } private function getMoneyPoints () : int { $maxMoneyPoints = $this -> totalWithoutVAT (); $moneyPoints = 100 * $this -> points / 10 ; return $moneyPoints > $maxMoneyPoints ? $maxMoneyPoints : $moneyPoints ; } } Y comprobamos que esto consigue que la prueba pase: bash$ vendor/bin/behat features/menu.feature:37 Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Intentar pagar el IVA con puntos # features/menu.feature:37 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago con 550 puntos y 0 euros # FeatureContext::pagoConPuntosYEuros() Entonces quedan 5 euros por pagar # FeatureContext::quedanEurosPorPagar() 1 scenario ( 1 passed ) 5 steps ( 5 passed ) 0m0.02s ( 9 .97Mb )","title":"Cuarto escenario"},{"location":"introduction/","text":"Introducci\u00f3n \u00b6 Desarrollo orientado a pruebas (TDD) \u00b6 Test Driven Development (TDD), o desarrollo orientado a pruebas, es un proceso de desarrollo de software muy conocido, que consiste en la repetici\u00f3n de ciclos de desarrollo muy cortos. Los requisitos se convierten en pruebas, unidades de c\u00f3digo que prueban una determinada funcionalidad. Entonces, se produce el c\u00f3digo justo que permite pasar dicha prueba. Este proceso es opuesto a otros sistemas de desarrollo que permiten incorporar c\u00f3digo que no se sabe con certeza si concuerdan o no con los requisitos. Los test que se pueden realizar pueden ser de unidad, funcionales y de aceptaci\u00f3n. Para todos estos tipos de test, en PHP podemos usar PHPUnit. Ciclo del desarrollo orientado a pruebas \u00b6 A\u00f1ade un test Ejecuta los test y comprueba que el nuevo test falla Escribe el c\u00f3digo Ejecuta los test Refactoriza el c\u00f3digo Repite Ejemplo de un test de unidad con PHPUnit \u00b6 Si queremos implementar una clase que implemente funciones matem\u00e1ticas, este ser\u00eda el c\u00f3digo de una prueba unitaria que, con PHPUnit, escribir\u00edamos para implementar la funcionalidad suma : <?php use PHPUnit\\Framework\\TestCase ; class CalculatorTest extends TestCase { public function testAdd () { $calculator = new Calculator (); $result = $calculator -> add ( 3 , 2 ); $this -> assertEquals ( 5 , $result ); } } Solo cuando tengamos el test escrito podremos desarrollar el c\u00f3digo: <?php class Calculator { public function add ( int $a , int $b ) : int { return $a + $b ; } } Las tres reglas \u00b6 Robert Martin, en su libro \"Clean Code. A Handbook of agile software craftsmanship\", especifica las tres reglas que deben seguirse cuando se desarrolla con TDD: No debes escribir c\u00f3digo de producci\u00f3n hasta que hayas escrito una prueba unitaria que falle. No debes escribir m\u00e1s de una prueba unitaria que sea suficiente para fallar y el sistema no compile. No debes escribir m\u00e1s c\u00f3digo de producci\u00f3n que el suficiente para superar la prueba que est\u00e9 fallando actualmente. Desarrollo orientado a comportamiento (BDD) \u00b6 Behaviour Driven Development (BDD), o desarrollo orientado a comportamiento, es un proceso de desarrollo similar a TDD, solo que con BDD lo que se realiza es definir el comportamiento y las especificaciones, al contrario que con TDD que se limita solamente a comprobar funcionalidades. Los test que se pueden realizar pueden ser de unidad, funcionales y de aceptaci\u00f3n. Para los test de unidad el software m\u00e1s apropiado en PhpSpec y para el resto Behat. Ciclo del desarrollo orientado a comportamiento \u00b6 Describe el comportamiento del software a trav\u00e9s de pruebas Ejecuta los test y comprueba que el nuevo test falla Implementa el nuevo comportamiento Ejecuta los test Mejora el c\u00f3digo Repite Ejemplo de un test de unidad con PHPSpec \u00b6 Si usamos el ejemplo de la calculadora, esta ser\u00eda la forma de describir el comportamiento de la calculadora: <?php use PhpSpec\\ObjectBehavior ; class CalculatorSpec extends ObjectBehavior { function it_is_initializable () { $this -> shouldHaveType ( Calculator :: class ); } function it_adds_to_numbers () { $this -> add ( 2 , 3 ) -> shouldReturn ( 5 ); } } Las diferencias principales con PHPUnit son dos: El nombre de la funci\u00f3n describe el comportamiento a implementar. Debe empezar por it_ o its_ . No es necesario instanciar la clase que queremos probar. La clase CalculatorSpec adquiere los m\u00e9todos de la clase que estamos describiendo. Hay muchas m\u00e1s diferencias, pero a grandes rasgos nos vamos a quedar con esas dos. Ejemplo de un test con Behat \u00b6 Behat utiliza un lenguaje llamado Gherkin para describir historias de usuario. Es m\u00e1s apropiado para hacer test de aceptaci\u00f3n. Este ser\u00eda un ejemplo de un test de aceptaci\u00f3n con Gherkin: Caracter\u00edstica: Crear una calculadora Escenario: Sumar dos n\u00fameros Dado que quiero sumar dos n\u00fameros Cuando introduzco el n\u00famero 2 E introduzco el n\u00famero 3 Entonces recibo el n\u00famero 5 Esta prueba es una simplificaci\u00f3n de lo que permite hacer Gherkin. La forma en c\u00f3mo se ejecuta e implementa este tipo de test lo veremos m\u00e1s adelante.","title":"Introducci\u00f3n"},{"location":"introduction/#introduccion","text":"","title":"Introducci\u00f3n"},{"location":"introduction/#desarrollo-orientado-a-pruebas-tdd","text":"Test Driven Development (TDD), o desarrollo orientado a pruebas, es un proceso de desarrollo de software muy conocido, que consiste en la repetici\u00f3n de ciclos de desarrollo muy cortos. Los requisitos se convierten en pruebas, unidades de c\u00f3digo que prueban una determinada funcionalidad. Entonces, se produce el c\u00f3digo justo que permite pasar dicha prueba. Este proceso es opuesto a otros sistemas de desarrollo que permiten incorporar c\u00f3digo que no se sabe con certeza si concuerdan o no con los requisitos. Los test que se pueden realizar pueden ser de unidad, funcionales y de aceptaci\u00f3n. Para todos estos tipos de test, en PHP podemos usar PHPUnit.","title":"Desarrollo orientado a pruebas (TDD)"},{"location":"introduction/#ciclo-del-desarrollo-orientado-a-pruebas","text":"A\u00f1ade un test Ejecuta los test y comprueba que el nuevo test falla Escribe el c\u00f3digo Ejecuta los test Refactoriza el c\u00f3digo Repite","title":"Ciclo del desarrollo orientado a pruebas"},{"location":"introduction/#ejemplo-de-un-test-de-unidad-con-phpunit","text":"Si queremos implementar una clase que implemente funciones matem\u00e1ticas, este ser\u00eda el c\u00f3digo de una prueba unitaria que, con PHPUnit, escribir\u00edamos para implementar la funcionalidad suma : <?php use PHPUnit\\Framework\\TestCase ; class CalculatorTest extends TestCase { public function testAdd () { $calculator = new Calculator (); $result = $calculator -> add ( 3 , 2 ); $this -> assertEquals ( 5 , $result ); } } Solo cuando tengamos el test escrito podremos desarrollar el c\u00f3digo: <?php class Calculator { public function add ( int $a , int $b ) : int { return $a + $b ; } }","title":"Ejemplo de un test de unidad con PHPUnit"},{"location":"introduction/#las-tres-reglas","text":"Robert Martin, en su libro \"Clean Code. A Handbook of agile software craftsmanship\", especifica las tres reglas que deben seguirse cuando se desarrolla con TDD: No debes escribir c\u00f3digo de producci\u00f3n hasta que hayas escrito una prueba unitaria que falle. No debes escribir m\u00e1s de una prueba unitaria que sea suficiente para fallar y el sistema no compile. No debes escribir m\u00e1s c\u00f3digo de producci\u00f3n que el suficiente para superar la prueba que est\u00e9 fallando actualmente.","title":"Las tres reglas"},{"location":"introduction/#desarrollo-orientado-a-comportamiento-bdd","text":"Behaviour Driven Development (BDD), o desarrollo orientado a comportamiento, es un proceso de desarrollo similar a TDD, solo que con BDD lo que se realiza es definir el comportamiento y las especificaciones, al contrario que con TDD que se limita solamente a comprobar funcionalidades. Los test que se pueden realizar pueden ser de unidad, funcionales y de aceptaci\u00f3n. Para los test de unidad el software m\u00e1s apropiado en PhpSpec y para el resto Behat.","title":"Desarrollo orientado a comportamiento (BDD)"},{"location":"introduction/#ciclo-del-desarrollo-orientado-a-comportamiento","text":"Describe el comportamiento del software a trav\u00e9s de pruebas Ejecuta los test y comprueba que el nuevo test falla Implementa el nuevo comportamiento Ejecuta los test Mejora el c\u00f3digo Repite","title":"Ciclo del desarrollo orientado a comportamiento"},{"location":"introduction/#ejemplo-de-un-test-de-unidad-con-phpspec","text":"Si usamos el ejemplo de la calculadora, esta ser\u00eda la forma de describir el comportamiento de la calculadora: <?php use PhpSpec\\ObjectBehavior ; class CalculatorSpec extends ObjectBehavior { function it_is_initializable () { $this -> shouldHaveType ( Calculator :: class ); } function it_adds_to_numbers () { $this -> add ( 2 , 3 ) -> shouldReturn ( 5 ); } } Las diferencias principales con PHPUnit son dos: El nombre de la funci\u00f3n describe el comportamiento a implementar. Debe empezar por it_ o its_ . No es necesario instanciar la clase que queremos probar. La clase CalculatorSpec adquiere los m\u00e9todos de la clase que estamos describiendo. Hay muchas m\u00e1s diferencias, pero a grandes rasgos nos vamos a quedar con esas dos.","title":"Ejemplo de un test de unidad con PHPSpec"},{"location":"introduction/#ejemplo-de-un-test-con-behat","text":"Behat utiliza un lenguaje llamado Gherkin para describir historias de usuario. Es m\u00e1s apropiado para hacer test de aceptaci\u00f3n. Este ser\u00eda un ejemplo de un test de aceptaci\u00f3n con Gherkin: Caracter\u00edstica: Crear una calculadora Escenario: Sumar dos n\u00fameros Dado que quiero sumar dos n\u00fameros Cuando introduzco el n\u00famero 2 E introduzco el n\u00famero 3 Entonces recibo el n\u00famero 5 Esta prueba es una simplificaci\u00f3n de lo que permite hacer Gherkin. La forma en c\u00f3mo se ejecuta e implementa este tipo de test lo veremos m\u00e1s adelante.","title":"Ejemplo de un test con Behat"},{"location":"modelling/","text":"Modelando con ejemplos \u00b6 Captura de requisitos \u00b6 Imaginemos que queremos crear un sistema de fidelizaci\u00f3n de clientes de un restaurante, d\u00e1ndoles una serie de puntos que le permitan obtener descuentos en sucesivas visitas. Cuando usamos reglas para la captura de requisitos, corremos el riesgo de ser ambiguos. Por ejemplo, veamos que ocurre cuando especificamos solo con reglas: Example RF01 : Los clientes obtienen un punto por cada euro gastado en un men\u00fa. RF02 : Diez puntos pueden ser canjeados por un euro de descuento al pagar un men\u00fa. RF03 : El IVA es del 10%. El problema es que nos surgen una serie de dudas que estas reglas no resuelven: \u00bfSi gasto puntos a\u00fan puedo ganar puntos? \u00bfPuedo gastar m\u00e1s de diez puntos en un solo men\u00fa? \u00bfEl IVA se aplica al precio descontado o al total? Si modelamos los requisitos con ejemplos obtenemos esto: Example Si un men\u00fa para una familia de cinco personas cuesta 50 euros: Si pagan en efectivo pagar\u00e1n 50\u20ac m\u00e1s 5\u20ac de IVA y obtendr\u00e1n 50 puntos. Si pagan con 10 puntos, costar\u00e1 10 puntos y 49\u20ac + 5\u20ac de IVA y obtendr\u00e1n 0 puntos. Si pagan solo con puntos, entregar\u00e1n 500 puntos + 5\u20ac de IVA y obtendr\u00e1n 0 puntos. Evidentemente el ejemplo cuenta con pocas reglas, pero lo que se quiere hacer notar es que es relativamente sencillo llegar a ambig\u00fcedades que con los ejemplos no obtendr\u00edamos. Por ello, en UML contamos con los casos de uso, que es una forma de captura de requisitos funcionales que permite evitar este tipo de problemas. Nos vamos a ahorrar la parte de crear los casos de uso y vamos ir directamente a crear las historias de usuario con Gherkin. Gherkin \u00b6 Gherkin es un lenguaje que permite describir el comportamiento del software sin entrar en detalles de c\u00f3mo se ha implementado dicho comportamiento. Cada caracter\u00edstica que se define con gherkin debe ir en un fichero con extensi\u00f3n .feature . A continuaci\u00f3n se puede ver una plantilla de ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # language: es Caracter\u00edstica: Internal operations In order to stay secret As a secret organization We need to be able to erase past agents' memory Antecedentes: [Dados|Dadas|Dada|Dado|*] there is agent A [*|Y|E] there is agent B Escenario: Erasing agent memory [Dados|Dadas|Dada|Dado|*] there is agent J [*|Y|E] there is agent K [Cuando|*] I erase agent K's memory [Entonces|*] there should be agent J [Pero|*] there should not be agent K Esquema del escenario: Erasing other agents' memory [Dados|Dadas|Dada|Dado|*] there is agent &lt;agent1&gt; [*|Y|E] there is agent &lt;agent2&gt; [Cuando|*] I erase agent &lt;agent2&gt;'s memory [Entonces|*] there should be agent &lt;agent1&gt; [Pero|*] there should not be agent &lt;agent2&gt; Ejemplos: | agent1 | agent2 | | D | M | Las palabras entre [ ] indican una entre las posibles. Para ver el formato en ingl\u00e9s lee la documentaci\u00f3n oficial. Introducci\u00f3n de la caracter\u00edstica \u00b6 Cada archivo .feature consiste convencionalmente en una \u00fanica caracter\u00edstica. Una l\u00ednea que comienza con la palabra clave Caracter\u00edstica seguida de texto tabulado que la describe. Una caracter\u00edstica generalmente contiene una lista de escenarios y unos antecedentes. Cada escenario consiste en una lista de pasos, que debe comenzar con una de las palabras clave indicadas en la plantilla. Los antecedentes son datos disponibles antes de cada prueba. Lo habitual es resetear el estado de la aplicaci\u00f3n para que al comienzo de cada escenario est\u00e9 tal y como indican los antecedentes. Los escenarios son las caracter\u00edsticas que deben ser implementadas y se componen de tres secciones: \" Dado unos antecedentes\": Permiten establecer un estado de la aplicaci\u00f3n espec\u00edfico para esta prueba. \" Cuando \" ocurre o se realiza una acci\u00f3n: Aqu\u00ed es donde se prueba la caracter\u00edstica a programar. \" Entonces \" ocurre una consecuencia: Aqu\u00ed es donde se comprueba que la caracter\u00edstica funciona correctamente. Se pueden concatenar sentencias con las palabras Y , E y PERO , tal y como se ve en la plantilla. Creando los escenarios \u00b6 Vamos a describir un posible archivo gherkin para nuestro ejemplo del restaurante: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #language: es Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10% Antecedentes: Dados los siguientes men\u00fas: | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Ganar puntos al pagar en efectivo Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Escenario: Pagar con dinero y puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 10 puntos y 54 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Escenario: Pagar con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 500 puntos y 5 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Escenario: Intentar pagar el IVA con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 550 puntos y 0 euros Entonces quedan 5 euros por pagar Escenario: Comprar men\u00fas de varios tipos Dado que he comprado 1 men\u00fa del n\u00famero 1 Y que he comprado 2 men\u00fas del n\u00famero 2 Y que he comprado 2 men\u00fas del n\u00famero 3 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos El anterior archivo describe las caracter\u00edsticas, en un lenguaje de negocio, de las caracter\u00edsticas del software que debemos implementar. En los siguientes cap\u00edtulos iremos implementando el proyecto paso a paso.","title":"Modelando con ejemplos"},{"location":"modelling/#modelando-con-ejemplos","text":"","title":"Modelando con ejemplos"},{"location":"modelling/#captura-de-requisitos","text":"Imaginemos que queremos crear un sistema de fidelizaci\u00f3n de clientes de un restaurante, d\u00e1ndoles una serie de puntos que le permitan obtener descuentos en sucesivas visitas. Cuando usamos reglas para la captura de requisitos, corremos el riesgo de ser ambiguos. Por ejemplo, veamos que ocurre cuando especificamos solo con reglas: Example RF01 : Los clientes obtienen un punto por cada euro gastado en un men\u00fa. RF02 : Diez puntos pueden ser canjeados por un euro de descuento al pagar un men\u00fa. RF03 : El IVA es del 10%. El problema es que nos surgen una serie de dudas que estas reglas no resuelven: \u00bfSi gasto puntos a\u00fan puedo ganar puntos? \u00bfPuedo gastar m\u00e1s de diez puntos en un solo men\u00fa? \u00bfEl IVA se aplica al precio descontado o al total? Si modelamos los requisitos con ejemplos obtenemos esto: Example Si un men\u00fa para una familia de cinco personas cuesta 50 euros: Si pagan en efectivo pagar\u00e1n 50\u20ac m\u00e1s 5\u20ac de IVA y obtendr\u00e1n 50 puntos. Si pagan con 10 puntos, costar\u00e1 10 puntos y 49\u20ac + 5\u20ac de IVA y obtendr\u00e1n 0 puntos. Si pagan solo con puntos, entregar\u00e1n 500 puntos + 5\u20ac de IVA y obtendr\u00e1n 0 puntos. Evidentemente el ejemplo cuenta con pocas reglas, pero lo que se quiere hacer notar es que es relativamente sencillo llegar a ambig\u00fcedades que con los ejemplos no obtendr\u00edamos. Por ello, en UML contamos con los casos de uso, que es una forma de captura de requisitos funcionales que permite evitar este tipo de problemas. Nos vamos a ahorrar la parte de crear los casos de uso y vamos ir directamente a crear las historias de usuario con Gherkin.","title":"Captura de requisitos"},{"location":"modelling/#gherkin","text":"Gherkin es un lenguaje que permite describir el comportamiento del software sin entrar en detalles de c\u00f3mo se ha implementado dicho comportamiento. Cada caracter\u00edstica que se define con gherkin debe ir en un fichero con extensi\u00f3n .feature . A continuaci\u00f3n se puede ver una plantilla de ejemplo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # language: es Caracter\u00edstica: Internal operations In order to stay secret As a secret organization We need to be able to erase past agents' memory Antecedentes: [Dados|Dadas|Dada|Dado|*] there is agent A [*|Y|E] there is agent B Escenario: Erasing agent memory [Dados|Dadas|Dada|Dado|*] there is agent J [*|Y|E] there is agent K [Cuando|*] I erase agent K's memory [Entonces|*] there should be agent J [Pero|*] there should not be agent K Esquema del escenario: Erasing other agents' memory [Dados|Dadas|Dada|Dado|*] there is agent &lt;agent1&gt; [*|Y|E] there is agent &lt;agent2&gt; [Cuando|*] I erase agent &lt;agent2&gt;'s memory [Entonces|*] there should be agent &lt;agent1&gt; [Pero|*] there should not be agent &lt;agent2&gt; Ejemplos: | agent1 | agent2 | | D | M | Las palabras entre [ ] indican una entre las posibles. Para ver el formato en ingl\u00e9s lee la documentaci\u00f3n oficial.","title":"Gherkin"},{"location":"modelling/#introduccion-de-la-caracteristica","text":"Cada archivo .feature consiste convencionalmente en una \u00fanica caracter\u00edstica. Una l\u00ednea que comienza con la palabra clave Caracter\u00edstica seguida de texto tabulado que la describe. Una caracter\u00edstica generalmente contiene una lista de escenarios y unos antecedentes. Cada escenario consiste en una lista de pasos, que debe comenzar con una de las palabras clave indicadas en la plantilla. Los antecedentes son datos disponibles antes de cada prueba. Lo habitual es resetear el estado de la aplicaci\u00f3n para que al comienzo de cada escenario est\u00e9 tal y como indican los antecedentes. Los escenarios son las caracter\u00edsticas que deben ser implementadas y se componen de tres secciones: \" Dado unos antecedentes\": Permiten establecer un estado de la aplicaci\u00f3n espec\u00edfico para esta prueba. \" Cuando \" ocurre o se realiza una acci\u00f3n: Aqu\u00ed es donde se prueba la caracter\u00edstica a programar. \" Entonces \" ocurre una consecuencia: Aqu\u00ed es donde se comprueba que la caracter\u00edstica funciona correctamente. Se pueden concatenar sentencias con las palabras Y , E y PERO , tal y como se ve en la plantilla.","title":"Introducci\u00f3n de la caracter\u00edstica"},{"location":"modelling/#creando-los-escenarios","text":"Vamos a describir un posible archivo gherkin para nuestro ejemplo del restaurante: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #language: es Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10% Antecedentes: Dados los siguientes men\u00fas: | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Ganar puntos al pagar en efectivo Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Escenario: Pagar con dinero y puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 10 puntos y 54 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Escenario: Pagar con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 500 puntos y 5 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Escenario: Intentar pagar el IVA con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 550 puntos y 0 euros Entonces quedan 5 euros por pagar Escenario: Comprar men\u00fas de varios tipos Dado que he comprado 1 men\u00fa del n\u00famero 1 Y que he comprado 2 men\u00fas del n\u00famero 2 Y que he comprado 2 men\u00fas del n\u00famero 3 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos El anterior archivo describe las caracter\u00edsticas, en un lenguaje de negocio, de las caracter\u00edsticas del software que debemos implementar. En los siguientes cap\u00edtulos iremos implementando el proyecto paso a paso.","title":"Creando los escenarios"},{"location":"second-scenario/","text":"Segundo escenario \u00b6 Vamos a implementar ahora el segundo escenario Escenario: Pagar con dinero y puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 10 puntos y 54 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Si intentamos ejecutar la prueba directamente vemos que hay ya muchos pasos que pasan: vendor/bin/behat features/menu.feature:23 Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Pagar con dinero y puntos # features/menu.feature:23 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago con 10 puntos y 54 euros # FeatureContext::pagoConPuntosYEuros() TODO: write pending definition Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 0 puntos # FeatureContext::heObtenidoPuntos() 1 scenario ( 1 pending ) 6 steps ( 3 passed, 1 pending, 2 skipped ) 0m0.02s ( 9 .98Mb ) Solo tenemos que implementar el pago con puntos. Describir la funcionalidad \u00b6 El primer paso, es escribir la descripci\u00f3n en nuestra especificaci\u00f3n de la clase Bill : <?php namespace spec\\Restaurant ; use Restaurant\\Bill ; use PhpSpec\\ObjectBehavior ; use Prophecy\\Argument ; use Restaurant\\Priced ; class BillSpec extends ObjectBehavior { // ... function it_can_be_paith_with_money_and_points_and_get_no_points ( Priced $item ) { $this -> addItem ( $item ); $this -> payWithMoney ( 1000 ); $this -> payWithPoints ( 10 ); $this -> restToPay () -> shouldBe ( 0 ); $this -> getPoints () -> shouldBe ( 0 ); } } De nuevo, ejecutamos las pruebas de phpspec para que se generen los m\u00e9todos necesarios en nuestra clase Bill y refactorizamos nuestro c\u00f3digo para pasar la prueba: <?php declare ( strict_types = 1 ); namespace Restaurant ; class Bill { const VAT = '1.10' ; private $items ; private $amount ; private $points ; public function __construct () { $this -> items = []; $this -> points = 0 ; $this -> amount = 0 ; } public function getTotal () : int { return ( int ) round ( $this -> totalWithoutVAT () * self :: VAT ); } public function addItem ( Priced $item ) : void { $this -> items [] = $item ; } public function payWithMoney ( int $amount ) : void { $this -> amount = $amount ; } public function restToPay () : int { return $this -> getTotal () - $this -> amount - $this -> getMoneyPoints (); } public function getPoints () : int { if ( $this -> points > 0 ) { return 0 ; } return ( int ) floor ( $this -> totalWithoutVAT () / 100 ); } private function totalWithoutVAT () : int { return array_reduce ( $this -> items , function ( $carry , Priced $priced ) { return $carry + $priced -> price (); }, 0 ); } public function payWithPoints ( int $points ) : void { $this -> points = $points ; } private function getMoneyPoints () : int { return 100 * ( $this -> points / 10 ); } } Comprobamos que pasamos las pruebas y pasamos a implementar la historia de usuario. Completando la historia de usuario \u00b6 Creamos el c\u00f3digo que implementa el paso que nos falta: <?php use Behat\\Behat\\Context\\Context ; use Behat\\Behat\\Tester\\Exception\\PendingException ; use Behat\\Gherkin\\Node\\PyStringNode ; use Behat\\Gherkin\\Node\\TableNode ; /** * Defines application features from the specific context. */ class FeatureContext implements Context { // ... /** * @When pago con :points puntos y :money euros */ public function pagoConPuntosYEuros ( $points , $money ) { $this -> bill -> payWithMoney ( $money * 100 ); $this -> bill -> payWithPoints ( $points ); } } Y ya hemos conseguido terminar otro escenario: vendor/bin/behat features/menu.feature:23 Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Pagar con dinero y puntos # features/menu.feature:23 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago con 10 puntos y 54 euros # FeatureContext::pagoConPuntosYEuros() Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 0 puntos # FeatureContext::heObtenidoPuntos() 1 scenario ( 1 passed ) 6 steps ( 6 passed ) 0m0.02s ( 10 .09Mb ) Conclusiones \u00b6 Como vamos viendo, el c\u00f3digo que se genera en phpspec es realmente el c\u00f3digo que implementa nuestras reglas de negocio. En behat solo implementamos c\u00f3digo para poder usar el dominio en las pruebas y comprobar que nuestras dos clases ( Menu y Bill ) trabajan bien juntas.","title":"Segundo escenario"},{"location":"second-scenario/#segundo-escenario","text":"Vamos a implementar ahora el segundo escenario Escenario: Pagar con dinero y puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 10 puntos y 54 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Si intentamos ejecutar la prueba directamente vemos que hay ya muchos pasos que pasan: vendor/bin/behat features/menu.feature:23 Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Pagar con dinero y puntos # features/menu.feature:23 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago con 10 puntos y 54 euros # FeatureContext::pagoConPuntosYEuros() TODO: write pending definition Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 0 puntos # FeatureContext::heObtenidoPuntos() 1 scenario ( 1 pending ) 6 steps ( 3 passed, 1 pending, 2 skipped ) 0m0.02s ( 9 .98Mb ) Solo tenemos que implementar el pago con puntos.","title":"Segundo escenario"},{"location":"second-scenario/#describir-la-funcionalidad","text":"El primer paso, es escribir la descripci\u00f3n en nuestra especificaci\u00f3n de la clase Bill : <?php namespace spec\\Restaurant ; use Restaurant\\Bill ; use PhpSpec\\ObjectBehavior ; use Prophecy\\Argument ; use Restaurant\\Priced ; class BillSpec extends ObjectBehavior { // ... function it_can_be_paith_with_money_and_points_and_get_no_points ( Priced $item ) { $this -> addItem ( $item ); $this -> payWithMoney ( 1000 ); $this -> payWithPoints ( 10 ); $this -> restToPay () -> shouldBe ( 0 ); $this -> getPoints () -> shouldBe ( 0 ); } } De nuevo, ejecutamos las pruebas de phpspec para que se generen los m\u00e9todos necesarios en nuestra clase Bill y refactorizamos nuestro c\u00f3digo para pasar la prueba: <?php declare ( strict_types = 1 ); namespace Restaurant ; class Bill { const VAT = '1.10' ; private $items ; private $amount ; private $points ; public function __construct () { $this -> items = []; $this -> points = 0 ; $this -> amount = 0 ; } public function getTotal () : int { return ( int ) round ( $this -> totalWithoutVAT () * self :: VAT ); } public function addItem ( Priced $item ) : void { $this -> items [] = $item ; } public function payWithMoney ( int $amount ) : void { $this -> amount = $amount ; } public function restToPay () : int { return $this -> getTotal () - $this -> amount - $this -> getMoneyPoints (); } public function getPoints () : int { if ( $this -> points > 0 ) { return 0 ; } return ( int ) floor ( $this -> totalWithoutVAT () / 100 ); } private function totalWithoutVAT () : int { return array_reduce ( $this -> items , function ( $carry , Priced $priced ) { return $carry + $priced -> price (); }, 0 ); } public function payWithPoints ( int $points ) : void { $this -> points = $points ; } private function getMoneyPoints () : int { return 100 * ( $this -> points / 10 ); } } Comprobamos que pasamos las pruebas y pasamos a implementar la historia de usuario.","title":"Describir la funcionalidad"},{"location":"second-scenario/#completando-la-historia-de-usuario","text":"Creamos el c\u00f3digo que implementa el paso que nos falta: <?php use Behat\\Behat\\Context\\Context ; use Behat\\Behat\\Tester\\Exception\\PendingException ; use Behat\\Gherkin\\Node\\PyStringNode ; use Behat\\Gherkin\\Node\\TableNode ; /** * Defines application features from the specific context. */ class FeatureContext implements Context { // ... /** * @When pago con :points puntos y :money euros */ public function pagoConPuntosYEuros ( $points , $money ) { $this -> bill -> payWithMoney ( $money * 100 ); $this -> bill -> payWithPoints ( $points ); } } Y ya hemos conseguido terminar otro escenario: vendor/bin/behat features/menu.feature:23 Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Pagar con dinero y puntos # features/menu.feature:23 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago con 10 puntos y 54 euros # FeatureContext::pagoConPuntosYEuros() Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 0 puntos # FeatureContext::heObtenidoPuntos() 1 scenario ( 1 passed ) 6 steps ( 6 passed ) 0m0.02s ( 10 .09Mb )","title":"Completando la historia de usuario"},{"location":"second-scenario/#conclusiones","text":"Como vamos viendo, el c\u00f3digo que se genera en phpspec es realmente el c\u00f3digo que implementa nuestras reglas de negocio. En behat solo implementamos c\u00f3digo para poder usar el dominio en las pruebas y comprobar que nuestras dos clases ( Menu y Bill ) trabajan bien juntas.","title":"Conclusiones"},{"location":"start-project/","text":"Crear el proyecto \u00b6 Vamos a implementar el proyecto que implemente las caracter\u00edsticas descritas en el apartado anterior. Vamos a hacer uso de un esqueleto que ya tiene configurado: composer create aulasoftwarelibre/bdd-by-example Se nos crear\u00e1 un directorio con todo lo que necesitamos para empezar a trabajar. Si analizamos el fichero composer.json veremos las dependencias de nuestro proyecto: { \"require-dev\" : { \"behat/behat\" : \"^3.4\" , \"phpspec/phpspec\" : \"^5.0\" , \"phpunit/phpunit\" : \"^7.0\" } } Creaci\u00f3n de caracter\u00edsticas \u00b6 Las caracter\u00edsticas (ficheros .feature ) deben ir dentro del directorio features/ de nuestro proyecto. Tip Las cajas de ejemplo tienen un icono que, si lo pulsas, permiten copiar el contenido al portapapeles. \u00dasalo para ir m\u00e1s r\u00e1pido al copiar el c\u00f3digo. Crearemos dentro de dicho directorio un fichero llamado menu.feature con el contenido que describimos en el cap\u00edtulo anterior. #language: es Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10% Antecedentes: Dados los siguientes men\u00fas: | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Ganar puntos al pagar en efectivo Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Escenario: Pagar con dinero y puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 10 puntos y 54 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Escenario: Pagar con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 500 puntos y 5 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Escenario: Intentar pagar el IVA con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 550 puntos y 0 euros Entonces quedan 5 euros por pagar Escenario: Comprar men\u00fas de varios tipos Dado que he comprado 1 men\u00fa del n\u00famero 1 Y que he comprado 2 men\u00fas del n\u00famero 2 Y que he comprado 2 men\u00fas del n\u00famero 3 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Ejecuci\u00f3n de behat \u00b6 Ahora que tenemos las pruebas definidas vamos a ejecutar behat : vendor/bin/behat --snippets-for FeatureContext Obtendremos el resumen de la ejecuci\u00f3n de pruebas que contiene la siguiente informaci\u00f3n: 5 scenarios ( 5 undefined ) 32 steps ( 32 undefined ) 0m0.02s ( 9 .49Mb ) Lo que significa es que behat no reconoce ninguno de los step o pasos de los que se compone cada escenario. Esa parte debemos programarla nosotros. Para ello behat nos facilita el trabajo con una serie de snippets . Veamos uno: <?php /** * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2 */ public function queHeCompradoMenusDelNumero ( $arg1 , $arg2 ) { throw new PendingException (); } El step se compone de una cabecera con las palabras @Given , @When o @Then y una frase que coincide con la que hayamos determinado en el paso. Los n\u00fameros y las cadenas que se pongan entre comillas se convierten en par\u00e1metros del paso. Tambi\u00e9n es posible usar expresiones regulares, pero en esos casos debemos hacerlo a mano. El objetivo es meter todos estos snippets en el archivo de contexto que usa Behat . Si editamos el archivo features/bootstrap/FeatureContext.php , veremos el archivo de contexto por defecto que usar Behat . Podemos tener los que necesitemos, para separar los steps de forma conveniente, pero eso es configuraci\u00f3n avanzada del entorno y no nos vamos a meter en eso. Editamos el archivo y copiamos el siguiente contenido en \u00e9l: <?php use Behat\\Behat\\Context\\Context ; use Behat\\Behat\\Tester\\Exception\\PendingException ; use Behat\\Gherkin\\Node\\PyStringNode ; use Behat\\Gherkin\\Node\\TableNode ; /** * Defines application features from the specific context. */ class FeatureContext implements Context { /** * Initializes context. * * Every scenario gets its own context instance. * You can also pass arbitrary arguments to the * context constructor through behat.yml. */ public function __construct () { } /** * @Given los siguientes men\u00fas: */ public function losSiguientesMenus ( TableNode $table ) { throw new PendingException (); } /** * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2 */ public function queHeCompradoMenusDelNumero ( $arg1 , $arg2 ) { throw new PendingException (); } /** * @When pido la cuenta recibo una factura de :arg1 euros */ public function pidoLaCuentaReciboUnaFacturaDeEuros ( $arg1 ) { throw new PendingException (); } /** * @When pago en efectivo con :arg1 euros */ public function pagoEnEfectivoConEuros ( $arg1 ) { throw new PendingException (); } /** * @Then la factura est\u00e1 pagada */ public function laFacturaEstaPagada () { throw new PendingException (); } /** * @Then he obtenido :arg1 puntos */ public function heObtenidoPuntos ( $arg1 ) { throw new PendingException (); } /** * @When pago con :arg1 puntos y :arg2 euros */ public function pagoConPuntosYEuros ( $arg1 , $arg2 ) { throw new PendingException (); } /** * @Then quedan :arg1 euros por pagar */ public function quedanEurosPorPagar ( $arg1 ) { throw new PendingException (); } /** * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2 */ public function queHeCompradoMenuDelNumero ( $arg1 , $arg2 ) { throw new PendingException (); } } Si volvemos a ejecutar behat: vendor/bin/behat Obtenemos algo distinto: 5 scenarios ( 5 pending ) 32 steps ( 5 pending, 27 skipped ) 0m0.03s ( 9 .54Mb ) Ya los escenarios no est\u00e1n como undefined sino como pending . Implementando el primer step \u00b6 El primer step es el que corresponde con la parte de antecedentes: #language: es Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10% Antecedentes: Dados los siguientes men\u00fas: | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Que corresponde al siguiente snippet <?php use Behat\\Behat\\Context\\Context ; use Behat\\Behat\\Tester\\Exception\\PendingException ; use Behat\\Gherkin\\Node\\PyStringNode ; use Behat\\Gherkin\\Node\\TableNode ; /** * Defines application features from the specific context. */ class FeatureContext implements Context { /** * @Given los siguientes men\u00fas: */ public function losSiguientesMenus ( TableNode $table ) { throw new PendingException (); } } Y aqu\u00ed nos surge la primera necesidad, necesitamos una clase para almacenar men\u00fas. PhpSpec \u00b6 PhpSpec es una herramienta para el dise\u00f1o de clases. Se usa, especialmente, para el dise\u00f1o de un modelo de dominio limpio, desacoplado y aislado sin involucrarse demasiado en la infraestructura. Principalmente lo que vamos a indicar con PhpSpec es la API de nuestra clase con el resto del dominio. Por el momento, para poder pasar la prueba que falla \"Dados los siguientes men\u00fas\", necesitamos una clase que nos ofrezca informaci\u00f3n del n\u00famero de men\u00fa y del precio. As\u00ed que vamos a empezar a describir nuestra clase con la ayuda de _PhpSpec : vendor/bin/phpspec desc Restaurant/Menu Warning Debido a que la barra invertida '\\' sirve como secuencia de escape en la consola, usamos la barra normal '/' para separar el espacio de nombres de la clase. Otra opci\u00f3n es usar doble barra invertida: vendor/bin/phpspec desc Restaurant \\\\ Menu Obtendremos un archivo en spec/Restaurant/MenuSpec.php : <?php namespace spec\\Restaurant ; use Restaurant\\Menu ; use PhpSpec\\ObjectBehavior ; use Prophecy\\Argument ; class MenuSpec extends ObjectBehavior { function it_is_initializable () { $this -> shouldHaveType ( Menu :: class ); } } La especificaci\u00f3n indica que existe una clase que debe ser iniciable y de tipo Restaurant\\Menu . Si ejecutamos las pruebas de PhpSpec : vendor/bin/phpspec run Obtendremos la siguiente salida: Restaurant \\M enu 11 ! is initializable class Restaurant \\M enu does not exist. ---- broken examples Restaurant/Menu 11 ! is initializable class Restaurant \\M enu does not exist. 1 specs 1 examples ( 1 broken ) 32ms Do you want me to create ` Restaurant \\M enu ` for you? [ Y/n ] Nos avisa que la clase que se quiere probar no existe y si quiere probarla por nosotros. Para sucesivas veces, en este tutorial responderemos siempre s\u00ed a esta circunstancia aunque no se indique. Class Restaurant \\M enu created in .../bdd-by-example/src/Restaurant/Menu.php. Restaurant \\M enu 11 \u2714 is initializable 1 specs 1 examples ( 1 passed ) 34ms Obteniendo una clase Menu en nuestro proyecto en src/Restaurant/Menu.php : <?php namespace Restaurant ; class Menu { } Vamos a seguir especificando los requisitos de nuestra clase para pasar la prueba. Concretamente necesitamos que nuestra clase sea capaz de indicar el n\u00famero de men\u00fa y el precio. Vamos a escribir la especificaci\u00f3n y la comentamos a continuaci\u00f3n. Modificamos nuestro MenuSpec.php as\u00ed: <?php namespace spec\\Restaurant ; use Restaurant\\Menu ; use PhpSpec\\ObjectBehavior ; use Prophecy\\Argument ; class MenuSpec extends ObjectBehavior { const NUMBER = 10 ; const PRICE = 2500 ; function let () { $this -> beConstructedWith ( self :: NUMBER , self :: PRICE ); } function it_is_initializable () { $this -> shouldHaveType ( Menu :: class ); } function it_has_a_menu_number () { $this -> number () -> shouldBe ( self :: NUMBER ); } function it_has_a_price () { $this -> price () -> shouldBe ( self :: PRICE ); } } Las l\u00edneas 24 y 29 especifican los dos comportamientos que esperamos de nuestra clase, devolver el n\u00famero y devolver el precio. Pero antes de devolver nada esa informaci\u00f3n debe incorporarse a trav\u00e9s del constructor. Para ello usamos la funci\u00f3n _ let_ (l\u00ednea 14), que sirve para configurar la prueba en su comienzo. En este caso, la l\u00ednea 16 construye la clase con el n\u00famero y el precio del men\u00fa. El uso de constantes es para ser m\u00e1s descriptivo a la hora de leer la prueba. Ya que hemos especificado como se construye la clase, especificamos los otros dos comportamientos. Info Estamos usando euros para los ejemplos. En realidad, y dado que PHP no tiene un tipo de datos para datos financieros, deber\u00edamos usar alguna clase Moneda o guardar los datos en c\u00e9ntimos para evitar el uso de decimales. Para simplificar el tutorial vamos a usar c\u00e9ntimos. As\u00ed que aunque en los test usemos euros en la clase Menu vamos a almacenar el valor en c\u00e9ntimos. Para indicar el n\u00famero de men\u00fa, indicamos que llamamos a un m\u00e9todo number() (l\u00ednea 26) que debe devolver el mismo valor que se pas\u00f3 al constructor. Para indicar el precio, lo mismo pero llamando a un m\u00e9todo price() (l\u00ednea 31). Ejecutamos otra vez PhpSpec , respondiendo afirmativamente a todas las preguntas: vendor/bin/phpspec run Obteniendo la siguiente salida: Restaurant \\M enu 19 ! is initializable method Restaurant \\M enu::__construct not found. 24 ! has a menu number method Restaurant \\M enu::__construct not found. 29 ! has a price method Restaurant \\M enu::__construct not found. ---- broken examples Restaurant/Menu 19 ! is initializable method Restaurant \\M enu::__construct not found. Restaurant/Menu 24 ! has a menu number method Restaurant \\M enu::__construct not found. Restaurant/Menu 29 ! has a price method Restaurant \\M enu::__construct not found. 1 specs 3 examples ( 3 broken ) 59ms Do you want me to create ` Restaurant \\M enu::__construct () ` for you? [ Y/n ] Do you want me to create ` Restaurant \\M enu::__construct () ` for you? [ Y/n ] Do you want me to create ` Restaurant \\M enu::__construct () ` for you? [ Y/n ] Method Restaurant \\M enu::__construct () has been created. Restaurant \\M enu 19 \u2714 is initializable 24 ! has a menu number method Restaurant \\M enu::number not found. 29 ! has a price method Restaurant \\M enu::price not found. ---- broken examples Restaurant/Menu 24 ! has a menu number method Restaurant \\M enu::number not found. Restaurant/Menu 29 ! has a price method Restaurant \\M enu::price not found. 1 specs 3 examples ( 1 passed, 2 broken ) 62ms Do you want me to create ` Restaurant \\M enu::number () ` for you? [ Y/n ] Do you want me to create ` Restaurant \\M enu::number () ` for you? [ Y/n ] Do you want me to create ` Restaurant \\M enu::number () ` for you? [ Y/n ] Method Restaurant \\M enu::number () has been created. Do you want me to create ` Restaurant \\M enu::price () ` for you? [ Y/n ] Do you want me to create ` Restaurant \\M enu::price () ` for you? [ Y/n ] Do you want me to create ` Restaurant \\M enu::price () ` for you? [ Y/n ] Method Restaurant \\M enu::price () has been created. Restaurant \\M enu 19 \u2714 is initializable 24 \u2718 has a menu number expected [ integer:10 ] , but got null. 29 \u2718 has a price expected [ integer:2500 ] , but got null. ---- failed examples Restaurant/Menu 24 \u2718 has a menu number expected [ integer:10 ] , but got null. Restaurant/Menu 29 \u2718 has a price expected [ integer:2500 ] , but got null. 1 specs 3 examples ( 1 passed, 2 failed ) 79ms Evidentemente las pruebas fallar\u00e1n al final, pero es el proceso normal en desarrollo orientado a pruebas/comportamiento. Analicemos que ha ocurrido en nuestra clase Menu : <?php namespace Restaurant ; class Menu { public function __construct ( $argument1 , $argument2 ) { // TODO: write logic here } public function number () { // TODO: write logic here } public function price () { // TODO: write logic here } } La especificaci\u00f3n de la prueba ha creado el esqueleto de nuestra clase, ahora solo queda implementar la funcionalidad para pasar la especificaci\u00f3n: <?php declare ( strict_types = 1 ); namespace Restaurant ; class Menu { private $number ; private $price ; public function __construct ( int $number , int $price ) { $this -> number = $number ; $this -> price = $price ; } public function number () : int { return $this -> number ; } public function price () : int { return $this -> price ; } } Ejecutamos las pruebas y comprobamos que pasan: bash$ vendor/bin/phpspec run Restaurant \\M enu 19 \u2714 is initializable 24 \u2714 has a menu number 29 \u2714 has a price 1 specs 3 examples ( 3 passed ) 60ms Ya tenemos nuestra primera clase completada que pasa la especificaci\u00f3n. Terminar de implementar los antecedentes \u00b6 Ahora podemos programar el paso para ir progresando en nuestros casos de uso. Editamos el archivo FeatureContext: <?php use Behat\\Behat\\Context\\Context ; use Behat\\Behat\\Tester\\Exception\\PendingException ; use Behat\\Gherkin\\Node\\PyStringNode ; use Behat\\Gherkin\\Node\\TableNode ; /** * Defines application features from the specific context. */ class FeatureContext implements Context { private $menus ; /** * Initializes context. * * Every scenario gets its own context instance. * You can also pass arbitrary arguments to the * context constructor through behat.yml. */ public function __construct () { $this -> menus = []; } /** * @Given los siguientes men\u00fas: */ public function losSiguientesMenus ( TableNode $table ) { foreach ( $table -> getHash () as $menu ) { $this -> menus [ $menu [ 'n\u00famero' ]] = new \\Restaurant\\Menu ( $menu [ 'n\u00famero' ], $menu [ 'precio' ] * 100 ); } } /** * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2 */ public function queHeCompradoMenusDelNumero ( $arg1 , $arg2 ) { throw new PendingException (); } /** * @When pido la cuenta recibo una factura de :arg1 euros */ public function pidoLaCuentaReciboUnaFacturaDeEuros ( $arg1 ) { throw new PendingException (); } /** * @When pago en efectivo con :arg1 euros */ public function pagoEnEfectivoConEuros ( $arg1 ) { throw new PendingException (); } /** * @Then la factura est\u00e1 pagada */ public function laFacturaEstaPagada () { throw new PendingException (); } /** * @Then he obtenido :arg1 puntos */ public function heObtenidoPuntos ( $arg1 ) { throw new PendingException (); } /** * @When pago con :arg1 puntos y :arg2 euros */ public function pagoConPuntosYEuros ( $arg1 , $arg2 ) { throw new PendingException (); } /** * @Then quedan :arg1 euros por pagar */ public function quedanEurosPorPagar ( $arg1 ) { throw new PendingException (); } /** * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2 */ public function queHeCompradoMenuDelNumero ( $arg1 , $arg2 ) { throw new PendingException (); } } Ejecutamos behat y vemos que ya hay pruebas que pasan: 5 scenarios ( 5 pending ) 32 steps ( 5 passed, 5 pending, 22 skipped ) 0m0.03s ( 9 .54Mb )","title":"Crear el proyecto"},{"location":"start-project/#crear-el-proyecto","text":"Vamos a implementar el proyecto que implemente las caracter\u00edsticas descritas en el apartado anterior. Vamos a hacer uso de un esqueleto que ya tiene configurado: composer create aulasoftwarelibre/bdd-by-example Se nos crear\u00e1 un directorio con todo lo que necesitamos para empezar a trabajar. Si analizamos el fichero composer.json veremos las dependencias de nuestro proyecto: { \"require-dev\" : { \"behat/behat\" : \"^3.4\" , \"phpspec/phpspec\" : \"^5.0\" , \"phpunit/phpunit\" : \"^7.0\" } }","title":"Crear el proyecto"},{"location":"start-project/#creacion-de-caracteristicas","text":"Las caracter\u00edsticas (ficheros .feature ) deben ir dentro del directorio features/ de nuestro proyecto. Tip Las cajas de ejemplo tienen un icono que, si lo pulsas, permiten copiar el contenido al portapapeles. \u00dasalo para ir m\u00e1s r\u00e1pido al copiar el c\u00f3digo. Crearemos dentro de dicho directorio un fichero llamado menu.feature con el contenido que describimos en el cap\u00edtulo anterior. #language: es Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10% Antecedentes: Dados los siguientes men\u00fas: | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Ganar puntos al pagar en efectivo Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos Escenario: Pagar con dinero y puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 10 puntos y 54 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Escenario: Pagar con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 500 puntos y 5 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Escenario: Intentar pagar el IVA con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 550 puntos y 0 euros Entonces quedan 5 euros por pagar Escenario: Comprar men\u00fas de varios tipos Dado que he comprado 1 men\u00fa del n\u00famero 1 Y que he comprado 2 men\u00fas del n\u00famero 2 Y que he comprado 2 men\u00fas del n\u00famero 3 Cuando pido la cuenta recibo una factura de 55 euros Y pago en efectivo con 55 euros Entonces la factura est\u00e1 pagada Y he obtenido 50 puntos","title":"Creaci\u00f3n de caracter\u00edsticas"},{"location":"start-project/#ejecucion-de-behat","text":"Ahora que tenemos las pruebas definidas vamos a ejecutar behat : vendor/bin/behat --snippets-for FeatureContext Obtendremos el resumen de la ejecuci\u00f3n de pruebas que contiene la siguiente informaci\u00f3n: 5 scenarios ( 5 undefined ) 32 steps ( 32 undefined ) 0m0.02s ( 9 .49Mb ) Lo que significa es que behat no reconoce ninguno de los step o pasos de los que se compone cada escenario. Esa parte debemos programarla nosotros. Para ello behat nos facilita el trabajo con una serie de snippets . Veamos uno: <?php /** * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2 */ public function queHeCompradoMenusDelNumero ( $arg1 , $arg2 ) { throw new PendingException (); } El step se compone de una cabecera con las palabras @Given , @When o @Then y una frase que coincide con la que hayamos determinado en el paso. Los n\u00fameros y las cadenas que se pongan entre comillas se convierten en par\u00e1metros del paso. Tambi\u00e9n es posible usar expresiones regulares, pero en esos casos debemos hacerlo a mano. El objetivo es meter todos estos snippets en el archivo de contexto que usa Behat . Si editamos el archivo features/bootstrap/FeatureContext.php , veremos el archivo de contexto por defecto que usar Behat . Podemos tener los que necesitemos, para separar los steps de forma conveniente, pero eso es configuraci\u00f3n avanzada del entorno y no nos vamos a meter en eso. Editamos el archivo y copiamos el siguiente contenido en \u00e9l: <?php use Behat\\Behat\\Context\\Context ; use Behat\\Behat\\Tester\\Exception\\PendingException ; use Behat\\Gherkin\\Node\\PyStringNode ; use Behat\\Gherkin\\Node\\TableNode ; /** * Defines application features from the specific context. */ class FeatureContext implements Context { /** * Initializes context. * * Every scenario gets its own context instance. * You can also pass arbitrary arguments to the * context constructor through behat.yml. */ public function __construct () { } /** * @Given los siguientes men\u00fas: */ public function losSiguientesMenus ( TableNode $table ) { throw new PendingException (); } /** * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2 */ public function queHeCompradoMenusDelNumero ( $arg1 , $arg2 ) { throw new PendingException (); } /** * @When pido la cuenta recibo una factura de :arg1 euros */ public function pidoLaCuentaReciboUnaFacturaDeEuros ( $arg1 ) { throw new PendingException (); } /** * @When pago en efectivo con :arg1 euros */ public function pagoEnEfectivoConEuros ( $arg1 ) { throw new PendingException (); } /** * @Then la factura est\u00e1 pagada */ public function laFacturaEstaPagada () { throw new PendingException (); } /** * @Then he obtenido :arg1 puntos */ public function heObtenidoPuntos ( $arg1 ) { throw new PendingException (); } /** * @When pago con :arg1 puntos y :arg2 euros */ public function pagoConPuntosYEuros ( $arg1 , $arg2 ) { throw new PendingException (); } /** * @Then quedan :arg1 euros por pagar */ public function quedanEurosPorPagar ( $arg1 ) { throw new PendingException (); } /** * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2 */ public function queHeCompradoMenuDelNumero ( $arg1 , $arg2 ) { throw new PendingException (); } } Si volvemos a ejecutar behat: vendor/bin/behat Obtenemos algo distinto: 5 scenarios ( 5 pending ) 32 steps ( 5 pending, 27 skipped ) 0m0.03s ( 9 .54Mb ) Ya los escenarios no est\u00e1n como undefined sino como pending .","title":"Ejecuci\u00f3n de behat"},{"location":"start-project/#implementando-el-primer-step","text":"El primer step es el que corresponde con la parte de antecedentes: #language: es Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10% Antecedentes: Dados los siguientes men\u00fas: | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Que corresponde al siguiente snippet <?php use Behat\\Behat\\Context\\Context ; use Behat\\Behat\\Tester\\Exception\\PendingException ; use Behat\\Gherkin\\Node\\PyStringNode ; use Behat\\Gherkin\\Node\\TableNode ; /** * Defines application features from the specific context. */ class FeatureContext implements Context { /** * @Given los siguientes men\u00fas: */ public function losSiguientesMenus ( TableNode $table ) { throw new PendingException (); } } Y aqu\u00ed nos surge la primera necesidad, necesitamos una clase para almacenar men\u00fas.","title":"Implementando el primer step"},{"location":"start-project/#phpspec","text":"PhpSpec es una herramienta para el dise\u00f1o de clases. Se usa, especialmente, para el dise\u00f1o de un modelo de dominio limpio, desacoplado y aislado sin involucrarse demasiado en la infraestructura. Principalmente lo que vamos a indicar con PhpSpec es la API de nuestra clase con el resto del dominio. Por el momento, para poder pasar la prueba que falla \"Dados los siguientes men\u00fas\", necesitamos una clase que nos ofrezca informaci\u00f3n del n\u00famero de men\u00fa y del precio. As\u00ed que vamos a empezar a describir nuestra clase con la ayuda de _PhpSpec : vendor/bin/phpspec desc Restaurant/Menu Warning Debido a que la barra invertida '\\' sirve como secuencia de escape en la consola, usamos la barra normal '/' para separar el espacio de nombres de la clase. Otra opci\u00f3n es usar doble barra invertida: vendor/bin/phpspec desc Restaurant \\\\ Menu Obtendremos un archivo en spec/Restaurant/MenuSpec.php : <?php namespace spec\\Restaurant ; use Restaurant\\Menu ; use PhpSpec\\ObjectBehavior ; use Prophecy\\Argument ; class MenuSpec extends ObjectBehavior { function it_is_initializable () { $this -> shouldHaveType ( Menu :: class ); } } La especificaci\u00f3n indica que existe una clase que debe ser iniciable y de tipo Restaurant\\Menu . Si ejecutamos las pruebas de PhpSpec : vendor/bin/phpspec run Obtendremos la siguiente salida: Restaurant \\M enu 11 ! is initializable class Restaurant \\M enu does not exist. ---- broken examples Restaurant/Menu 11 ! is initializable class Restaurant \\M enu does not exist. 1 specs 1 examples ( 1 broken ) 32ms Do you want me to create ` Restaurant \\M enu ` for you? [ Y/n ] Nos avisa que la clase que se quiere probar no existe y si quiere probarla por nosotros. Para sucesivas veces, en este tutorial responderemos siempre s\u00ed a esta circunstancia aunque no se indique. Class Restaurant \\M enu created in .../bdd-by-example/src/Restaurant/Menu.php. Restaurant \\M enu 11 \u2714 is initializable 1 specs 1 examples ( 1 passed ) 34ms Obteniendo una clase Menu en nuestro proyecto en src/Restaurant/Menu.php : <?php namespace Restaurant ; class Menu { } Vamos a seguir especificando los requisitos de nuestra clase para pasar la prueba. Concretamente necesitamos que nuestra clase sea capaz de indicar el n\u00famero de men\u00fa y el precio. Vamos a escribir la especificaci\u00f3n y la comentamos a continuaci\u00f3n. Modificamos nuestro MenuSpec.php as\u00ed: <?php namespace spec\\Restaurant ; use Restaurant\\Menu ; use PhpSpec\\ObjectBehavior ; use Prophecy\\Argument ; class MenuSpec extends ObjectBehavior { const NUMBER = 10 ; const PRICE = 2500 ; function let () { $this -> beConstructedWith ( self :: NUMBER , self :: PRICE ); } function it_is_initializable () { $this -> shouldHaveType ( Menu :: class ); } function it_has_a_menu_number () { $this -> number () -> shouldBe ( self :: NUMBER ); } function it_has_a_price () { $this -> price () -> shouldBe ( self :: PRICE ); } } Las l\u00edneas 24 y 29 especifican los dos comportamientos que esperamos de nuestra clase, devolver el n\u00famero y devolver el precio. Pero antes de devolver nada esa informaci\u00f3n debe incorporarse a trav\u00e9s del constructor. Para ello usamos la funci\u00f3n _ let_ (l\u00ednea 14), que sirve para configurar la prueba en su comienzo. En este caso, la l\u00ednea 16 construye la clase con el n\u00famero y el precio del men\u00fa. El uso de constantes es para ser m\u00e1s descriptivo a la hora de leer la prueba. Ya que hemos especificado como se construye la clase, especificamos los otros dos comportamientos. Info Estamos usando euros para los ejemplos. En realidad, y dado que PHP no tiene un tipo de datos para datos financieros, deber\u00edamos usar alguna clase Moneda o guardar los datos en c\u00e9ntimos para evitar el uso de decimales. Para simplificar el tutorial vamos a usar c\u00e9ntimos. As\u00ed que aunque en los test usemos euros en la clase Menu vamos a almacenar el valor en c\u00e9ntimos. Para indicar el n\u00famero de men\u00fa, indicamos que llamamos a un m\u00e9todo number() (l\u00ednea 26) que debe devolver el mismo valor que se pas\u00f3 al constructor. Para indicar el precio, lo mismo pero llamando a un m\u00e9todo price() (l\u00ednea 31). Ejecutamos otra vez PhpSpec , respondiendo afirmativamente a todas las preguntas: vendor/bin/phpspec run Obteniendo la siguiente salida: Restaurant \\M enu 19 ! is initializable method Restaurant \\M enu::__construct not found. 24 ! has a menu number method Restaurant \\M enu::__construct not found. 29 ! has a price method Restaurant \\M enu::__construct not found. ---- broken examples Restaurant/Menu 19 ! is initializable method Restaurant \\M enu::__construct not found. Restaurant/Menu 24 ! has a menu number method Restaurant \\M enu::__construct not found. Restaurant/Menu 29 ! has a price method Restaurant \\M enu::__construct not found. 1 specs 3 examples ( 3 broken ) 59ms Do you want me to create ` Restaurant \\M enu::__construct () ` for you? [ Y/n ] Do you want me to create ` Restaurant \\M enu::__construct () ` for you? [ Y/n ] Do you want me to create ` Restaurant \\M enu::__construct () ` for you? [ Y/n ] Method Restaurant \\M enu::__construct () has been created. Restaurant \\M enu 19 \u2714 is initializable 24 ! has a menu number method Restaurant \\M enu::number not found. 29 ! has a price method Restaurant \\M enu::price not found. ---- broken examples Restaurant/Menu 24 ! has a menu number method Restaurant \\M enu::number not found. Restaurant/Menu 29 ! has a price method Restaurant \\M enu::price not found. 1 specs 3 examples ( 1 passed, 2 broken ) 62ms Do you want me to create ` Restaurant \\M enu::number () ` for you? [ Y/n ] Do you want me to create ` Restaurant \\M enu::number () ` for you? [ Y/n ] Do you want me to create ` Restaurant \\M enu::number () ` for you? [ Y/n ] Method Restaurant \\M enu::number () has been created. Do you want me to create ` Restaurant \\M enu::price () ` for you? [ Y/n ] Do you want me to create ` Restaurant \\M enu::price () ` for you? [ Y/n ] Do you want me to create ` Restaurant \\M enu::price () ` for you? [ Y/n ] Method Restaurant \\M enu::price () has been created. Restaurant \\M enu 19 \u2714 is initializable 24 \u2718 has a menu number expected [ integer:10 ] , but got null. 29 \u2718 has a price expected [ integer:2500 ] , but got null. ---- failed examples Restaurant/Menu 24 \u2718 has a menu number expected [ integer:10 ] , but got null. Restaurant/Menu 29 \u2718 has a price expected [ integer:2500 ] , but got null. 1 specs 3 examples ( 1 passed, 2 failed ) 79ms Evidentemente las pruebas fallar\u00e1n al final, pero es el proceso normal en desarrollo orientado a pruebas/comportamiento. Analicemos que ha ocurrido en nuestra clase Menu : <?php namespace Restaurant ; class Menu { public function __construct ( $argument1 , $argument2 ) { // TODO: write logic here } public function number () { // TODO: write logic here } public function price () { // TODO: write logic here } } La especificaci\u00f3n de la prueba ha creado el esqueleto de nuestra clase, ahora solo queda implementar la funcionalidad para pasar la especificaci\u00f3n: <?php declare ( strict_types = 1 ); namespace Restaurant ; class Menu { private $number ; private $price ; public function __construct ( int $number , int $price ) { $this -> number = $number ; $this -> price = $price ; } public function number () : int { return $this -> number ; } public function price () : int { return $this -> price ; } } Ejecutamos las pruebas y comprobamos que pasan: bash$ vendor/bin/phpspec run Restaurant \\M enu 19 \u2714 is initializable 24 \u2714 has a menu number 29 \u2714 has a price 1 specs 3 examples ( 3 passed ) 60ms Ya tenemos nuestra primera clase completada que pasa la especificaci\u00f3n.","title":"PhpSpec"},{"location":"start-project/#terminar-de-implementar-los-antecedentes","text":"Ahora podemos programar el paso para ir progresando en nuestros casos de uso. Editamos el archivo FeatureContext: <?php use Behat\\Behat\\Context\\Context ; use Behat\\Behat\\Tester\\Exception\\PendingException ; use Behat\\Gherkin\\Node\\PyStringNode ; use Behat\\Gherkin\\Node\\TableNode ; /** * Defines application features from the specific context. */ class FeatureContext implements Context { private $menus ; /** * Initializes context. * * Every scenario gets its own context instance. * You can also pass arbitrary arguments to the * context constructor through behat.yml. */ public function __construct () { $this -> menus = []; } /** * @Given los siguientes men\u00fas: */ public function losSiguientesMenus ( TableNode $table ) { foreach ( $table -> getHash () as $menu ) { $this -> menus [ $menu [ 'n\u00famero' ]] = new \\Restaurant\\Menu ( $menu [ 'n\u00famero' ], $menu [ 'precio' ] * 100 ); } } /** * @Given que he comprado :arg1 men\u00fas del n\u00famero :arg2 */ public function queHeCompradoMenusDelNumero ( $arg1 , $arg2 ) { throw new PendingException (); } /** * @When pido la cuenta recibo una factura de :arg1 euros */ public function pidoLaCuentaReciboUnaFacturaDeEuros ( $arg1 ) { throw new PendingException (); } /** * @When pago en efectivo con :arg1 euros */ public function pagoEnEfectivoConEuros ( $arg1 ) { throw new PendingException (); } /** * @Then la factura est\u00e1 pagada */ public function laFacturaEstaPagada () { throw new PendingException (); } /** * @Then he obtenido :arg1 puntos */ public function heObtenidoPuntos ( $arg1 ) { throw new PendingException (); } /** * @When pago con :arg1 puntos y :arg2 euros */ public function pagoConPuntosYEuros ( $arg1 , $arg2 ) { throw new PendingException (); } /** * @Then quedan :arg1 euros por pagar */ public function quedanEurosPorPagar ( $arg1 ) { throw new PendingException (); } /** * @Given que he comprado :arg1 men\u00fa del n\u00famero :arg2 */ public function queHeCompradoMenuDelNumero ( $arg1 , $arg2 ) { throw new PendingException (); } } Ejecutamos behat y vemos que ya hay pruebas que pasan: 5 scenarios ( 5 pending ) 32 steps ( 5 passed, 5 pending, 22 skipped ) 0m0.03s ( 9 .54Mb )","title":"Terminar de implementar los antecedentes"},{"location":"third-scenario/","text":"Tercer escenario \u00b6 Vamos a implementar el tercer escenario Escenario: Pagar con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 500 puntos y 5 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Si ejecutamos la prueba: vendor/bin/behat features/menu.feature:30 Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Pagar con puntos # features/menu.feature:30 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago con 500 puntos y 5 euros # FeatureContext::pagoConPuntosYEuros() Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 0 puntos # FeatureContext::heObtenidoPuntos() 1 scenario ( 1 passed ) 6 steps ( 6 passed ) 0m0.02s ( 10 .09Mb ) \u00a1La prueba pasa! No tenemos que implementar nada nuevo. Una cuesti\u00f3n importante a la hora de escribir los pasos ( steps ), es intentarlos escribir siempre de la misma manera, de tal manera que podamos reutilizarlos en sucesivas pruebas. De esta manera, en muchas ocasiones comprobaremos que no tenemos que implementar escenarios porque ya se ejecutan con los pasos definidos en los anteriores.","title":"Tercer escenario"},{"location":"third-scenario/#tercer-escenario","text":"Vamos a implementar el tercer escenario Escenario: Pagar con puntos Dado que he comprado 5 men\u00fas del n\u00famero 1 Cuando pido la cuenta recibo una factura de 55 euros Y pago con 500 puntos y 5 euros Entonces la factura est\u00e1 pagada Y he obtenido 0 puntos Si ejecutamos la prueba: vendor/bin/behat features/menu.feature:30 Caracter\u00edstica: Pagar un men\u00fa Reglas: - 1 punto por cada euro. - 10 puntos equivalen a un descuento de 1 euros. - El IVA es del 10 % Antecedentes: # features/menu.feature:9 Dados los siguientes men\u00fas: # FeatureContext::losSiguientesMenus() | n\u00famero | precio | | 1 | 10 | | 2 | 12 | | 3 | 8 | Escenario: Pagar con puntos # features/menu.feature:30 Dado que he comprado 5 men\u00fas del n\u00famero 1 # FeatureContext::queHeCompradoMenusDelNumero() Cuando pido la cuenta recibo una factura de 55 euros # FeatureContext::pidoLaCuentaReciboUnaFacturaDeEuros() Y pago con 500 puntos y 5 euros # FeatureContext::pagoConPuntosYEuros() Entonces la factura est\u00e1 pagada # FeatureContext::laFacturaEstaPagada() Y he obtenido 0 puntos # FeatureContext::heObtenidoPuntos() 1 scenario ( 1 passed ) 6 steps ( 6 passed ) 0m0.02s ( 10 .09Mb ) \u00a1La prueba pasa! No tenemos que implementar nada nuevo. Una cuesti\u00f3n importante a la hora de escribir los pasos ( steps ), es intentarlos escribir siempre de la misma manera, de tal manera que podamos reutilizarlos en sucesivas pruebas. De esta manera, en muchas ocasiones comprobaremos que no tenemos que implementar escenarios porque ya se ejecutan con los pasos definidos en los anteriores.","title":"Tercer escenario"}]}